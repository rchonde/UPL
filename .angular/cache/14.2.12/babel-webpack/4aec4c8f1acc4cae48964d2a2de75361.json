{"ast":null,"code":"/**\r\n * CSV parser.\r\n */\nimport { __extends } from \"tslib\";\n/**\r\n * ============================================================================\r\n * IMPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\n\nimport { DataParser } from \"./DataParser\";\nimport * as $type from \"../utils/Type\";\nimport * as $array from \"../utils/Array\";\n/**\r\n * Define possible separators.\r\n */\n\nvar separators = [\",\", \";\", \"\\t\"];\n/**\r\n * A parser for CSV format.\r\n *\r\n * @important\r\n */\n\nvar CSVParser =\n/** @class */\nfunction (_super) {\n  __extends(CSVParser, _super);\n\n  function CSVParser() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    /**\r\n     * Content-type suitable for CSV format.\r\n     */\n\n\n    _this.contentType = \"text/csv\";\n    /**\r\n     * Parser options.\r\n     *\r\n     * @see {@link ICSVOptions} for description of each option\r\n     */\n\n    _this.options = {\n      delimiter: \"\",\n      reverse: false,\n      skipRows: 0,\n      skipEmpty: true,\n      useColumnNames: false\n    };\n    return _this;\n  }\n  /**\r\n   * Tests if the format is CSV.\r\n   *\r\n   * @param data  Source data\r\n   * @return Is it CSV?\r\n   */\n\n\n  CSVParser.isCSV = function (data) {\n    return CSVParser.getDelimiterFromData(data) ? true : false;\n  };\n  /**\r\n   * Tries to determine a column separator.\r\n   *\r\n   * @param data  Source data\r\n   * @return Separator\r\n   */\n\n\n  CSVParser.getDelimiterFromData = function (data) {\n    // We're going to take first few lines of the CSV with different\n    // possible separators and check if it results in same number of columns.\n    // If it does, we're going to assume it's a CSV\n    var lines = data.split(\"\\n\");\n    var len = lines.length;\n    var separator;\n    $array.each(separators, function (sep) {\n      var columns = 0,\n          lineColums = 0; // TODO replace with iterators\n\n      for (var i = 0; i < len; ++i) {\n        // Get number of columns in a line\n        columns = lines[i].split(sep).length;\n\n        if (columns > 1) {\n          // More than one column - possible candidate\n          if (lineColums === 0) {\n            // First line\n            lineColums = columns;\n          } else if (columns != lineColums) {\n            // Incorrect number of columns, give up on this separator\n            lineColums = 0;\n            break;\n          }\n        } else {\n          // Not this separator\n          // Not point in continuing\n          lineColums = 0;\n          break;\n        }\n      } // Check if we have a winner\n\n\n      if (lineColums) {\n        separator = sep;\n      }\n    });\n    return separator;\n  };\n  /**\r\n   * Parses and returns data.\r\n   *\r\n   * @param data  Unparsed data\r\n   * @return Parsed data\r\n   */\n\n\n  CSVParser.prototype.parse = function (csv) {\n    // Check if we have delimiter set\n    if (!this.options.delimiter) {\n      this.options.delimiter = CSVParser.getDelimiterFromData(csv);\n    } // Get CSV data as array\n\n\n    var data = this.CSVToArray(csv, this.options.delimiter); // Do we need to cast some fields to numbers?\n\n    var empty = $type.hasValue(this.options.emptyAs);\n    var numbers = this.parsableNumbers;\n    var dates = this.parsableDates; // Init resuling array\n\n    var res = [],\n        cols = [],\n        col,\n        i; // Skip rows\n\n    for (i = 0; i < this.options.skipRows; i++) {\n      data.shift();\n    } // First row holds column names?\n\n\n    if (this.options.useColumnNames) {\n      cols = data.shift(); // Normalize column names\n\n      for (var x = 0; x < cols.length; x++) {\n        // trim\n        col = $type.hasValue(cols[x]) ? cols[x].replace(/^\\s+|\\s+$/gm, \"\") : \"\"; // Check for empty\n\n        if (\"\" === col) {\n          col = \"col\" + x;\n        }\n\n        cols[x] = col;\n      }\n    } // Iterate through the result set\n\n\n    var row;\n\n    while (true) {\n      row = this.options.reverse ? data.pop() : data.shift();\n\n      if (!row) {\n        break;\n      }\n\n      if (this.options.skipEmpty && row.length === 1 && row[0] === \"\") {\n        continue;\n      }\n\n      var dataPoint = {};\n\n      for (i = 0; i < row.length; i++) {\n        col = undefined === cols[i] ? \"col\" + i : cols[i];\n        dataPoint[col] = row[i] === \"\" ? this.options.emptyAs : row[i]; // Convert\n\n        if (empty) {\n          dataPoint[col] = this.maybeToEmpty(dataPoint[col]);\n        }\n\n        if (numbers) {\n          dataPoint[col] = this.maybeToNumber(col, dataPoint[col]);\n        }\n\n        if (dates) {\n          dataPoint[col] = this.maybeToDate(col, dataPoint[col]);\n        }\n      }\n\n      res.push(dataPoint);\n    }\n\n    return res;\n  };\n  /**\r\n   * Converts CSV into array.\r\n   *\r\n   * The functionality of this function is taken from here:\r\n   * http://www.bennadel.com/blog/1504-ask-ben-parsing-csv-strings-with-javascript-exec-regular-expression-command.htm\r\n   *\r\n   * @param data       Source data\r\n   * @param delimiter  Column delimiter\r\n   * @return Parsed array\r\n   */\n\n\n  CSVParser.prototype.CSVToArray = function (data, delimiter) {\n    // Check to see if the delimiter is defined. If not,\n    // then default to comma.\n    delimiter = delimiter || ','; // Create a regular expression to parse the CSV values.\n\n    var objPattern = new RegExp( // Delimiters.\n    \"(\\\\\" + delimiter + \"|\\\\r?\\\\n|\\\\r|^)\" + // Quoted fields.\n    \"(?:\\\"([^\\\"]*(?:\\\"\\\"[^\\\"]*)*)\\\"|\" + // Standard fields.\n    \"([^\\\"\\\\\" + delimiter + \"\\\\r\\\\n]*))\", \"gi\"); // Create an array to hold our data. Give the array\n    // a default empty first row.\n\n    var arrData = [[]]; // Create an array to hold our individual pattern\n    // matching groups.\n\n    var arrMatches = null; // Keep looping over the regular expression matches\n    // until we can no longer find a match.\n\n    while (true) {\n      arrMatches = objPattern.exec(data);\n\n      if (!arrMatches) {\n        break;\n      } // Get the delimiter that was found.\n\n\n      var strMatchedDelimiter = arrMatches[1]; // Check to see if the given delimiter has a length\n      // (is not the start of string) and if it matches\n      // field delimiter. If id does not, then we know\n      // that this delimiter is a row delimiter.\n\n      if (strMatchedDelimiter.length && strMatchedDelimiter !== delimiter) {\n        // Since we have reached a new row of data,\n        // add an empty row to our data array.\n        arrData.push([]);\n      } // Now that we have our delimiter out of the way,\n      // let's check to see which kind of value we\n      // captured (quoted or unquoted).\n\n\n      var strMatchedValue = void 0;\n\n      if (arrMatches[2]) {\n        // We found a quoted value. When we capture\n        // this value, unescape any double quotes.\n        strMatchedValue = arrMatches[2].replace(new RegExp(\"\\\"\\\"\", \"g\"), \"\\\"\");\n      } else {\n        // We found a non-quoted value.\n        strMatchedValue = arrMatches[3];\n      } // Now that we have our value string, let's add\n      // it to the data array.\n\n\n      arrData[arrData.length - 1].push(strMatchedValue);\n    } // Return the parsed data.\n\n\n    return arrData;\n  };\n\n  return CSVParser;\n}(DataParser);\n\nexport { CSVParser };","map":{"version":3,"names":["__extends","DataParser","$type","$array","separators","CSVParser","_super","_this","apply","arguments","contentType","options","delimiter","reverse","skipRows","skipEmpty","useColumnNames","isCSV","data","getDelimiterFromData","lines","split","len","length","separator","each","sep","columns","lineColums","i","prototype","parse","csv","CSVToArray","empty","hasValue","emptyAs","numbers","parsableNumbers","dates","parsableDates","res","cols","col","shift","x","replace","row","pop","dataPoint","undefined","maybeToEmpty","maybeToNumber","maybeToDate","push","objPattern","RegExp","arrData","arrMatches","exec","strMatchedDelimiter","strMatchedValue"],"sources":["D:/APPLICATION/UI/UPL/NEW/node_modules/@amcharts/amcharts4/.internal/core/data/CSVParser.js"],"sourcesContent":["/**\r\n * CSV parser.\r\n */\r\nimport { __extends } from \"tslib\";\r\n/**\r\n * ============================================================================\r\n * IMPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\r\nimport { DataParser } from \"./DataParser\";\r\nimport * as $type from \"../utils/Type\";\r\nimport * as $array from \"../utils/Array\";\r\n/**\r\n * Define possible separators.\r\n */\r\nvar separators = [\",\", \";\", \"\\t\"];\r\n/**\r\n * A parser for CSV format.\r\n *\r\n * @important\r\n */\r\nvar CSVParser = /** @class */ (function (_super) {\r\n    __extends(CSVParser, _super);\r\n    function CSVParser() {\r\n        var _this = _super !== null && _super.apply(this, arguments) || this;\r\n        /**\r\n         * Content-type suitable for CSV format.\r\n         */\r\n        _this.contentType = \"text/csv\";\r\n        /**\r\n         * Parser options.\r\n         *\r\n         * @see {@link ICSVOptions} for description of each option\r\n         */\r\n        _this.options = {\r\n            delimiter: \"\",\r\n            reverse: false,\r\n            skipRows: 0,\r\n            skipEmpty: true,\r\n            useColumnNames: false\r\n        };\r\n        return _this;\r\n    }\r\n    /**\r\n     * Tests if the format is CSV.\r\n     *\r\n     * @param data  Source data\r\n     * @return Is it CSV?\r\n     */\r\n    CSVParser.isCSV = function (data) {\r\n        return CSVParser.getDelimiterFromData(data) ? true : false;\r\n    };\r\n    /**\r\n     * Tries to determine a column separator.\r\n     *\r\n     * @param data  Source data\r\n     * @return Separator\r\n     */\r\n    CSVParser.getDelimiterFromData = function (data) {\r\n        // We're going to take first few lines of the CSV with different\r\n        // possible separators and check if it results in same number of columns.\r\n        // If it does, we're going to assume it's a CSV\r\n        var lines = data.split(\"\\n\");\r\n        var len = lines.length;\r\n        var separator;\r\n        $array.each(separators, function (sep) {\r\n            var columns = 0, lineColums = 0;\r\n            // TODO replace with iterators\r\n            for (var i = 0; i < len; ++i) {\r\n                // Get number of columns in a line\r\n                columns = lines[i].split(sep).length;\r\n                if (columns > 1) {\r\n                    // More than one column - possible candidate\r\n                    if (lineColums === 0) {\r\n                        // First line\r\n                        lineColums = columns;\r\n                    }\r\n                    else if (columns != lineColums) {\r\n                        // Incorrect number of columns, give up on this separator\r\n                        lineColums = 0;\r\n                        break;\r\n                    }\r\n                }\r\n                else {\r\n                    // Not this separator\r\n                    // Not point in continuing\r\n                    lineColums = 0;\r\n                    break;\r\n                }\r\n            }\r\n            // Check if we have a winner\r\n            if (lineColums) {\r\n                separator = sep;\r\n            }\r\n        });\r\n        return separator;\r\n    };\r\n    /**\r\n     * Parses and returns data.\r\n     *\r\n     * @param data  Unparsed data\r\n     * @return Parsed data\r\n     */\r\n    CSVParser.prototype.parse = function (csv) {\r\n        // Check if we have delimiter set\r\n        if (!this.options.delimiter) {\r\n            this.options.delimiter = CSVParser.getDelimiterFromData(csv);\r\n        }\r\n        // Get CSV data as array\r\n        var data = this.CSVToArray(csv, this.options.delimiter);\r\n        // Do we need to cast some fields to numbers?\r\n        var empty = $type.hasValue(this.options.emptyAs);\r\n        var numbers = this.parsableNumbers;\r\n        var dates = this.parsableDates;\r\n        // Init resuling array\r\n        var res = [], cols = [], col, i;\r\n        // Skip rows\r\n        for (i = 0; i < this.options.skipRows; i++) {\r\n            data.shift();\r\n        }\r\n        // First row holds column names?\r\n        if (this.options.useColumnNames) {\r\n            cols = data.shift();\r\n            // Normalize column names\r\n            for (var x = 0; x < cols.length; x++) {\r\n                // trim\r\n                col = $type.hasValue(cols[x]) ? cols[x].replace(/^\\s+|\\s+$/gm, \"\") : \"\";\r\n                // Check for empty\r\n                if (\"\" === col) {\r\n                    col = \"col\" + x;\r\n                }\r\n                cols[x] = col;\r\n            }\r\n        }\r\n        // Iterate through the result set\r\n        var row;\r\n        while (true) {\r\n            row = this.options.reverse ? data.pop() : data.shift();\r\n            if (!row) {\r\n                break;\r\n            }\r\n            if (this.options.skipEmpty && row.length === 1 && row[0] === \"\") {\r\n                continue;\r\n            }\r\n            var dataPoint = {};\r\n            for (i = 0; i < row.length; i++) {\r\n                col = undefined === cols[i] ? \"col\" + i : cols[i];\r\n                dataPoint[col] = row[i] === \"\" ? this.options.emptyAs : row[i];\r\n                // Convert\r\n                if (empty) {\r\n                    dataPoint[col] = this.maybeToEmpty(dataPoint[col]);\r\n                }\r\n                if (numbers) {\r\n                    dataPoint[col] = this.maybeToNumber(col, dataPoint[col]);\r\n                }\r\n                if (dates) {\r\n                    dataPoint[col] = this.maybeToDate(col, dataPoint[col]);\r\n                }\r\n            }\r\n            res.push(dataPoint);\r\n        }\r\n        return res;\r\n    };\r\n    /**\r\n     * Converts CSV into array.\r\n     *\r\n     * The functionality of this function is taken from here:\r\n     * http://www.bennadel.com/blog/1504-ask-ben-parsing-csv-strings-with-javascript-exec-regular-expression-command.htm\r\n     *\r\n     * @param data       Source data\r\n     * @param delimiter  Column delimiter\r\n     * @return Parsed array\r\n     */\r\n    CSVParser.prototype.CSVToArray = function (data, delimiter) {\r\n        // Check to see if the delimiter is defined. If not,\r\n        // then default to comma.\r\n        delimiter = (delimiter || ',');\r\n        // Create a regular expression to parse the CSV values.\r\n        var objPattern = new RegExp((\r\n        // Delimiters.\r\n        \"(\\\\\" + delimiter + \"|\\\\r?\\\\n|\\\\r|^)\" +\r\n            // Quoted fields.\r\n            \"(?:\\\"([^\\\"]*(?:\\\"\\\"[^\\\"]*)*)\\\"|\" +\r\n            // Standard fields.\r\n            \"([^\\\"\\\\\" + delimiter + \"\\\\r\\\\n]*))\"), \"gi\");\r\n        // Create an array to hold our data. Give the array\r\n        // a default empty first row.\r\n        var arrData = [\r\n            []\r\n        ];\r\n        // Create an array to hold our individual pattern\r\n        // matching groups.\r\n        var arrMatches = null;\r\n        // Keep looping over the regular expression matches\r\n        // until we can no longer find a match.\r\n        while (true) {\r\n            arrMatches = objPattern.exec(data);\r\n            if (!arrMatches) {\r\n                break;\r\n            }\r\n            // Get the delimiter that was found.\r\n            var strMatchedDelimiter = arrMatches[1];\r\n            // Check to see if the given delimiter has a length\r\n            // (is not the start of string) and if it matches\r\n            // field delimiter. If id does not, then we know\r\n            // that this delimiter is a row delimiter.\r\n            if (strMatchedDelimiter.length &&\r\n                (strMatchedDelimiter !== delimiter)) {\r\n                // Since we have reached a new row of data,\r\n                // add an empty row to our data array.\r\n                arrData.push([]);\r\n            }\r\n            // Now that we have our delimiter out of the way,\r\n            // let's check to see which kind of value we\r\n            // captured (quoted or unquoted).\r\n            var strMatchedValue = void 0;\r\n            if (arrMatches[2]) {\r\n                // We found a quoted value. When we capture\r\n                // this value, unescape any double quotes.\r\n                strMatchedValue = arrMatches[2].replace(new RegExp(\"\\\"\\\"\", \"g\"), \"\\\"\");\r\n            }\r\n            else {\r\n                // We found a non-quoted value.\r\n                strMatchedValue = arrMatches[3];\r\n            }\r\n            // Now that we have our value string, let's add\r\n            // it to the data array.\r\n            arrData[arrData.length - 1].push(strMatchedValue);\r\n        }\r\n        // Return the parsed data.\r\n        return (arrData);\r\n    };\r\n    return CSVParser;\r\n}(DataParser));\r\nexport { CSVParser };\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}