{"ast":null,"code":"/**\r\n * Morpher module contains functionality that allows morphing one polygon to\r\n * another.\r\n */\nimport { __extends } from \"tslib\";\n/**\r\n * ============================================================================\r\n * IMPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\n\nimport { BaseObject } from \"../Base\";\nimport { Animation, AnimationDisposer } from \"../utils/Animation\";\nimport * as $math from \"../utils/Math\";\nimport * as $ease from \"../utils/Ease\";\nimport * as $type from \"../utils/Type\";\n/**\r\n * Morpher can be used to morph one polygon to some other polygon.\r\n */\n\nvar Morpher =\n/** @class */\nfunction (_super) {\n  __extends(Morpher, _super);\n  /**\r\n   * Constructor.\r\n   *\r\n   * @param morphable An object to morph\r\n   */\n\n\n  function Morpher(morphable) {\n    var _this = _super.call(this) || this;\n    /**\r\n     * A storage for measurements.\r\n     */\n\n\n    _this._bboxes = [];\n    /**\r\n     * Duration of the morphing animation in milliseconds.\r\n     */\n\n    _this.morphDuration = 800;\n    /**\r\n     * An easing function to use for morphing animation.\r\n     *\r\n     * @see {@link Ease}\r\n     */\n\n    _this.morphEasing = $ease.cubicOut;\n    /**\r\n     * If set to `true`, all separate parts of the multi-part polygon will\r\n     * morph into a single circle or polygon when using built-in methods\r\n     * `morphToCircle()` or `morphToPolygon()`.\r\n     *\r\n     * Otherwise each separate part of polygon will morph to individual target\r\n     * circle or polgyon.\r\n     */\n\n    _this.morphToSingle = true;\n    /**\r\n     * A ratio to scale morphed object in relation to the source object.\r\n     */\n\n    _this.scaleRatio = 1;\n    _this.className = \"Morpher\";\n    _this.morphable = morphable;\n\n    _this.applyTheme();\n\n    return _this;\n  }\n  /**\r\n   * Morphs a polygon to another polygon.\r\n   *\r\n   * @param toPoints  Corner points of the target shape\r\n   * @param duration  Duration in milliseconds\r\n   * @param easing    Easing function\r\n   * @return Animation\r\n   */\n\n\n  Morpher.prototype.morphToPolygon = function (toPoints, duration, easing) {\n    var points = this.morphable.currentPoints;\n\n    if (points && toPoints) {\n      this.sortPoints(points);\n      this.sortPoints(toPoints);\n      this._morphFromPointsReal = [];\n      this._morphToPointsReal = [];\n\n      if (!$type.hasValue(duration)) {\n        duration = this.morphDuration;\n      }\n\n      if (!$type.hasValue(easing)) {\n        easing = this.morphEasing;\n      }\n\n      this._morphFromPointsReal = this.normalizePoints(toPoints, points);\n      this._morphToPointsReal = this.normalizePoints(points, toPoints);\n      this.morphable.currentPoints = this._morphFromPointsReal;\n      var animation = new Animation(this, {\n        property: \"morphProgress\",\n        from: 0,\n        to: 1\n      }, duration, easing);\n\n      this._disposers.push(animation);\n\n      animation.start();\n      return animation;\n    }\n  };\n  /**\r\n   * [normalizePoints description]\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @todo Description\r\n   * @param pointsA  Point A\r\n   * @param pointsB  Point B\r\n   * @return Normalized points\r\n   */\n\n\n  Morpher.prototype.normalizePoints = function (pointsA, pointsB) {\n    for (var i = 0, len = pointsA.length; i < len; i++) {\n      var surfaceA = pointsA[i][0];\n      var holeA = pointsA[i][1];\n      var bboxA = $type.getValue($math.getBBox(surfaceA));\n      var middleX = bboxA.x + bboxA.width;\n      var middleY = bboxA.y + bboxA.height; // check if we have the same in PointsB\n\n      if (!pointsB[i]) {\n        pointsB[i] = [];\n      } // check if we have surface in pointsB\n\n\n      if (surfaceA && !pointsB[i][0]) {\n        pointsB[i][0] = [{\n          x: middleX,\n          y: middleY\n        }, {\n          x: middleX,\n          y: middleY\n        }];\n      }\n\n      if (pointsB[i][0]) {\n        pointsB[i][0] = this.addPoints(pointsB[i][0], surfaceA.length);\n        var distance = Infinity;\n        var splitAt = 0;\n\n        for (var a = 0; a < pointsB[i][0].length; a++) {\n          var newDistance = $math.getDistance(pointsB[i][0][a], surfaceA[0]);\n\n          if (newDistance < distance) {\n            splitAt = a;\n            distance = newDistance;\n          }\n        }\n\n        var partA = pointsB[i][0].slice(0, splitAt);\n        var partB = pointsB[i][0].slice(splitAt);\n        pointsB[i][0] = partB.concat(partA);\n      }\n\n      if (holeA) {\n        if (!pointsB[i][1]) {\n          pointsB[i][1] = [{\n            x: middleX,\n            y: middleY\n          }, {\n            x: middleX,\n            y: middleY\n          }];\n        }\n\n        pointsB[i][1] = this.addPoints(pointsB[i][1], holeA.length);\n      }\n    }\n\n    return pointsB;\n  };\n  /**\r\n   * [sortPoints description]\r\n   *\r\n   * @ignore Exclude from doc\r\n   * @todo Description\r\n   * @param points  [description]\r\n   * @return                        common bbox of points\r\n   */\n\n\n  Morpher.prototype.sortPoints = function (points) {\n    points.sort(function (a, b) {\n      var bbox1 = $type.getValue($math.getBBox(a[0]));\n      var bbox2 = $type.getValue($math.getBBox(b[0]));\n\n      if (bbox1.width * bbox1.height > bbox2.width * bbox2.height) {\n        return -1;\n      } else {\n        return 1;\n      }\n    });\n    var bboxes = [];\n\n    for (var i = 0, len = points.length; i < len; i++) {\n      var surface = points[i][0];\n\n      if (surface) {\n        bboxes.push($type.getValue($math.getBBox(surface)));\n      }\n    }\n\n    return $math.getCommonRectangle(bboxes);\n  };\n  /**\r\n   * Morphs polygon to a circle (it is actually a polygon which makes a circle).\r\n   *\r\n   * @param radius    Target circle radius (px)\r\n   * @param duration  Duration (ms)\r\n   * @param easing    Easing function\r\n   * @return Animation\r\n   */\n\n\n  Morpher.prototype.morphToCircle = function (radius, duration, easing) {\n    var points = this.morphable.points;\n    var commonBBox = this.sortPoints(points);\n    this._morphFromPointsReal = [];\n    this._morphToPointsReal = [];\n\n    if (!$type.hasValue(duration)) {\n      duration = this.morphDuration;\n    }\n\n    if (!$type.hasValue(easing)) {\n      easing = this.morphEasing;\n    } // surface\n\n\n    for (var i = 0, len = points.length; i < len; i++) {\n      var surface = points[i][0];\n      var hole = points[i][1];\n      this._morphFromPointsReal[i] = [];\n      this._morphToPointsReal[i] = [];\n\n      if (surface) {\n        var toPoints = surface;\n        var fromPoints = surface;\n        var bbox = $type.getValue($math.getBBox(fromPoints)); // this._bboxes[i];\n\n        if (this.morphToSingle) {\n          bbox = $type.getValue(commonBBox);\n        }\n\n        var middleX = bbox.x + bbox.width / 2;\n        var middleY = bbox.y + bbox.height / 2;\n        var realRadius = radius;\n\n        if (!$type.isNumber(realRadius)) {\n          realRadius = Math.min(bbox.width / 2, bbox.height / 2);\n        }\n\n        toPoints = []; // find angle for the first point\n\n        var startAngle = $math.getAngle({\n          x: middleX,\n          y: middleY\n        }, surface[0]);\n        var count = 100;\n\n        if (surface.length > count) {\n          count = surface.length;\n        }\n\n        fromPoints = this.addPoints(surface, count);\n        count = fromPoints.length; // add Points might increase number a bit\n\n        var angle = 360 / (count - 1);\n\n        for (var a = 0; a < count; a++) {\n          var realAngle = angle * a + startAngle;\n          var pointOnCircle = {\n            x: middleX + realRadius * $math.cos(realAngle),\n            y: middleY + realRadius * $math.sin(realAngle)\n          };\n          toPoints[a] = pointOnCircle;\n        }\n\n        if (hole && hole.length > 0) {\n          for (var i_1 = 0, hlen = hole.length; i_1 < hlen; i_1++) {\n            toPoints.push({\n              x: middleX,\n              y: middleY\n            });\n          }\n        }\n\n        this._morphFromPointsReal[i][0] = fromPoints;\n        this._morphToPointsReal[i][0] = toPoints;\n      }\n    }\n\n    this.morphable.currentPoints = this._morphFromPointsReal;\n    var animation = new Animation(this, {\n      property: \"morphProgress\",\n      from: 0,\n      to: 1\n    }, duration, easing);\n\n    this._disposers.push(animation);\n\n    animation.start();\n    return animation;\n  };\n  /**\r\n   * [addPoints description]\r\n   *\r\n   * @ignore Exclude from doc\r\n   * @todo Description\r\n   * @param points         [description]\r\n   * @param mustHaveCount  [description]\r\n   * @return [description]\r\n   */\n\n\n  Morpher.prototype.addPoints = function (points, mustHaveCount) {\n    var addToSegmentCount = Math.round(mustHaveCount / points.length);\n    var newPoints = [];\n\n    for (var i = 0, len = points.length; i < len; i++) {\n      var point0 = points[i];\n      var point1 = void 0;\n\n      if (i == points.length - 1) {\n        point1 = points[0];\n      } else {\n        point1 = points[i + 1];\n      }\n\n      newPoints.push(point0);\n\n      for (var p = 1; p < addToSegmentCount; p++) {\n        var percent = p / addToSegmentCount;\n        var extraPoint = {\n          x: point0.x + (point1.x - point0.x) * percent,\n          y: point0.y + (point1.y - point0.y) * percent\n        };\n        newPoints.push(extraPoint);\n      } // stop adding in case we already added more than left in original\n\n\n      if (newPoints.length + points.length - i == mustHaveCount) {\n        addToSegmentCount = 0;\n      }\n    }\n\n    if (newPoints.length < mustHaveCount && points.length > 0) {\n      var lastPoint = points[points.length - 1];\n\n      for (var p = newPoints.length; p < mustHaveCount; p++) {\n        // add same as last\n        newPoints.push({\n          x: lastPoint.x,\n          y: lastPoint.y\n        });\n      }\n    }\n\n    return newPoints;\n  };\n  /**\r\n   * Morphs polygon into a rectangular polygon.\r\n   *\r\n   * @param width     Width of the target rectangle (px)\r\n   * @param height    Height of the target rectangle (px)\r\n   * @param duration  Duration (ms)\r\n   * @param easing    Easing function\r\n   * @return Animation\r\n   */\n\n\n  Morpher.prototype.morphToRectangle = function (width, height, duration, easing) {\n    var points = this.morphable.points;\n    this.sortPoints(points);\n    this._morphFromPointsReal = [];\n    this._morphToPointsReal = [];\n\n    if (!$type.hasValue(duration)) {\n      duration = this.morphDuration;\n    }\n\n    if (!$type.hasValue(easing)) {\n      easing = this.morphEasing;\n    } //\t\tlet biggestBBox: IRectangle = this._bboxes[this._biggestIndex];\n    // surface\n\n\n    for (var i = 0, len = points.length; i < len; i++) {\n      var surface = points[i][0];\n      var hole = points[i][1];\n      this._morphFromPointsReal[i] = [];\n      this._morphToPointsReal[i] = [];\n\n      if (surface) {\n        var toPoints = surface;\n        var fromPoints = surface;\n        var bbox = this._bboxes[i]; // we only work with first area. TODO: maybe we should find the biggest one?\n\n        if (this.morphToSingle) {//if (i != this._biggestIndex) {\n          //\tbbox = { x: biggestBBox.x + biggestBBox.width / 2, y: biggestBBox.y + biggestBBox.height / 2, width: 0, height: 0 };\n          //}\n        }\n\n        var x = bbox.x;\n        var y = bbox.y;\n        var realWidth = width;\n        var realHeight = height;\n\n        if (!$type.isNumber(realWidth)) {\n          realWidth = bbox.width;\n        }\n\n        if (!$type.isNumber(realHeight)) {\n          realHeight = bbox.height;\n        }\n\n        toPoints = [{\n          x: x,\n          y: y\n        }, {\n          x: x + realWidth,\n          y: y\n        }, {\n          x: x + realWidth,\n          y: y + realHeight\n        }, {\n          x: x,\n          y: y + realHeight\n        }];\n        toPoints = this.addPoints(toPoints, surface.length); // if polygon has less points then count, add\n\n        if (surface.length < 4) {\n          for (var i_2 = surface.length; i_2 < 4; i_2++) {\n            toPoints.push({\n              x: surface[i_2].x,\n              y: surface[i_2].y\n            });\n          }\n        }\n\n        if (hole && hole.length > 0) {\n          var middleX = bbox.x + bbox.width / 2;\n          var middleY = bbox.y + bbox.height / 2;\n\n          for (var i_3 = 0, hlen = hole.length; i_3 < hlen; i_3++) {\n            toPoints.push({\n              x: middleX,\n              y: middleY\n            });\n          }\n        }\n\n        this._morphFromPointsReal[i][0] = fromPoints;\n        this._morphToPointsReal[i][0] = toPoints;\n      }\n    }\n\n    this.morphable.currentPoints = this._morphFromPointsReal;\n    var animation = new Animation(this, {\n      property: \"morphProgress\",\n      from: 0,\n      to: 1\n    }, duration, easing);\n\n    this._disposers.push(animation);\n\n    animation.start();\n    return animation;\n  };\n\n  Object.defineProperty(Morpher.prototype, \"morphProgress\", {\n    /**\r\n     * Returns the progress of morph transition.\r\n     *\r\n     * @return Progress (0-1)\r\n     */\n    get: function () {\n      return this._morphProgress;\n    },\n\n    /**\r\n     * Progress of the morph transition.\r\n     *\r\n     * Setting this will also trigger actual transformation.\r\n     *\r\n     * @param value  Progress (0-1)\r\n     */\n    set: function (value) {\n      this._morphProgress = value;\n      var currentPoints = [];\n\n      if (value != null) {\n        var fromPoints = this._morphFromPointsReal;\n        var toPoints = this._morphToPointsReal;\n\n        if (fromPoints != null && toPoints != null) {\n          for (var i = 0, len = fromPoints.length; i < len; i++) {\n            var currentArea = [];\n            currentPoints.push(currentArea);\n            var surfaceFrom = fromPoints[i][0];\n            var holeFrom = fromPoints[i][1];\n            var surfaceTo = toPoints[i][0];\n            var holeTo = toPoints[i][1];\n\n            if (surfaceFrom && surfaceFrom.length > 0 && surfaceTo && surfaceTo.length > 0) {\n              var currentSurface = [];\n\n              for (var i_4 = 0, slen = surfaceFrom.length; i_4 < slen; i_4++) {\n                var point0 = surfaceFrom[i_4];\n                var point1 = surfaceTo[i_4];\n                var currentPoint = {\n                  x: point0.x + (point1.x * this.scaleRatio - point0.x) * value,\n                  y: point0.y + (point1.y * this.scaleRatio - point0.y) * value\n                };\n                currentSurface.push(currentPoint);\n              }\n\n              currentArea[0] = currentSurface;\n            }\n\n            if (holeFrom && holeFrom.length > 0 && holeTo && holeTo.length > 0) {\n              var currentHole = [];\n\n              for (var i_5 = 0, hlen = holeFrom.length; i_5 < hlen; i_5++) {\n                var point0 = holeFrom[i_5];\n                var point1 = holeTo[i_5];\n                var currentPoint = {\n                  x: point0.x + (point1.x * this.scaleRatio - point0.x) * value,\n                  y: point0.y + (point1.y * this.scaleRatio - point0.y) * value\n                };\n                currentHole.push(currentPoint);\n              }\n\n              currentArea[1] = currentHole;\n            }\n          }\n        }\n      }\n\n      this.morphable.currentPoints = currentPoints;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\r\n   * Restores the polygon to its original appearance.\r\n   *\r\n   * @param duration  Duration (ms)\r\n   * @param easing    Easing function\r\n   * @return Animation\r\n   */\n\n  Morpher.prototype.morphBack = function (duration, easing) {\n    this._morphToPointsReal = this._morphFromPointsReal;\n    this._morphFromPointsReal = this.morphable.currentPoints;\n\n    if (!$type.hasValue(duration)) {\n      duration = this.morphDuration;\n    }\n\n    if (!$type.hasValue(easing)) {\n      easing = this.morphEasing;\n    }\n\n    var animation = new Animation(this, {\n      property: \"morphProgress\",\n      from: 0,\n      to: 1\n    }, duration, easing);\n\n    this._disposers.push(animation);\n\n    animation.start();\n    return animation;\n  };\n\n  Object.defineProperty(Morpher.prototype, \"animations\", {\n    /**\r\n     * Returns a list of morph animations currently being played.\r\n     *\r\n     * @return List of animations\r\n     */\n    get: function () {\n      if (!this._animations) {\n        this._animations = [];\n\n        this._disposers.push(new AnimationDisposer(this._animations));\n      }\n\n      return this._animations;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  return Morpher;\n}(BaseObject);\n\nexport { Morpher };","map":{"version":3,"names":["__extends","BaseObject","Animation","AnimationDisposer","$math","$ease","$type","Morpher","_super","morphable","_this","call","_bboxes","morphDuration","morphEasing","cubicOut","morphToSingle","scaleRatio","className","applyTheme","prototype","morphToPolygon","toPoints","duration","easing","points","currentPoints","sortPoints","_morphFromPointsReal","_morphToPointsReal","hasValue","normalizePoints","animation","property","from","to","_disposers","push","start","pointsA","pointsB","i","len","length","surfaceA","holeA","bboxA","getValue","getBBox","middleX","x","width","middleY","y","height","addPoints","distance","Infinity","splitAt","a","newDistance","getDistance","partA","slice","partB","concat","sort","b","bbox1","bbox2","bboxes","surface","getCommonRectangle","morphToCircle","radius","commonBBox","hole","fromPoints","bbox","realRadius","isNumber","Math","min","startAngle","getAngle","count","angle","realAngle","pointOnCircle","cos","sin","i_1","hlen","mustHaveCount","addToSegmentCount","round","newPoints","point0","point1","p","percent","extraPoint","lastPoint","morphToRectangle","realWidth","realHeight","i_2","i_3","Object","defineProperty","get","_morphProgress","set","value","currentArea","surfaceFrom","holeFrom","surfaceTo","holeTo","currentSurface","i_4","slen","currentPoint","currentHole","i_5","enumerable","configurable","morphBack","_animations"],"sources":["D:/APPLICATION/UI/UPL/NEW/node_modules/@amcharts/amcharts4/.internal/core/utils/Morpher.js"],"sourcesContent":["/**\r\n * Morpher module contains functionality that allows morphing one polygon to\r\n * another.\r\n */\r\nimport { __extends } from \"tslib\";\r\n/**\r\n * ============================================================================\r\n * IMPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\r\nimport { BaseObject } from \"../Base\";\r\nimport { Animation, AnimationDisposer } from \"../utils/Animation\";\r\nimport * as $math from \"../utils/Math\";\r\nimport * as $ease from \"../utils/Ease\";\r\nimport * as $type from \"../utils/Type\";\r\n/**\r\n * Morpher can be used to morph one polygon to some other polygon.\r\n */\r\nvar Morpher = /** @class */ (function (_super) {\r\n    __extends(Morpher, _super);\r\n    /**\r\n     * Constructor.\r\n     *\r\n     * @param morphable An object to morph\r\n     */\r\n    function Morpher(morphable) {\r\n        var _this = _super.call(this) || this;\r\n        /**\r\n         * A storage for measurements.\r\n         */\r\n        _this._bboxes = [];\r\n        /**\r\n         * Duration of the morphing animation in milliseconds.\r\n         */\r\n        _this.morphDuration = 800;\r\n        /**\r\n         * An easing function to use for morphing animation.\r\n         *\r\n         * @see {@link Ease}\r\n         */\r\n        _this.morphEasing = $ease.cubicOut;\r\n        /**\r\n         * If set to `true`, all separate parts of the multi-part polygon will\r\n         * morph into a single circle or polygon when using built-in methods\r\n         * `morphToCircle()` or `morphToPolygon()`.\r\n         *\r\n         * Otherwise each separate part of polygon will morph to individual target\r\n         * circle or polgyon.\r\n         */\r\n        _this.morphToSingle = true;\r\n        /**\r\n         * A ratio to scale morphed object in relation to the source object.\r\n         */\r\n        _this.scaleRatio = 1;\r\n        _this.className = \"Morpher\";\r\n        _this.morphable = morphable;\r\n        _this.applyTheme();\r\n        return _this;\r\n    }\r\n    /**\r\n     * Morphs a polygon to another polygon.\r\n     *\r\n     * @param toPoints  Corner points of the target shape\r\n     * @param duration  Duration in milliseconds\r\n     * @param easing    Easing function\r\n     * @return Animation\r\n     */\r\n    Morpher.prototype.morphToPolygon = function (toPoints, duration, easing) {\r\n        var points = this.morphable.currentPoints;\r\n        if (points && toPoints) {\r\n            this.sortPoints(points);\r\n            this.sortPoints(toPoints);\r\n            this._morphFromPointsReal = [];\r\n            this._morphToPointsReal = [];\r\n            if (!$type.hasValue(duration)) {\r\n                duration = this.morphDuration;\r\n            }\r\n            if (!$type.hasValue(easing)) {\r\n                easing = this.morphEasing;\r\n            }\r\n            this._morphFromPointsReal = this.normalizePoints(toPoints, points);\r\n            this._morphToPointsReal = this.normalizePoints(points, toPoints);\r\n            this.morphable.currentPoints = this._morphFromPointsReal;\r\n            var animation = new Animation(this, { property: \"morphProgress\", from: 0, to: 1 }, duration, easing);\r\n            this._disposers.push(animation);\r\n            animation.start();\r\n            return animation;\r\n        }\r\n    };\r\n    /**\r\n     * [normalizePoints description]\r\n     *\r\n     * @ignore Exclude from docs\r\n     * @todo Description\r\n     * @param pointsA  Point A\r\n     * @param pointsB  Point B\r\n     * @return Normalized points\r\n     */\r\n    Morpher.prototype.normalizePoints = function (pointsA, pointsB) {\r\n        for (var i = 0, len = pointsA.length; i < len; i++) {\r\n            var surfaceA = pointsA[i][0];\r\n            var holeA = pointsA[i][1];\r\n            var bboxA = $type.getValue($math.getBBox(surfaceA));\r\n            var middleX = bboxA.x + bboxA.width;\r\n            var middleY = bboxA.y + bboxA.height;\r\n            // check if we have the same in PointsB\r\n            if (!pointsB[i]) {\r\n                pointsB[i] = [];\r\n            }\r\n            // check if we have surface in pointsB\r\n            if (surfaceA && !pointsB[i][0]) {\r\n                pointsB[i][0] = [{ x: middleX, y: middleY }, { x: middleX, y: middleY }];\r\n            }\r\n            if (pointsB[i][0]) {\r\n                pointsB[i][0] = this.addPoints(pointsB[i][0], surfaceA.length);\r\n                var distance = Infinity;\r\n                var splitAt = 0;\r\n                for (var a = 0; a < pointsB[i][0].length; a++) {\r\n                    var newDistance = $math.getDistance(pointsB[i][0][a], surfaceA[0]);\r\n                    if (newDistance < distance) {\r\n                        splitAt = a;\r\n                        distance = newDistance;\r\n                    }\r\n                }\r\n                var partA = pointsB[i][0].slice(0, splitAt);\r\n                var partB = pointsB[i][0].slice(splitAt);\r\n                pointsB[i][0] = partB.concat(partA);\r\n            }\r\n            if (holeA) {\r\n                if (!pointsB[i][1]) {\r\n                    pointsB[i][1] = [{ x: middleX, y: middleY }, { x: middleX, y: middleY }];\r\n                }\r\n                pointsB[i][1] = this.addPoints(pointsB[i][1], holeA.length);\r\n            }\r\n        }\r\n        return pointsB;\r\n    };\r\n    /**\r\n     * [sortPoints description]\r\n     *\r\n     * @ignore Exclude from doc\r\n     * @todo Description\r\n     * @param points  [description]\r\n     * @return                        common bbox of points\r\n     */\r\n    Morpher.prototype.sortPoints = function (points) {\r\n        points.sort(function (a, b) {\r\n            var bbox1 = $type.getValue($math.getBBox(a[0]));\r\n            var bbox2 = $type.getValue($math.getBBox(b[0]));\r\n            if (bbox1.width * bbox1.height > bbox2.width * bbox2.height) {\r\n                return -1;\r\n            }\r\n            else {\r\n                return 1;\r\n            }\r\n        });\r\n        var bboxes = [];\r\n        for (var i = 0, len = points.length; i < len; i++) {\r\n            var surface = points[i][0];\r\n            if (surface) {\r\n                bboxes.push($type.getValue($math.getBBox(surface)));\r\n            }\r\n        }\r\n        return $math.getCommonRectangle(bboxes);\r\n    };\r\n    /**\r\n     * Morphs polygon to a circle (it is actually a polygon which makes a circle).\r\n     *\r\n     * @param radius    Target circle radius (px)\r\n     * @param duration  Duration (ms)\r\n     * @param easing    Easing function\r\n     * @return Animation\r\n     */\r\n    Morpher.prototype.morphToCircle = function (radius, duration, easing) {\r\n        var points = this.morphable.points;\r\n        var commonBBox = this.sortPoints(points);\r\n        this._morphFromPointsReal = [];\r\n        this._morphToPointsReal = [];\r\n        if (!$type.hasValue(duration)) {\r\n            duration = this.morphDuration;\r\n        }\r\n        if (!$type.hasValue(easing)) {\r\n            easing = this.morphEasing;\r\n        }\r\n        // surface\r\n        for (var i = 0, len = points.length; i < len; i++) {\r\n            var surface = points[i][0];\r\n            var hole = points[i][1];\r\n            this._morphFromPointsReal[i] = [];\r\n            this._morphToPointsReal[i] = [];\r\n            if (surface) {\r\n                var toPoints = surface;\r\n                var fromPoints = surface;\r\n                var bbox = $type.getValue($math.getBBox(fromPoints)); // this._bboxes[i];\r\n                if (this.morphToSingle) {\r\n                    bbox = $type.getValue(commonBBox);\r\n                }\r\n                var middleX = bbox.x + bbox.width / 2;\r\n                var middleY = bbox.y + bbox.height / 2;\r\n                var realRadius = radius;\r\n                if (!$type.isNumber(realRadius)) {\r\n                    realRadius = Math.min(bbox.width / 2, bbox.height / 2);\r\n                }\r\n                toPoints = [];\r\n                // find angle for the first point\r\n                var startAngle = $math.getAngle({ x: middleX, y: middleY }, surface[0]);\r\n                var count = 100;\r\n                if (surface.length > count) {\r\n                    count = surface.length;\r\n                }\r\n                fromPoints = this.addPoints(surface, count);\r\n                count = fromPoints.length; // add Points might increase number a bit\r\n                var angle = 360 / (count - 1);\r\n                for (var a = 0; a < count; a++) {\r\n                    var realAngle = angle * a + startAngle;\r\n                    var pointOnCircle = { x: middleX + realRadius * $math.cos(realAngle), y: middleY + realRadius * $math.sin(realAngle) };\r\n                    toPoints[a] = pointOnCircle;\r\n                }\r\n                if (hole && hole.length > 0) {\r\n                    for (var i_1 = 0, hlen = hole.length; i_1 < hlen; i_1++) {\r\n                        toPoints.push({ x: middleX, y: middleY });\r\n                    }\r\n                }\r\n                this._morphFromPointsReal[i][0] = fromPoints;\r\n                this._morphToPointsReal[i][0] = toPoints;\r\n            }\r\n        }\r\n        this.morphable.currentPoints = this._morphFromPointsReal;\r\n        var animation = new Animation(this, { property: \"morphProgress\", from: 0, to: 1 }, duration, easing);\r\n        this._disposers.push(animation);\r\n        animation.start();\r\n        return animation;\r\n    };\r\n    /**\r\n     * [addPoints description]\r\n     *\r\n     * @ignore Exclude from doc\r\n     * @todo Description\r\n     * @param points         [description]\r\n     * @param mustHaveCount  [description]\r\n     * @return [description]\r\n     */\r\n    Morpher.prototype.addPoints = function (points, mustHaveCount) {\r\n        var addToSegmentCount = Math.round(mustHaveCount / points.length);\r\n        var newPoints = [];\r\n        for (var i = 0, len = points.length; i < len; i++) {\r\n            var point0 = points[i];\r\n            var point1 = void 0;\r\n            if (i == points.length - 1) {\r\n                point1 = points[0];\r\n            }\r\n            else {\r\n                point1 = points[i + 1];\r\n            }\r\n            newPoints.push(point0);\r\n            for (var p = 1; p < addToSegmentCount; p++) {\r\n                var percent = p / addToSegmentCount;\r\n                var extraPoint = { x: point0.x + (point1.x - point0.x) * percent, y: point0.y + (point1.y - point0.y) * percent };\r\n                newPoints.push(extraPoint);\r\n            }\r\n            // stop adding in case we already added more than left in original\r\n            if (newPoints.length + points.length - i == mustHaveCount) {\r\n                addToSegmentCount = 0;\r\n            }\r\n        }\r\n        if (newPoints.length < mustHaveCount && points.length > 0) {\r\n            var lastPoint = points[points.length - 1];\r\n            for (var p = newPoints.length; p < mustHaveCount; p++) {\r\n                // add same as last\r\n                newPoints.push({ x: lastPoint.x, y: lastPoint.y });\r\n            }\r\n        }\r\n        return newPoints;\r\n    };\r\n    /**\r\n     * Morphs polygon into a rectangular polygon.\r\n     *\r\n     * @param width     Width of the target rectangle (px)\r\n     * @param height    Height of the target rectangle (px)\r\n     * @param duration  Duration (ms)\r\n     * @param easing    Easing function\r\n     * @return Animation\r\n     */\r\n    Morpher.prototype.morphToRectangle = function (width, height, duration, easing) {\r\n        var points = this.morphable.points;\r\n        this.sortPoints(points);\r\n        this._morphFromPointsReal = [];\r\n        this._morphToPointsReal = [];\r\n        if (!$type.hasValue(duration)) {\r\n            duration = this.morphDuration;\r\n        }\r\n        if (!$type.hasValue(easing)) {\r\n            easing = this.morphEasing;\r\n        }\r\n        //\t\tlet biggestBBox: IRectangle = this._bboxes[this._biggestIndex];\r\n        // surface\r\n        for (var i = 0, len = points.length; i < len; i++) {\r\n            var surface = points[i][0];\r\n            var hole = points[i][1];\r\n            this._morphFromPointsReal[i] = [];\r\n            this._morphToPointsReal[i] = [];\r\n            if (surface) {\r\n                var toPoints = surface;\r\n                var fromPoints = surface;\r\n                var bbox = this._bboxes[i];\r\n                // we only work with first area. TODO: maybe we should find the biggest one?\r\n                if (this.morphToSingle) {\r\n                    //if (i != this._biggestIndex) {\r\n                    //\tbbox = { x: biggestBBox.x + biggestBBox.width / 2, y: biggestBBox.y + biggestBBox.height / 2, width: 0, height: 0 };\r\n                    //}\r\n                }\r\n                var x = bbox.x;\r\n                var y = bbox.y;\r\n                var realWidth = width;\r\n                var realHeight = height;\r\n                if (!$type.isNumber(realWidth)) {\r\n                    realWidth = bbox.width;\r\n                }\r\n                if (!$type.isNumber(realHeight)) {\r\n                    realHeight = bbox.height;\r\n                }\r\n                toPoints = [{ x: x, y: y }, { x: x + realWidth, y: y }, { x: x + realWidth, y: y + realHeight }, { x: x, y: y + realHeight }];\r\n                toPoints = this.addPoints(toPoints, surface.length);\r\n                // if polygon has less points then count, add\r\n                if (surface.length < 4) {\r\n                    for (var i_2 = surface.length; i_2 < 4; i_2++) {\r\n                        toPoints.push({ x: surface[i_2].x, y: surface[i_2].y });\r\n                    }\r\n                }\r\n                if (hole && hole.length > 0) {\r\n                    var middleX = bbox.x + bbox.width / 2;\r\n                    var middleY = bbox.y + bbox.height / 2;\r\n                    for (var i_3 = 0, hlen = hole.length; i_3 < hlen; i_3++) {\r\n                        toPoints.push({ x: middleX, y: middleY });\r\n                    }\r\n                }\r\n                this._morphFromPointsReal[i][0] = fromPoints;\r\n                this._morphToPointsReal[i][0] = toPoints;\r\n            }\r\n        }\r\n        this.morphable.currentPoints = this._morphFromPointsReal;\r\n        var animation = new Animation(this, { property: \"morphProgress\", from: 0, to: 1 }, duration, easing);\r\n        this._disposers.push(animation);\r\n        animation.start();\r\n        return animation;\r\n    };\r\n    Object.defineProperty(Morpher.prototype, \"morphProgress\", {\r\n        /**\r\n         * Returns the progress of morph transition.\r\n         *\r\n         * @return Progress (0-1)\r\n         */\r\n        get: function () {\r\n            return this._morphProgress;\r\n        },\r\n        /**\r\n         * Progress of the morph transition.\r\n         *\r\n         * Setting this will also trigger actual transformation.\r\n         *\r\n         * @param value  Progress (0-1)\r\n         */\r\n        set: function (value) {\r\n            this._morphProgress = value;\r\n            var currentPoints = [];\r\n            if (value != null) {\r\n                var fromPoints = this._morphFromPointsReal;\r\n                var toPoints = this._morphToPointsReal;\r\n                if (fromPoints != null && toPoints != null) {\r\n                    for (var i = 0, len = fromPoints.length; i < len; i++) {\r\n                        var currentArea = [];\r\n                        currentPoints.push(currentArea);\r\n                        var surfaceFrom = fromPoints[i][0];\r\n                        var holeFrom = fromPoints[i][1];\r\n                        var surfaceTo = toPoints[i][0];\r\n                        var holeTo = toPoints[i][1];\r\n                        if (surfaceFrom && surfaceFrom.length > 0 && surfaceTo && surfaceTo.length > 0) {\r\n                            var currentSurface = [];\r\n                            for (var i_4 = 0, slen = surfaceFrom.length; i_4 < slen; i_4++) {\r\n                                var point0 = surfaceFrom[i_4];\r\n                                var point1 = surfaceTo[i_4];\r\n                                var currentPoint = { x: point0.x + (point1.x * this.scaleRatio - point0.x) * value, y: point0.y + (point1.y * this.scaleRatio - point0.y) * value };\r\n                                currentSurface.push(currentPoint);\r\n                            }\r\n                            currentArea[0] = currentSurface;\r\n                        }\r\n                        if (holeFrom && holeFrom.length > 0 && holeTo && holeTo.length > 0) {\r\n                            var currentHole = [];\r\n                            for (var i_5 = 0, hlen = holeFrom.length; i_5 < hlen; i_5++) {\r\n                                var point0 = holeFrom[i_5];\r\n                                var point1 = holeTo[i_5];\r\n                                var currentPoint = { x: point0.x + (point1.x * this.scaleRatio - point0.x) * value, y: point0.y + (point1.y * this.scaleRatio - point0.y) * value };\r\n                                currentHole.push(currentPoint);\r\n                            }\r\n                            currentArea[1] = currentHole;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            this.morphable.currentPoints = currentPoints;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    /**\r\n     * Restores the polygon to its original appearance.\r\n     *\r\n     * @param duration  Duration (ms)\r\n     * @param easing    Easing function\r\n     * @return Animation\r\n     */\r\n    Morpher.prototype.morphBack = function (duration, easing) {\r\n        this._morphToPointsReal = this._morphFromPointsReal;\r\n        this._morphFromPointsReal = this.morphable.currentPoints;\r\n        if (!$type.hasValue(duration)) {\r\n            duration = this.morphDuration;\r\n        }\r\n        if (!$type.hasValue(easing)) {\r\n            easing = this.morphEasing;\r\n        }\r\n        var animation = new Animation(this, { property: \"morphProgress\", from: 0, to: 1 }, duration, easing);\r\n        this._disposers.push(animation);\r\n        animation.start();\r\n        return animation;\r\n    };\r\n    Object.defineProperty(Morpher.prototype, \"animations\", {\r\n        /**\r\n         * Returns a list of morph animations currently being played.\r\n         *\r\n         * @return List of animations\r\n         */\r\n        get: function () {\r\n            if (!this._animations) {\r\n                this._animations = [];\r\n                this._disposers.push(new AnimationDisposer(this._animations));\r\n            }\r\n            return this._animations;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    return Morpher;\r\n}(BaseObject));\r\nexport { Morpher };\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}