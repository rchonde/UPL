{"ast":null,"code":"/**\r\n * Interaction manages all aspects of user interaction - mouse move,\r\n * click, hover, drag events, touch gestures.\r\n *\r\n * [[InteractionObject]] elements that want to use certain events, must attach event\r\n * listeners to Interaction instance.\r\n *\r\n * Interaction itself will not modify [[InteractionObject]] elements, it will be up to\r\n * those elements to handle interaction information received via event triggers.\r\n */\nimport { __extends } from \"tslib\";\n/**\r\n * ============================================================================\r\n * IMPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\n\nimport { BaseObjectEvents } from \"../Base\";\nimport { List } from \"../utils/List\";\nimport { Animation } from \"../utils/Animation\";\nimport { MultiDisposer } from \"../utils/Disposer\";\nimport { InteractionObject } from \"./InteractionObject\";\nimport { InteractionKeyboardObject } from \"./InteractionKeyboardObject\";\nimport { Dictionary } from \"../utils/Dictionary\";\nimport { Inertia } from \"./Inertia\";\nimport { addEventListener } from \"../utils/DOM\";\nimport { keyboard } from \"../utils/Keyboard\";\nimport { system } from \"./../System\";\nimport { options } from \"./../Options\";\nimport * as $ease from \"../utils/Ease\";\nimport * as $math from \"../utils/Math\";\nimport * as $array from \"../utils/Array\";\nimport * as $dom from \"../utils/DOM\";\nimport * as $iter from \"../utils/Iterator\";\nimport * as $type from \"../utils/Type\";\nimport * as $time from \"../utils/Time\";\n/**\r\n * ============================================================================\r\n * MAIN CLASS\r\n * ============================================================================\r\n * @hidden\r\n */\n\n/**\r\n* Interaction manages all aspects of user interaction - mouse move,\r\n* click, hover, drag events, touch gestures.\r\n*\r\n* [[InteractionObject]] elements that want to use certain events, must attach event\r\n* listeners to Interaction instance.\r\n*\r\n* Interaction itself will not modify [[InteractionObject]] elements, it will be up to\r\n* those elements to handle interaction information received via event triggers.\r\n*\r\n* @see {@link IInteractionEvents} for a list of available events\r\n*/\n\nvar Interaction =\n/** @class */\nfunction (_super) {\n  __extends(Interaction, _super);\n  /**\r\n   * Constructor. Sets up universal document-wide move events to handle stuff\r\n   * outside particular chart container.\r\n   */\n\n\n  function Interaction() {\n    var _this = // Call super\n    _super.call(this) || this;\n    /**\r\n     * An indicator of global events were already initialized.\r\n     */\n\n\n    _this._globalEventsAdded = false;\n    /**\r\n     * Holds which mouse event listeners to use.\r\n     */\n\n    _this._pointerEvents = {\n      \"pointerdown\": \"mousedown\",\n      \"pointerup\": \"mouseup\",\n      \"pointermove\": \"mousemove\",\n      \"pointercancel\": \"mouseup\",\n      \"pointerover\": \"mouseover\",\n      \"pointerout\": \"mouseout\",\n      \"wheel\": \"wheel\"\n    };\n    /**\r\n     * Indicates if Interaction should use only \"pointer\" type events, like\r\n     * \"pointermove\", available in all modern browsers, ignoring \"legacy\"\r\n     * events, like \"touchmove\".\r\n     */\n\n    _this._usePointerEventsOnly = false;\n    /**\r\n     * Use only touch events (for touch only devices such as tablets and phones)\r\n     */\n\n    _this._useTouchEventsOnly = false;\n    /**\r\n     * Add special hover events. Normally, touch device tap will also simulate\r\n     * hover event. On some devices (ahem iOS) we want to prevent that so that\r\n     * over/out events are not duplicated.\r\n     */\n\n    _this._addHoverEvents = true;\n    /**\r\n     * Indicates if passive mode options is supported by this browser.\r\n     */\n\n    _this._passiveSupported = false;\n    /**\r\n     * Holds list of delayed events\r\n     */\n\n    _this._delayedEvents = {\n      out: []\n    };\n    /**\r\n     * List of objects that current have a pointer hovered over them.\r\n     */\n\n    _this.overObjects = new List();\n    /**\r\n     * List of objects that currently has a pressed pointer.\r\n     */\n\n    _this.downObjects = new List();\n    /**\r\n     * List of objects that need mouse position to be reported to them.\r\n     */\n\n    _this.trackedObjects = new List();\n    /**\r\n     * List of objects that are currently being dragged.\r\n     */\n\n    _this.transformedObjects = new List();\n    /**\r\n     * Holds all known pointers.\r\n     */\n\n    _this.pointers = new Dictionary();\n    /**\r\n     * Inertia options that need to be applied to after element drag, if it's\r\n     * `inert = true`.\r\n     *\r\n     * This is just a default, which can and probably will be overridden by\r\n     * actual elements.\r\n     */\n\n    _this.inertiaOptions = new Dictionary();\n    /**\r\n     * Default options for click events. These can be overridden in\r\n     * [[InteractionObject]].\r\n     */\n\n    _this.hitOptions = {\n      \"doubleHitTime\": 300,\n      //\"delayFirstHit\": false,\n      \"hitTolerance\": 10,\n      \"noFocus\": true\n    };\n    /**\r\n     * Default options for hover events. These can be overridden in\r\n     * [[InteractionObject]].\r\n     */\n\n    _this.hoverOptions = {\n      \"touchOutBehavior\": \"leave\",\n      \"touchOutDelay\": 1000\n    };\n    /**\r\n     * Default options for detecting a swipe gesture. These can be overridden in\r\n     * [[InteractionObject]].\r\n     */\n\n    _this.swipeOptions = {\n      \"time\": 500,\n      \"verticalThreshold\": 75,\n      \"horizontalThreshold\": 30\n    };\n    /**\r\n     * Default options for keyboard operations. These can be overridden in\r\n     * [[InteractionObject]].\r\n     */\n\n    _this.keyboardOptions = {\n      \"speed\": 0.1,\n      \"accelleration\": 1.2,\n      \"accellerationDelay\": 2000\n    };\n    /**\r\n     * Default options for keyboard operations. These can be overridden in\r\n     * [[InteractionObject]].\r\n     *\r\n     * @since 4.5.14\r\n     */\n\n    _this.mouseOptions = {\n      \"sensitivity\": 1\n    }; // Set class name\n\n    _this.className = \"Interaction\"; // Create InteractionObject for <body>\n\n    _this.body = _this.getInteraction(document.body);\n\n    _this._disposers.push(_this.body); // Detect browser capabilities and determine what event listeners to use\n\n\n    if (window.hasOwnProperty(\"PointerEvent\")) {\n      // IE10+/Edge without touch controls enabled\n      _this._pointerEvents.pointerdown = \"pointerdown\";\n      _this._pointerEvents.pointerup = \"pointerup\";\n      _this._pointerEvents.pointermove = \"pointermove\";\n      _this._pointerEvents.pointercancel = \"pointercancel\";\n      _this._pointerEvents.pointerover = \"pointerover\";\n      _this._pointerEvents.pointerout = \"pointerout\"; //this._usePointerEventsOnly = true;\n    } else if (window.hasOwnProperty(\"MSPointerEvent\")) {\n      // IE9\n      _this._pointerEvents.pointerdown = \"MSPointerDown\";\n      _this._pointerEvents.pointerup = \"MSPointerUp\";\n      _this._pointerEvents.pointermove = \"MSPointerMove\";\n      _this._pointerEvents.pointercancel = \"MSPointerUp\";\n      _this._pointerEvents.pointerover = \"MSPointerOver\";\n      _this._pointerEvents.pointerout = \"MSPointerOut\"; //this._usePointerEventsOnly = true;\n    } else if (typeof matchMedia !== \"undefined\" && matchMedia('(pointer:fine)').matches) {\n      // This is only for Safari as it does not support PointerEvent\n      // Do nothing and let it use regular `mouse*` events\n      // Hi Apple ;)\n      // Additionally disable hover events for iOS devices\n      if ('ontouchstart' in window) {\n        _this._addHoverEvents = false;\n        _this._useTouchEventsOnly = true;\n      }\n    } else if (window.navigator.userAgent.match(/MSIE /)) {\n      // Oh looky, an MSIE that does not support PointerEvent. Hi granpa IE9!\n      _this._usePointerEventsOnly = true;\n    } else if (_this.fullFF()) {\n      // Old FF, let's use regular events.\n      // (Newer FFs would be detected by the PointerEvent availability check)\n      _this._usePointerEventsOnly = true;\n    } else {\n      // Uses defaults for normal browsers\n      // We also assume that this must be a touch device that does not have\n      // any pointer events\n      _this._useTouchEventsOnly = true;\n    } // Detect if device has a mouse\n    // This is turning out to be not reliable\n    // @todo remove\n\n    /*if (!window.navigator.msPointerEnabled && (typeof matchMedia !== \"undefined\") && !matchMedia('(pointer:fine)').matches && !this.fullFF()) {\r\n        this._useTouchEventsOnly = true;\r\n    }*/\n    // Detect proper mouse wheel events\n\n\n    if (\"onwheel\" in document.createElement(\"div\")) {\n      // Modern browsers\n      _this._pointerEvents.wheel = \"wheel\";\n    } else if ($type.hasValue(document.onmousewheel)) {\n      // Webkit and IE support at least \"mousewheel\"\n      _this._pointerEvents.wheel = \"mousewheel\";\n    } // Set up default inertia options\n\n\n    _this.inertiaOptions.setKey(\"move\", {\n      \"time\": 100,\n      \"duration\": 500,\n      \"factor\": 1,\n      \"easing\": $ease.polyOut3\n    });\n\n    _this.inertiaOptions.setKey(\"resize\", {\n      \"time\": 100,\n      \"duration\": 500,\n      \"factor\": 1,\n      \"easing\": $ease.polyOut3\n    }); // Set the passive mode support\n\n\n    _this._passiveSupported = Interaction.passiveSupported; // Apply theme\n\n    _this.applyTheme();\n\n    return _this;\n  }\n  /**\r\n   * This is a nasty detection for Firefox. The reason why we have is that\r\n   * Firefox ESR version does not support matchMedia correctly.\r\n   *\r\n   * On iOS, Firefox uses different userAgent, so we don't have to detect iOS.\r\n   *\r\n   * @return Full Firefox?\r\n   */\n\n\n  Interaction.prototype.fullFF = function () {\n    return window.navigator.userAgent.match(/Firefox/) && !window.navigator.userAgent.match(/Android/);\n  };\n\n  Interaction.prototype.debug = function () {};\n  /**\r\n   * ==========================================================================\r\n   * Processing\r\n   * ==========================================================================\r\n   * @hidden\r\n   */\n\n  /**\r\n   * Sets up global events.\r\n   *\r\n   * We need this so that we can track drag movement beyond chart's container.\r\n   *\r\n   * @ignore Exclude from docs\r\n   */\n\n\n  Interaction.prototype.addGlobalEvents = function () {\n    var _this = this;\n\n    if (!this._globalEventsAdded) {\n      if (!this._useTouchEventsOnly) {\n        this._disposers.push(addEventListener(document, this._pointerEvents.pointerdown, function (ev) {\n          _this.handleGlobalPointerDown(ev);\n        }));\n\n        this._disposers.push(addEventListener(document, this._pointerEvents.pointermove, function (ev) {\n          _this.handleGlobalPointerMove(ev);\n        }));\n\n        this._disposers.push(addEventListener(document, this._pointerEvents.pointerup, function (ev) {\n          _this.handleGlobalPointerUp(ev);\n        }));\n\n        this._disposers.push(addEventListener(document, this._pointerEvents.pointercancel, function (ev) {\n          _this.handleGlobalPointerUp(ev, true);\n        }));\n\n        this._disposers.push(addEventListener(document, \"mouseenter\", function (ev) {\n          if (!$type.hasValue(ev.relatedTarget) && (ev.buttons == 0 || ev.which == 0)) {\n            _this.handleDocumentLeave(ev);\n          }\n        }));\n      } // No need to duplicate events for hubrid systems that support both\n      // pointer events and touch events. Touch events are need only for\n      // some touch-only systems, like Mobile Safari.\n\n\n      if (!this._usePointerEventsOnly) {\n        this._disposers.push(addEventListener(document, \"touchstart\", function (ev) {\n          _this.handleGlobalTouchStart(ev);\n        }));\n\n        this._disposers.push(addEventListener(document, \"touchmove\", function (ev) {\n          _this.handleGlobalTouchMove(ev);\n        }));\n\n        this._disposers.push(addEventListener(document, \"touchend\", function (ev) {\n          _this.handleGlobalTouchEnd(ev);\n        }));\n      }\n\n      this._disposers.push(addEventListener(document, \"keydown\", function (ev) {\n        _this.handleGlobalKeyDown(ev);\n      }));\n\n      this._disposers.push(addEventListener(document, \"keyup\", function (ev) {\n        _this.handleGlobalKeyUp(ev);\n      }));\n\n      this._globalEventsAdded = true;\n    }\n  };\n  /**\r\n   * Sets if [[InteractionObject]] is clickable.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param io [[InteractionObject]] instance\r\n   */\n\n\n  Interaction.prototype.processClickable = function (io) {\n    // Add or remove touch events\n    this.processTouchable(io);\n  };\n  /**\r\n   * Sets if [[InteractionObject]] will display context menu when right-clicked.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param io [[InteractionObject]] instance\r\n   */\n\n\n  Interaction.prototype.processContextMenu = function (io) {\n    if (io.contextMenuDisabled) {\n      if (!io.eventDisposers.hasKey(\"contextMenuDisabled\")) {\n        io.eventDisposers.setKey(\"contextMenuDisabled\", addEventListener(io.element, \"contextmenu\", function (e) {\n          e.preventDefault();\n        }));\n      }\n    } else {\n      if (io.eventDisposers.hasKey(\"contextMenuDisabled\")) {\n        io.eventDisposers.getKey(\"contextMenuDisabled\").dispose();\n      }\n    }\n  };\n  /**\r\n   * Sets if [[InteractionObject]] is hoverable.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param io [[InteractionObject]] instance\r\n   */\n\n\n  Interaction.prototype.processHoverable = function (io) {\n    var _this = this;\n\n    if (io.hoverable || io.trackable) {\n      // Add global events\n      this.addGlobalEvents(); // Add hover styles\n\n      this.applyCursorOverStyle(io); // Add local events\n\n      if (!io.eventDisposers.hasKey(\"hoverable\") && this._addHoverEvents) {\n        io.eventDisposers.setKey(\"hoverable\", new MultiDisposer([addEventListener(io.element, this._pointerEvents.pointerout, function (e) {\n          return _this.handlePointerOut(io, e);\n        }), addEventListener(io.element, this._pointerEvents.pointerover, function (e) {\n          return _this.handlePointerOver(io, e);\n        })]));\n      }\n\n      if (io.trackable) {//sprite.addEventListener(\"touchmove\", this.handleTouchMove, false, this);\n      }\n    } else {\n      var disposer = io.eventDisposers.getKey(\"hoverable\");\n\n      if (disposer != null) {\n        disposer.dispose();\n        io.eventDisposers.removeKey(\"hoverable\");\n      }\n    } // Add or remove touch events\n\n\n    this.processTouchable(io);\n  };\n  /**\r\n   * Sets up [[InteractionObject]] as movable. Movable can be any\r\n   * transformation, e.g. drag, swipe, resize, track.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param io  Element\r\n   */\n\n\n  Interaction.prototype.processMovable = function (io) {\n    // Add unified events\n    if (io.draggable || io.swipeable || io.trackable || io.resizable) {\n      // Prep the element\n      if (!this.isGlobalElement(io) && !io.isTouchProtected) {\n        this.prepElement(io);\n      } // Add hover styles\n\n\n      this.applyCursorOverStyle(io);\n    } // Add or remove touch events\n\n\n    this.processTouchable(io);\n  };\n  /**\r\n   * Checks if [[InteractionObject]] is trackable and sets relative events.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param io  Element\r\n   */\n\n\n  Interaction.prototype.processTrackable = function (io) {\n    this.processHoverable(io);\n    this.processMovable(io);\n\n    if (io.trackable) {\n      this.trackedObjects.moveValue(io);\n    } else {\n      this.trackedObjects.removeValue(io);\n    }\n  };\n  /**\r\n   * Checks if [[InteractionObject]] is draggable.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param io  Element\r\n   */\n\n\n  Interaction.prototype.processDraggable = function (io) {\n    this.processMovable(io);\n  };\n  /**\r\n   * Checks if [[InteractionObject]] is swipeable and sets relative events.\r\n   *\r\n   * A swipe event is triggered when a horizontal drag of 75px or more (and\r\n   * less than 30px vertically) occurs within 700 milliseconds. This can be\r\n   * overridden in sprites [[swipeOptions]].\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param io  Element\r\n   */\n\n\n  Interaction.prototype.processSwipeable = function (io) {\n    this.processMovable(io);\n  };\n  /**\r\n   * Checks if [[InteractionObject]] is resizable and attaches required events\r\n   * to it.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param io  Element\r\n   */\n\n\n  Interaction.prototype.processResizable = function (io) {\n    this.processMovable(io);\n  };\n  /**\r\n   * Checks if [[InteractionObject]] is supposed to capture mouse wheel events\r\n   * and prepares it to catch those events.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param io  Element\r\n   */\n\n\n  Interaction.prototype.processWheelable = function (io) {\n    var _this = this;\n\n    if (io.wheelable) {\n      //io.hoverable = true;\n      if (!io.eventDisposers.hasKey(\"wheelable\")) {\n        io.eventDisposers.setKey(\"wheelable\", new MultiDisposer([addEventListener(io.element, this._pointerEvents.wheel, function (e) {\n          return _this.handleMouseWheel(io, e);\n        }, this._passiveSupported ? {\n          passive: false\n        } : false), io.events.on(\"out\", function (e) {\n          if (io.wheelable) {\n            _this.unlockWheel();\n          }\n        }), io.events.on(\"over\", function (e) {\n          //console.log(\"whelab over\")\n          if (io.wheelable) {\n            _this.lockWheel();\n          }\n        })]));\n      }\n    } else {\n      var disposer = io.eventDisposers.getKey(\"wheelable\");\n\n      if (disposer != null) {\n        disposer.dispose();\n        io.eventDisposers.removeKey(\"wheelable\");\n      }\n    }\n  };\n  /**\r\n   * Checks if [[InteractionObject]] is focusable. A focusable element is an\r\n   * element that will be highlighted when users presses TAB key. If the\r\n   * element is focusable, this function will attach relative focus/blur\r\n   * events to it.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param io  Element\r\n   */\n\n\n  Interaction.prototype.processFocusable = function (io) {\n    var _this = this;\n\n    if (io.focusable === true && io.tabindex > -1 && !this._useTouchEventsOnly) {\n      if (!io.eventDisposers.hasKey(\"focusable\")) {\n        io.eventDisposers.setKey(\"focusable\", new MultiDisposer([addEventListener(io.element, \"focus\", function (e) {\n          return _this.handleFocus(io, e);\n        }), addEventListener(io.element, \"blur\", function (e) {\n          return _this.handleBlur(io, e);\n        }), addEventListener(io.element, this._pointerEvents.pointerdown, function (e) {\n          return _this.handleFocusBlur(io, e);\n        }), addEventListener(io.element, \"touchstart\", function (e) {\n          return _this.handleFocusBlur(io, e);\n        }, this._passiveSupported ? {\n          passive: false\n        } : false)]));\n      }\n    } else {\n      var disposer = io.eventDisposers.getKey(\"focusable\");\n\n      if (disposer != null) {\n        disposer.dispose();\n        io.eventDisposers.removeKey(\"focusable\");\n      }\n    }\n  };\n  /**\r\n   * Checks if [[InteractionObject]] is \"touchable\". It means any interaction\r\n   * whatsoever: mouse click, touch screen tap, swipe, drag, resize, etc.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param io  Element\r\n   */\n\n\n  Interaction.prototype.processTouchable = function (io) {\n    var _this = this; // Add unified events\n\n\n    if (io.clickable || io.hoverable || io.trackable || io.draggable || io.swipeable || io.resizable) {\n      // Add global events\n      this.addGlobalEvents(); // Add local events\n\n      if (!io.eventDisposers.hasKey(\"touchable\")) {\n        if (!this._useTouchEventsOnly && !this._usePointerEventsOnly) {\n          io.eventDisposers.setKey(\"touchable\", new MultiDisposer([addEventListener(io.element, this._pointerEvents.pointerdown, function (e) {\n            return _this.handlePointerDown(io, e);\n          }), addEventListener(io.element, \"touchstart\", function (e) {\n            return _this.handleTouchDown(io, e);\n          }, this._passiveSupported ? {\n            passive: false\n          } : false)]));\n        } else if (!this._useTouchEventsOnly) {\n          io.eventDisposers.setKey(\"touchable\", addEventListener(io.element, this._pointerEvents.pointerdown, function (e) {\n            return _this.handlePointerDown(io, e);\n          }));\n        } else if (!this._usePointerEventsOnly) {\n          io.eventDisposers.setKey(\"touchable\", addEventListener(io.element, \"touchstart\", function (e) {\n            return _this.handleTouchDown(io, e);\n          }, this._passiveSupported ? {\n            passive: false\n          } : false));\n        }\n      }\n    } else {\n      var disposer = io.eventDisposers.getKey(\"touchable\");\n\n      if (disposer != null) {\n        disposer.dispose();\n        io.eventDisposers.removeKey(\"touchable\");\n      }\n    }\n  };\n  /**\r\n   * ==========================================================================\r\n   * Non-pointer events\r\n   * ==========================================================================\r\n   * @hidden\r\n   */\n\n  /**\r\n   * Dispatches \"focus\" event when element gains focus.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param io  Element\r\n   * @param ev  Original event\r\n   */\n\n\n  Interaction.prototype.handleFocus = function (io, ev) {\n    if (!io.focusable) {\n      ev.preventDefault();\n      return;\n    }\n\n    io.isFocused = true;\n\n    if (io.events.isEnabled(\"focus\") && !system.isPaused) {\n      var imev = {\n        type: \"focus\",\n        target: io,\n        event: ev\n      };\n      io.events.dispatchImmediately(\"focus\", imev);\n    }\n  };\n  /**\r\n   * Used by regular click events to prevent focus if \"noFocus\" is set.\r\n   *\r\n   * This should not be called by \"focus\" handlers.\r\n   *\r\n   * @param io  Element\r\n   * @param ev  Original event\r\n   */\n\n\n  Interaction.prototype.handleFocusBlur = function (io, ev) {\n    if (io.focusable !== false && this.getHitOption(io, \"noFocus\")) {\n      io.events.once(\"focus\", function () {\n        io.events.disableType(\"blur\");\n        $dom.blur();\n\n        if (io.sprite) {\n          io.sprite.handleBlur();\n        }\n\n        io.events.enableType(\"blur\");\n      });\n    }\n  };\n  /**\r\n   * Dispatches \"blur\" event when element loses focus.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param io  Element\r\n   * @param ev  Original event\r\n   */\n\n\n  Interaction.prototype.handleBlur = function (io, ev) {\n    if (!io.focusable) {\n      ev.preventDefault();\n      return;\n    }\n\n    io.isFocused = false;\n\n    if (io.events.isEnabled(\"blur\") && !system.isPaused) {\n      var imev = {\n        type: \"blur\",\n        target: io,\n        event: ev\n      };\n      io.events.dispatchImmediately(\"blur\", imev);\n    }\n  };\n  /**\r\n   * ==========================================================================\r\n   * Global keyboard-related even handlers\r\n   * ==========================================================================\r\n   * @hidden\r\n   */\n\n  /**\r\n   * Checks if there is an item that has currently focus and that they key is\r\n   * one of the directional keys. If both of the conditions are true, it\r\n   * creates an object to simulate movement of dragable element with keyboard.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param ev An original keyboard event\r\n   */\n\n\n  Interaction.prototype.handleGlobalKeyDown = function (ev) {\n    if (this.focusedObject) {\n      if (keyboard.isKey(ev, \"esc\")) {\n        // ESC removes focus\n        $dom.blur();\n      } else if (this.focusedObject.draggable && keyboard.isKey(ev, [\"up\", \"down\", \"left\", \"right\"])) {\n        // Prevent scrolling of the document\n        ev.preventDefault(); // Get focused object\n\n        var io = this.focusedObject; // Get particular key\n\n        var disposerKey = \"interactionKeyboardObject\"; // If such disposer already exists we know the event is going on so we\n        // just move on\n\n        if (io.eventDisposers.hasKey(disposerKey)) {\n          return;\n        } // Create a keyboard mover\n\n\n        var ko = new InteractionKeyboardObject(io, ev);\n        io.eventDisposers.setKey(disposerKey, ko);\n\n        switch (keyboard.getEventKey(ev)) {\n          case \"up\":\n            ko.directionY = -1;\n            break;\n\n          case \"down\":\n            ko.directionY = 1;\n            break;\n\n          case \"left\":\n            ko.directionX = -1;\n            break;\n\n          case \"right\":\n            ko.directionX = 1;\n            break;\n        }\n      }\n    }\n  };\n  /**\r\n   * Dispatches related events when the keyboard key is realeasd.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param ev An original keyboard event\r\n   */\n\n\n  Interaction.prototype.handleGlobalKeyUp = function (ev) {\n    var disposerKey = \"interactionKeyboardObject\";\n\n    if (this.focusedObject) {\n      var disposer = this.focusedObject.eventDisposers.getKey(disposerKey);\n\n      if (disposer != null) {\n        // Prevent scrolling of the document\n        ev.preventDefault(); // Dispose stuff\n\n        disposer.dispose();\n        this.focusedObject.eventDisposers.removeKey(disposerKey);\n      } // Does focused object have \"hit\" event?\n\n\n      var sprite = this.focusedObject.sprite;\n\n      if (keyboard.isKey(ev, \"enter\") && sprite) {\n        if (sprite.events.isEnabled(\"hit\") || sprite.events.isEnabled(\"toggled\")) {\n          this.focusedObject.dispatchImmediately(\"hit\");\n        } else if (sprite.showTooltipOn == \"hit\") {\n          this.focusedObject.dispatchImmediately(\"up\");\n        }\n      }\n    }\n  };\n  /**\r\n   * ==========================================================================\r\n   * Global pointer-related even handlers\r\n   * ==========================================================================\r\n   * @hidden\r\n   */\n\n  /**\r\n   * Handler for a global \"pointermove\" event.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param ev Event object\r\n   */\n\n\n  Interaction.prototype.handleGlobalPointerMove = function (ev) {\n    // Get pointer\n    var pointer = this.getPointer(ev); // Update current point position\n\n    pointer.point = this.getPointerPoint(ev); // Prepare and fire global event\n\n    if (this.events.isEnabled(\"track\") && !system.isPaused) {\n      var imev = {\n        type: \"track\",\n        target: this,\n        event: ev,\n        pointer: pointer,\n        touch: pointer.touch\n      };\n      this.events.dispatchImmediately(\"track\", imev);\n    } // Track\n\n\n    this.addBreadCrumb(pointer, pointer.point); // Process further\n\n    this.handleGlobalMove(pointer, ev);\n  };\n  /**\r\n   * Handler for a global \"pointerdown\" event.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param ev Event object\r\n   */\n\n\n  Interaction.prototype.handleGlobalPointerDown = function (ev) {\n    // Remove delayed hovers\n    this.processDelayed(); // Get pointer\n\n    var pointer = this.getPointer(ev); // Prepare and fire global event\n\n    if (this.events.isEnabled(\"down\") && !system.isPaused) {\n      var imev = {\n        type: \"down\",\n        target: this,\n        event: ev,\n        pointer: pointer,\n        touch: pointer.touch\n      };\n      this.events.dispatchImmediately(\"down\", imev);\n    }\n  };\n  /**\r\n   * Prevents touch action from firing.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param ev Event\r\n   */\n\n\n  Interaction.prototype.preventTouchAction = function (ev) {\n    if (!ev.defaultPrevented) {\n      ev.preventDefault();\n    }\n  };\n  /**\r\n   * Handler for a global \"pointerup\" event.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param ev Event object\r\n   */\n\n\n  Interaction.prototype.handleGlobalPointerUp = function (ev, cancelled) {\n    if (cancelled === void 0) {\n      cancelled = false;\n    } // Get pointer\n\n\n    var pointer = this.getPointer(ev); // Prepare and fire global event\n\n    if (this.events.isEnabled(\"up\") && !system.isPaused) {\n      var imev = {\n        type: \"up\",\n        target: this,\n        event: ev,\n        pointer: pointer,\n        touch: pointer.touch\n      };\n      this.events.dispatchImmediately(\"up\", imev);\n    } // Process further\n\n\n    this.handleGlobalUp(pointer, ev, cancelled);\n  };\n  /**\r\n  * ==========================================================================\r\n  * Global touch-related even handlers\r\n  * ==========================================================================\r\n  */\n\n  /**\r\n   * Handler for a global \"touchmove\" event.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param ev Event object\r\n   */\n\n\n  Interaction.prototype.handleGlobalTouchMove = function (ev) {\n    // Process each changed touch point\n    for (var i = 0; i < ev.changedTouches.length; i++) {\n      // Get pointer\n      var pointer = this.getPointer(ev.changedTouches[i]); // Update current point position\n\n      pointer.point = this.getPointerPoint(ev.changedTouches[i]); // Prepare and fire global event\n\n      if (this.events.isEnabled(\"track\") && !system.isPaused) {\n        var imev = {\n          type: \"track\",\n          target: this,\n          event: ev,\n          pointer: pointer,\n          touch: pointer.touch\n        };\n        this.events.dispatchImmediately(\"track\", imev);\n      } // Track\n\n\n      this.addBreadCrumb(pointer, pointer.point); // Process further\n\n      this.handleGlobalMove(pointer, ev);\n    }\n  };\n  /**\r\n   * Handler for a global \"touchstart\" event.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param ev Event object\r\n   */\n\n\n  Interaction.prototype.handleGlobalTouchStart = function (ev) {\n    // Remove delayed hovers\n    this.processDelayed(); // Process each changed touch point\n\n    for (var i = 0; i < ev.changedTouches.length; i++) {\n      // Get pointer\n      var pointer = this.getPointer(ev.changedTouches[i]); // Prepare and fire global event\n\n      if (!this._usePointerEventsOnly && this.events.isEnabled(\"down\") && !system.isPaused) {\n        var imev = {\n          type: \"down\",\n          target: this,\n          event: ev,\n          pointer: pointer,\n          touch: pointer.touch\n        };\n        this.events.dispatchImmediately(\"down\", imev);\n      }\n    }\n  };\n  /**\r\n   * Handler for a global \"touchend\" event.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param ev Event object\r\n   */\n\n\n  Interaction.prototype.handleGlobalTouchEnd = function (ev) {\n    // Process each changed touch point\n    for (var i = 0; i < ev.changedTouches.length; i++) {\n      // Get pointer\n      var pointer = this.getPointer(ev.changedTouches[i]); // Prepare and fire global event\n\n      if (this.events.isEnabled(\"up\") && !system.isPaused) {\n        var imev = {\n          type: \"up\",\n          target: this,\n          event: ev,\n          pointer: pointer,\n          touch: pointer.touch\n        };\n        this.events.dispatchImmediately(\"up\", imev);\n      } // Handle element-related events\n\n\n      this.handleGlobalUp(pointer, ev);\n    }\n  };\n  /**\r\n   * ==========================================================================\r\n   * Element-specific pointer-related even handlers\r\n   * ==========================================================================\r\n   * @hidden\r\n   */\n\n  /**\r\n   * Handles event when pointer is over [[InteractionObject]] and button is\r\n   * pressed.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param io  Element\r\n   * @param ev  Original event\r\n   */\n\n\n  Interaction.prototype.handlePointerDown = function (io, ev) {\n    // Stop further propagation so we don't get multiple triggers on hybrid\n    // devices (both mouse and touch capabilities)\n    //ev.preventDefault();\n    //ev.stopPropagation();\n    //if (ev.defaultPrevented) {\n    //}\n    // Get pointer\n    var pointer = this.getPointer(ev); // Ignore if it's anything but mouse's primary button\n\n    if (!pointer.touch && ev.which != 1 && ev.which != 3) {\n      return;\n    } // Set mouse button\n\n\n    pointer.button = ev.which; // Reset pointer\n\n    this.resetPointer(pointer, ev); // Process down\n\n    this.handleDown(io, pointer, ev);\n  };\n  /**\r\n   * Handles event when [[InteractionObject]] is hovered by a mouse pointer.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param io  Element\r\n   * @param ev  Original event\r\n   */\n\n\n  Interaction.prototype.handlePointerOver = function (io, ev) {\n    // Get pointer\n    var pointer = this.getPointer(ev); // Process down\n\n    this.handleOver(io, pointer, ev);\n  };\n  /**\r\n   * Handles event when [[InteractionObject]] loses hover from a mouse pointer.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param io  Element\r\n   * @param ev  Original event\r\n   */\n\n\n  Interaction.prototype.handlePointerOut = function (io, ev) {\n    // Get pointer\n    var pointer = this.getPointer(ev); // Process down\n\n    this.handleOut(io, pointer, ev);\n  };\n  /**\r\n   * Handles event when mouse wheel is crolled over the [[InteractionObject]].\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param io  Element\r\n   * @param ev  Original event\r\n   * @todo Investigate more-cross browser stuff https://developer.mozilla.org/en-US/docs/Web/Events/wheel\r\n   */\n\n\n  Interaction.prototype.handleMouseWheel = function (io, ev) {\n    // Get pointer\n    var pointer = this.getPointer(ev); // Update current point position\n\n    pointer.point = this.getPointerPoint(ev); // Init delta values\n\n    var deltaX = 0,\n        deltaY = 0; // Set up modifier\n    // This is needed because FireFox reports wheel deltas in \"lines\" instead\n    // of pixels so we have to approximate pixel value\n\n    var mod = 1;\n\n    if (ev.deltaMode == 1) {\n      mod = 50;\n    } // Adjust configurable sensitivity\n\n\n    mod *= this.getMouseOption(io, \"sensitivity\"); // Calculate deltas\n\n    if (ev instanceof WheelEvent) {\n      deltaX = Math.round(-1 * ev.wheelDeltaX || ev.deltaX * mod);\n      deltaY = Math.round(-1 * ev.wheelDeltaY || ev.deltaY * mod);\n    } else {\n      throw new Error(\"Invalid event type\");\n    } // Handle the event\n\n\n    this.handleWheel(io, pointer, deltaX, deltaY, ev);\n  };\n  /**\r\n   * ==========================================================================\r\n   * Element-specific touch-related even handlers\r\n   * ==========================================================================\r\n   * @hidden\r\n   */\n\n  /**\r\n    * Handles an event when an [[InteractionObject]] is touched on a touch\r\n    * device.\r\n    *\r\n    * @ignore Exclude from docs\r\n    * @param io  Element\r\n    * @param ev  Original event\r\n    */\n\n\n  Interaction.prototype.handleTouchDown = function (io, ev) {\n    // Stop further propagation so we don't get multiple triggers on hybrid\n    // devices (both mouse and touch capabilities)\n    //this.maybePreventDefault(io, ev);\n    //return;\n    // Process each changed touch point\n    for (var i = 0; i < ev.changedTouches.length; i++) {\n      // Get pointer\n      var pointer = this.getPointer(ev.changedTouches[i]);\n      this.maybePreventDefault(io, ev, pointer); // Reset pointer\n\n      this.resetPointer(pointer, ev.changedTouches[i]); // Process down\n\n      this.handleDown(io, pointer, ev);\n    }\n  };\n  /**\r\n   * ==========================================================================\r\n   * Universal handlers\r\n   * ==========================================================================\r\n   * @hidden\r\n   */\n\n  /**\r\n   * Handles click/tap. Checks for doublehit.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param io       Interaction object\r\n   * @param pointer  Pointer\r\n   * @param ev       Original event\r\n   */\n\n\n  Interaction.prototype.handleHit = function (io, pointer, ev) {\n    // Check if this is a double-hit\n    var now = $time.getTime();\n\n    if (io.lastHit && io.lastHit >= now - this.getHitOption(io, \"doubleHitTime\")) {\n      // Yup - it's a double-hit\n      // Cancel the hit\n      //clearTimeout(io.lastHitPointer.hitTimeout);\n      // If it happened too fast it probably means that hybrid device just\n      // generated two events for the same tap\n      if (now - io.lastHit < 100) {\n        // Ignore\n        return;\n      } // Clear last hit\n\n\n      io.lastHit = undefined;\n      io.lastHitPointer = undefined; // Dispatch event\n\n      if (io.events.isEnabled(\"doublehit\") && !system.isPaused) {\n        var imev = {\n          type: \"doublehit\",\n          target: io,\n          point: pointer.point,\n          event: ev,\n          touch: pointer.touch\n        };\n        io.events.dispatchImmediately(\"doublehit\", imev);\n      }\n    } else {\n      // Log last hit\n      io.lastHit = now;\n      io.lastHitPointer = pointer;\n\n      if (pointer.button === 3) {\n        // Execute HIT now\n        if (io.events.isEnabled(\"rightclick\") && !system.isPaused) {\n          var imev = {\n            type: \"rightclick\",\n            target: io,\n            event: ev\n          };\n          io.events.dispatchImmediately(\"rightclick\", imev);\n        }\n      } else {\n        if (io.events.isEnabled(\"hit\") && !system.isPaused) {\n          var imev = {\n            type: \"hit\",\n            target: io,\n            event: ev,\n            point: pointer.point,\n            touch: pointer.touch\n          };\n          io.events.dispatchImmediately(\"hit\", imev);\n        }\n      }\n    }\n  };\n  /**\r\n   * Handles pointer hovering over [[InteractionObject]].\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param io       Interaction object\r\n   * @param pointer  Pointer\r\n   * @param ev       Original event\r\n   * @param soft     Invoked by helper function\r\n   */\n\n\n  Interaction.prototype.handleOver = function (io, pointer, ev, soft) {\n    if (soft === void 0) {\n      soft = false;\n    }\n\n    if (!io.hoverable) {\n      return;\n    }\n\n    var hoversPaused = false;\n\n    if (this.shouldCancelHovers(pointer) && this.areTransformed() && this.moved(pointer, this.getHitOption(io, \"hitTolerance\"))) {\n      hoversPaused = true;\n      this.cancelAllHovers(ev);\n    } // Remove any delayed outs\n\n\n    this.processDelayed(); // Add pointer\n\n    io.overPointers.moveValue(pointer); // Check if object is not yet hovered\n\n    if (!io.isRealHover) {\n      // Set element as hovered\n      if (!hoversPaused) {\n        io.isHover = true;\n        io.isRealHover = true;\n        this.overObjects.moveValue(io);\n      } // Generate body track event. This is needed so that if element loads\n      // under unmoved mouse cursor, we still need all the actions that are\n      // required to happen to kick in.\n\n\n      this.handleTrack(this.body, pointer, ev, true); // Event\n\n      if (io.events.isEnabled(\"over\") && !system.isPaused && !hoversPaused) {\n        var imev = {\n          type: \"over\",\n          target: io,\n          event: ev,\n          pointer: pointer,\n          touch: pointer.touch\n        };\n        io.events.dispatchImmediately(\"over\", imev);\n      }\n    }\n  };\n  /**\r\n   * Handles when [[InteractionObject]] is no longer hovered.\r\n   *\r\n   * If `soft = true`, this means that method is being invoked by some other\r\n   * code, not hard \"out\" function, like `handleUp` which implies we need to\r\n   * run additional checks before unhovering the object.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param io       Interaction object\r\n   * @param pointer  Pointer\r\n   * @param ev       Original event\r\n   * @param soft     Invoked by helper function\r\n   * @param force    Force imediate out\r\n   */\n\n\n  Interaction.prototype.handleOut = function (io, pointer, ev, soft, force) {\n    var _this = this;\n\n    if (soft === void 0) {\n      soft = false;\n    }\n\n    if (force === void 0) {\n      force = false;\n    }\n\n    if (!io.hoverable) {\n      return;\n    } // Remove pointer\n\n\n    io.overPointers.removeValue(pointer); // Check if element is still hovered\n\n    if (io.isHover && (!io.hasDelayedOut || force)) {\n      // Should we run additional checks?\n      if (soft && io.overPointers.length) {\n        // There are still pointers hovering - don't do anything else and\n        // wait until either no over pointers are there or we get a hard out\n        // event.\n        return;\n      } // Should we delay \"out\" if this is happening on a touch device?\n\n\n      if (pointer && pointer.touch && !force && !this.old(pointer)) {\n        // This is a touch pointer, and it hasn't moved, let's pretend\n        // the object is still hovered, and act as per \"behavior\" setting\n        var behavior = this.getHoverOption(io, \"touchOutBehavior\");\n\n        if (behavior == \"leave\") {\n          // Set to \"leave\", so we do not execute any \"out\" event.\n          // It will be handled by any other interaction that happens\n          // afterwards.\n          this._delayedEvents.out.push({\n            type: \"out\",\n            io: io,\n            pointer: pointer,\n            event: ev,\n            keepUntil: $time.getTime() + 500\n          });\n\n          io.hasDelayedOut = true;\n          return;\n        } else if (behavior == \"delay\" && this.getHoverOption(io, \"touchOutDelay\")) {\n          this._delayedEvents.out.push({\n            type: \"out\",\n            io: io,\n            pointer: pointer,\n            event: ev,\n            keepUntil: $time.getTime() + 500,\n            timeout: this.setTimeout(function () {\n              _this.handleOut(io, pointer, ev, true);\n            }, this.getHoverOption(io, \"touchOutDelay\"))\n          });\n\n          return;\n        } else {// Nothing for \"remove\" - that's how it works \"out-of-the-box\"\n        }\n      } // Set element as not hovered\n\n\n      io.isHover = false;\n      this.overObjects.removeValue(io); // Invoke event\n\n      if (!io.isDisposed() && io.events.isEnabled(\"out\") && !system.isPaused) {\n        var imev = {\n          type: \"out\",\n          target: io,\n          event: ev,\n          pointer: pointer,\n          touch: pointer.touch\n        };\n        io.events.dispatchImmediately(\"out\", imev);\n      } // Reset object from lefover delayed outs, pointers\n\n\n      io.overPointers.clear();\n      io.hasDelayedOut = false; // @todo (clean delayed)\n    }\n  };\n  /**\r\n   * Processes dalyed events, such as \"out\" event that was initiated for\r\n   * elements by touch.\r\n   */\n\n\n  Interaction.prototype.processDelayed = function () {\n    var delayedEvent;\n\n    while (true) {\n      delayedEvent = this._delayedEvents.out.pop();\n\n      if (!delayedEvent) {\n        break;\n      }\n\n      if (delayedEvent.timeout) {\n        delayedEvent.timeout.dispose();\n      }\n\n      this.handleOut(delayedEvent.io, delayedEvent.pointer, delayedEvent.event, false, true);\n    }\n  };\n  /**\r\n   * Performs tasks on pointer down.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param io       Element\r\n   * @param pointer  Pointer\r\n   * @param ev       Original event\r\n   */\n\n\n  Interaction.prototype.handleDown = function (io, pointer, ev) {\n    // Need to prevent default event from happening on transformable objects\n    this.maybePreventDefault(io, ev, pointer); // Stop inertia animations if they're currently being played out\n\n    if (io.inert) {\n      this.stopInertia(io);\n    } // Trigger hover because some touch devices won't trigger over events\n    // on their own\n\n\n    this.handleOver(io, pointer, ev, true); // Add pointer to list\n\n    io.downPointers.moveValue(pointer); // Apply styles if necessary\n\n    this.applyCursorDownStyle(io, pointer); // Check if object is already down\n\n    if (!io.isDown) {\n      // Lose focus if needed\n      if (io.focusable !== false && this.getHitOption(io, \"noFocus\") && this.focusedObject) {\n        $dom.blur();\n      } // Set object as hovered\n\n\n      io.isDown = true;\n      this.downObjects.moveValue(io); // Prep object for dragging and/or resizing\n\n      if (io.draggable) {\n        this.processDragStart(io, pointer, ev);\n      }\n\n      if (io.resizable) {\n        this.processResizeStart(io, pointer, ev);\n      }\n    } // Dispatch \"down\" event\n\n\n    if (io.events.isEnabled(\"down\") && !system.isPaused) {\n      var imev = {\n        type: \"down\",\n        target: io,\n        event: ev,\n        pointer: pointer,\n        touch: pointer.touch\n      };\n      io.events.dispatchImmediately(\"down\", imev);\n    }\n  };\n  /**\r\n   * Performs tasks on pointer up.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param pointer  Pointer\r\n   * @param ev       Original event\r\n   */\n\n\n  Interaction.prototype.handleGlobalUp = function (pointer, ev, cancelled) {\n    var _this = this;\n\n    if (cancelled === void 0) {\n      cancelled = false;\n    }\n\n    var sorted = this.downObjects.values.slice();\n    sorted.sort(function (x, y) {\n      if (x && y) {\n        var pos = x.element.compareDocumentPosition(y.element);\n\n        if (pos & Node.DOCUMENT_POSITION_CONTAINED_BY) {\n          return 1;\n        } else if (pos & Node.DOCUMENT_POSITION_CONTAINS) {\n          return -1;\n        } else {\n          return 0;\n        }\n      } else {\n        return 0;\n      }\n    }); // Process all down objects\n\n    $array.each(sorted, function (io) {\n      // Check if this particular pointer is pressing down\n      // on object\n      if (io && io.downPointers.contains(pointer)) {\n        _this.handleUp(io, pointer, ev, cancelled);\n      }\n    });\n  };\n  /**\r\n   * Simulates all pointers being up once mouse leaves document area.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param ev       Original event\r\n   */\n\n\n  Interaction.prototype.handleDocumentLeave = function (ev) {\n    var _this = this; // Process all down objects\n\n\n    $iter.each(this.downObjects.backwards().iterator(), function (io) {\n      io.downPointers.each(function (pointer) {\n        _this.handleUp(io, pointer, ev);\n      });\n    });\n  };\n  /**\r\n   * Handles when [[InteractionObject]] is no longer hovered.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param io       Interaction object\r\n   * @param pointer  Pointer\r\n   * @param ev       Original event\r\n   */\n\n\n  Interaction.prototype.handleUp = function (io, pointer, ev, cancelled) {\n    if (cancelled === void 0) {\n      cancelled = false;\n    } // Restore cursor style\n\n\n    this.restoreCursorDownStyle(io, pointer); // Remove pointer from the list\n\n    io.downPointers.removeValue(pointer); // Trigger out because some touch devices won't trigger out events\n    // on their own\n\n    if (pointer && pointer.touch || this._useTouchEventsOnly) {\n      this.handleOut(io, pointer, ev, true);\n    } // Check if object still down\n\n\n    if (io.isDown) {\n      // Check if there are no other pointers hovering this element\n      if (io.downPointers.length == 0) {\n        // Set element as no longer down\n        io.isDown = false;\n        this.downObjects.removeValue(io);\n      } // Dispatch \"up\" event\n\n\n      if (io.events.isEnabled(\"up\") && !system.isPaused && pointer) {\n        var imev = {\n          type: \"up\",\n          target: io,\n          event: ev,\n          pointer: pointer,\n          touch: pointer.touch\n        };\n        io.events.dispatchImmediately(\"up\", imev);\n      } // Check if this was not a cancelled event.\n      // If event was canelled (which might happen if gesture resulted in\n      // navigation or page scroll) there's no point in triggering hit and\n      // other actions.\n\n\n      if (!cancelled) {\n        // Handle swiping-related stuff\n        if (io.swipeable && this.swiped(io, pointer)) {\n          // Swiped - nothing else should happen\n          this.handleSwipe(io, pointer, ev);\n        } else {\n          // Check if it maybe a click\n          if (io.clickable && !this.moved(pointer, this.getHitOption(io, \"hitTolerance\"))) {\n            this.handleHit(io, pointer, ev);\n          } // Handle inertia\n\n\n          if (io.inert && this.moved(pointer, this.getHitOption(io, \"hitTolerance\"))) {\n            this.handleInertia(io, pointer);\n          } else if (io.draggable) {\n            this.processDragStop(io, pointer, ev);\n          }\n\n          if (io.resizable) {\n            this.processResizeStop(io, pointer, ev);\n          }\n        }\n      }\n    }\n  };\n  /**\r\n   * Checks if event needs to be prevented on draggable and such items, so that\r\n   * touch gestures like navigation and scroll do not kick in.\r\n   *\r\n   * @param io  Object\r\n   * @param ev  Event\r\n   */\n\n\n  Interaction.prototype.maybePreventDefault = function (io, ev, pointer) {\n    if ($type.hasValue(ev) && (io.draggable || io.swipeable || io.trackable || io.resizable) && !this.isGlobalElement(io) && ev.cancelable !== false && (!io.isTouchProtected || !pointer || !pointer.touch)) {\n      ev.preventDefault();\n    }\n  };\n  /**\r\n   * Cancels all hovers on all currently hovered objects.\r\n   *\r\n   * @param  pointer  Pointer\r\n   * @param  ev       Event\r\n   */\n\n\n  Interaction.prototype.cancelAllHovers = function (ev) {\n    var _this = this; //this.overObjects.each((io) => {\n\n\n    $iter.each(this.overObjects.backwards().iterator(), function (io) {\n      if (io) {\n        var pointer = io.overPointers.getIndex(0);\n\n        _this.handleOut(io, pointer, ev, true, true);\n      }\n    });\n  };\n  /**\r\n   * Checks if hovers should be cancelled on transform as per global options.\r\n   * @param   pointer  Pointer\r\n   * @return           Cancel?\r\n   */\n\n\n  Interaction.prototype.shouldCancelHovers = function (pointer) {\n    return options.disableHoverOnTransform == \"always\" || options.disableHoverOnTransform == \"touch\" && pointer.touch;\n  };\n  /**\r\n   * Handles pointer move.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param pointer  Pointer\r\n   * @param ev       Original event\r\n   */\n\n\n  Interaction.prototype.handleGlobalMove = function (pointer, ev) {\n    var _this = this; // Process hovered elements\n    // We check if the element became unhovered without reporting the mouseout\n    // event. (it happens in some cases)\n\n\n    if (!pointer.touch) {\n      var target_1 = $dom.eventTarget(pointer.lastEvent);\n      $iter.each(this.overObjects.backwards().iterator(), function (io) {\n        // Is this pointer relevant to element?\n        if (io && io.overPointers.contains(pointer) && io.hoverable) {\n          // Check if the element is still hovered\n          var reset = false;\n\n          if (io.element && pointer.lastEvent) {\n            if (!$dom.contains(io.element, target_1)) {\n              reset = true;\n            }\n          } else {\n            reset = true;\n          }\n\n          if (reset) {\n            _this.handleOut(io, pointer, ev, true);\n          }\n        }\n      });\n    } // Process down elements\n\n\n    $iter.each(this.transformedObjects.backwards().iterator(), function (io) {\n      // Is this pointer relevant to element?\n      if (io.downPointers.contains(pointer) && // Swipe still happening?\n      !(io.swipeable && _this.swiping(io, pointer)) && (io.draggable || io.resizable)) {\n        _this.handleTransform(io, ev);\n      }\n    }); // Process tracked elements\n\n    $iter.each(this.trackedObjects.backwards().iterator(), function (io) {\n      // Is this pointer relevant to element?\n      if (!io.overPointers.contains(pointer)) {\n        _this.handleTrack(io, pointer, ev);\n      }\n    });\n  };\n  /**\r\n   * Handles reporting of pointer movement.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param io        Element\r\n   * @param pointer    Pointer\r\n   * @param ev         Original event\r\n   * @param skipCheck  Sould we skip check if cursor actually moved\r\n   */\n\n\n  Interaction.prototype.handleTrack = function (io, pointer, ev, skipCheck) {\n    if (skipCheck === void 0) {\n      skipCheck = false;\n    } // Do nothing if the cursor did not actually move\n\n\n    if (!skipCheck && !this.moved(pointer, 0)) {\n      return;\n    } // Initiate TRACK event\n\n\n    if (io.events.isEnabled(\"track\") && !system.isPaused) {\n      var imev = {\n        type: \"track\",\n        target: io,\n        event: ev,\n        point: pointer.point,\n        pointer: pointer,\n        touch: pointer.touch\n      };\n      io.events.dispatchImmediately(\"track\", imev);\n    }\n  };\n  /**\r\n   * Handles swipe action.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param io       Element\r\n   * @param pointer  Pointer\r\n   * @param ev       Original event\r\n   */\n\n\n  Interaction.prototype.handleSwipe = function (io, pointer, ev) {\n    // We pass in InteractionEvent with shift in mouse coordinates\n    // between when the drag started and ended\n    if (io.events.isEnabled(\"swipe\") && !system.isPaused) {\n      var imev = {\n        type: \"swipe\",\n        target: io,\n        event: ev,\n        touch: pointer.touch\n      };\n      io.events.dispatchImmediately(\"swipe\", imev);\n    }\n\n    if (pointer.startPoint.x < pointer.point.x) {\n      if (io.events.isEnabled(\"swiperight\") && !system.isPaused) {\n        var imev = {\n          type: \"swiperight\",\n          target: io,\n          event: ev,\n          touch: pointer.touch\n        };\n        io.events.dispatchImmediately(\"swiperight\", imev);\n      }\n    } else {\n      if (io.events.isEnabled(\"swipeleft\") && !system.isPaused) {\n        var imev = {\n          type: \"swipeleft\",\n          target: io,\n          event: ev,\n          touch: pointer.touch\n        };\n        io.events.dispatchImmediately(\"swipeleft\", imev);\n      }\n    }\n  };\n  /**\r\n   * Handles event triggering for wheel rotation.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param io       Element\r\n   * @param pointer  Pointer\r\n   * @param deltaX   Horizontal shift\r\n   * @param deltaY   Vertical shift\r\n   * @param ev       Original event\r\n   */\n\n\n  Interaction.prototype.handleWheel = function (io, pointer, deltaX, deltaY, ev) {\n    var shift = {\n      x: deltaX,\n      y: deltaY\n    }; // Trigger generic WHEEL event\n\n    if (io.events.isEnabled(\"wheel\") && !system.isPaused) {\n      io.events.dispatchImmediately(\"wheel\", {\n        type: \"wheel\",\n        target: io,\n        event: ev,\n        point: pointer.point,\n        shift: shift\n      });\n    } // Trigger direction-specific events\n    // Horizontal\n\n\n    if (deltaX < 0) {\n      if (io.events.isEnabled(\"wheelleft\") && !system.isPaused) {\n        io.events.dispatchImmediately(\"wheelleft\", {\n          type: \"wheelleft\",\n          target: io,\n          event: ev,\n          point: pointer.point,\n          shift: shift\n        });\n      }\n    } else if (deltaX > 0) {\n      if (io.events.isEnabled(\"swiperight\") && !system.isPaused) {\n        io.events.dispatchImmediately(\"wheelright\", {\n          type: \"wheelright\",\n          target: io,\n          event: ev,\n          point: pointer.point,\n          shift: shift\n        });\n      } // Vertical\n\n    } else if (deltaY < 0) {\n      if (io.events.isEnabled(\"wheelup\") && !system.isPaused) {\n        io.events.dispatchImmediately(\"wheelup\", {\n          type: \"wheelup\",\n          target: io,\n          event: ev,\n          point: pointer.point,\n          shift: shift\n        });\n      }\n    } else if (deltaY > 0) {\n      if (io.events.isEnabled(\"wheeldown\") && !system.isPaused) {\n        io.events.dispatchImmediately(\"wheeldown\", {\n          type: \"wheeldown\",\n          target: io,\n          event: ev,\n          point: pointer.point,\n          shift: shift\n        });\n      }\n    }\n  };\n  /**\r\n   * Initiates inertia checking sub-routines for different movement types:\r\n   * drag, resize.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param sprite\r\n   * @param pointer\r\n   */\n\n\n  Interaction.prototype.handleInertia = function (io, pointer) {\n    if (io.draggable && io.downPointers.length === 0) {\n      this.handleMoveInertia(io, pointer);\n    }\n\n    if (io.resizable && io.downPointers.length > 1) {\n      this.handleResizeInertia(io, pointer);\n    }\n  };\n  /**\r\n   * Continues moving the element to simulate the effect of inertia. Happens\r\n   * when `inert` and `draggable` object is dragged and then released.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param io       Element\r\n   * @param pointer  Pointer\r\n   */\n\n\n  Interaction.prototype.handleMoveInertia = function (io, pointer) {\n    var interaction = io;\n    var type = \"move\";\n    var point = {\n      \"x\": pointer.point.x,\n      \"y\": pointer.point.y\n    };\n    var startPoint = {\n      \"x\": pointer.startPoint.x,\n      \"y\": pointer.startPoint.y\n    }; // Init inertia object\n\n    var inertia = new Inertia(interaction, type, point, startPoint); // Get inertia data\n\n    var ref = this.getTrailPoint(pointer, $time.getTime() - this.getInertiaOption(io, \"move\", \"time\"));\n\n    if (typeof ref === \"undefined\") {\n      this.processDragStop(io, pointer, pointer.lastUpEvent);\n      return;\n    } // Init animation options\n\n\n    var factor = this.getInertiaOption(io, \"move\", \"factor\");\n    var animationOptions = [{\n      \"to\": pointer.point.x + (pointer.point.x - ref.point.x) * factor,\n      \"property\": \"x\"\n    }, {\n      \"to\": pointer.point.y + (pointer.point.y - ref.point.y) * factor,\n      \"property\": \"y\"\n    }]; // Start animation\n\n    var animation = new Animation(inertia, animationOptions, this.getInertiaOption(io, \"move\", \"duration\"), this.getInertiaOption(io, \"move\", \"easing\")).start();\n\n    this._disposers.push(animation.events.on(\"animationended\", function (ev) {\n      inertia.done();\n    })); // Add inertia object\n\n\n    io.inertias.setKey(\"move\", inertia);\n  };\n  /**\r\n   * Continues resizing of a `resizable` element after it is resized and\r\n   * released.\r\n   *\r\n   * **NOTE:** this is is just a placeholder function. No actual fucntionality\r\n   * is implemented, yet.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param io       Element\r\n   * @param pointer  Pointer\r\n   */\n\n\n  Interaction.prototype.handleResizeInertia = function (io, pointer) {// Some day, folks. Some day...\n  };\n  /**\r\n   * Recalculates element's position and size based on position of\r\n   * all its related pointers.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param io  Element\r\n   * @param ev  Original event\r\n   */\n\n\n  Interaction.prototype.handleTransform = function (io, ev) {\n    // Get primary pointer and its respective points\n    var pointer1 = io.downPointers.getIndex(0);\n    var point1 = null;\n    var startPoint1 = null;\n\n    if (pointer1) {\n      point1 = pointer1.point;\n      startPoint1 = pointer1.startPoint;\n    } // Init secondary pointer\n\n\n    var pointer2;\n    var point2;\n    var startPoint2; // Use center of the sprite to simulate \"second\" point of touch\n\n    point2 = {\n      \"x\": io.originalPosition.x,\n      \"y\": io.originalPosition.y\n    };\n    startPoint2 = point2; // Determine if it's a sinngle pointer or multi\n\n    var singlePoint = true;\n\n    for (var i = 1; i < io.downPointers.length; i++) {\n      // Get pointer\n      var nextPointer = io.downPointers.getIndex(i); // Doublecheck if it's not the same pointer by comparing original position\n\n      if (startPoint1.x != nextPointer.startPoint.x && startPoint1.y != nextPointer.startPoint.y) {\n        // Several pointers down\n        singlePoint = false; // Get second pointer\n\n        pointer2 = nextPointer;\n        point2 = pointer2.point;\n        startPoint2 = pointer2.startPoint; // Stop looking\n\n        break;\n      }\n    } // Primary touch point moved?\n\n\n    var pointer1Moved = pointer1 && this.moved(pointer1, 0); // Report DRAG_START if necessary\n\n    if (io.draggable && pointer1 && pointer1.dragStartEvents && pointer1.dragStartEvents.length && pointer1Moved) {\n      if (io.events.isEnabled(\"dragstart\") && !system.isPaused) {\n        io.events.dispatchImmediately(\"dragstart\", pointer1.dragStartEvents.shift());\n      } //delete pointer1.dragStartEvents;\n\n    } // Determine what we do in order of superiority\n\n\n    if (singlePoint && io.draggable) {\n      // We have only one pointer and the Sprite is draggable\n      // There's nothing else to be done - just move it\n      this.handleTransformMove(io, point1, startPoint1, ev, pointer1Moved, pointer1.touch);\n\n      if (this.shouldCancelHovers(pointer1) && this.moved(pointer1, this.getHitOption(io, \"hitTolerance\"))) {\n        this.cancelAllHovers(ev);\n      }\n    } else {\n      // Check if second touch point moved\n      var pointer2Moved = pointer2 && this.moved(pointer2, 0);\n\n      if (this.shouldCancelHovers(pointer1) && this.moved(pointer1, this.getHitOption(io, \"hitTolerance\")) || this.shouldCancelHovers(pointer2) && this.moved(pointer2, this.getHitOption(io, \"hitTolerance\"))) {\n        this.cancelAllHovers(ev);\n      }\n\n      if (io.draggable && io.resizable) {\n        //this.handleTransformAll(io, point1, startPoint1, point2, startPoint2, ev, pointer1Moved && pointer2Moved);\n        this.handleTransformMove(io, point1, startPoint1, ev, pointer1Moved && pointer2Moved, pointer1.touch);\n        this.handleTransformResize(io, point1, startPoint1, point2, startPoint2, ev, pointer1Moved && pointer2Moved, pointer1.touch);\n      } else {\n        if (io.draggable) {\n          this.handleTransformMove(io, point1, startPoint1, ev, pointer1Moved, pointer1.touch);\n        }\n\n        if (io.resizable && (!singlePoint || ev.ctrlKey)) {\n          this.handleTransformResize(io, point1, startPoint1, point2, startPoint2, ev, pointer1Moved && pointer2Moved, pointer1.touch);\n        }\n      }\n    }\n  };\n  /**\r\n   * Handles movement of the dragged element.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param io            Element\r\n   * @param point         Current point of the pointer\r\n   * @param startPoint    Starting point of the pointer\r\n   * @param ev            Original event\r\n   * @param pointerMoved  Did pointer move?\r\n   */\n\n\n  Interaction.prototype.handleTransformMove = function (io, point, startPoint, ev, pointerMoved, touch) {\n    if (pointerMoved) {\n      if (io.events.isEnabled(\"drag\") && !system.isPaused && (!io.isTouchProtected || !touch)) {\n        var imev = {\n          type: \"drag\",\n          target: io,\n          event: ev,\n          shift: {\n            \"x\": point.x - startPoint.x,\n            \"y\": point.y - startPoint.y\n          },\n          startPoint: startPoint,\n          point: point,\n          touch: touch\n        };\n        io.events.dispatchImmediately(\"drag\", imev);\n      }\n    }\n  };\n  /**\r\n   * Handles resizing of the element.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param io            Element\r\n   * @param point1        Current position of reference point #1\r\n   * @param startPoint1   Original position of reference point #1\r\n   * @param point2        Current position of reference point #2\r\n   * @param startPoint2   Original position of reference point #2\r\n   * @param ev            Original event\r\n   * @param pointerMoved  Did pointer move?\r\n   */\n\n\n  Interaction.prototype.handleTransformResize = function (io, point1, startPoint1, point2, startPoint2, ev, pointerMoved, touch) {\n    if (io.events.isEnabled(\"resize\") && !system.isPaused && (!io.isTouchProtected || !touch)) {\n      var imev = {\n        type: \"resize\",\n        target: io,\n        event: ev,\n        scale: $math.getScale(point1, startPoint1, point2, startPoint2),\n        startPoint1: startPoint1,\n        point1: point1,\n        startPoint2: startPoint2,\n        point2: point2,\n        touch: touch\n      };\n      io.events.dispatchImmediately(\"resize\", imev);\n    }\n  };\n  /**\r\n   * Handles all the preparations of the element when it starts to be dragged.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param io       Element\r\n   * @param pointer  Pointer\r\n   * @param ev       Original event\r\n   */\n\n\n  Interaction.prototype.processDragStart = function (io, pointer, ev) {\n    // Add to draggedObjects\n    this.transformedObjects.moveValue(io);\n\n    if (this.shouldCancelHovers(pointer)) {\n      this.cancelAllHovers(ev);\n    } // Report \"dragstart\"\n\n\n    var imev = {\n      type: \"dragstart\",\n      target: io,\n      event: ev,\n      touch: pointer ? pointer.touch : false\n    }; // Log object that we are starting to drag, so we can check against and\n    // avoid hovers on other objects that might be in the path of movement.\n\n    if (pointer) {\n      pointer.dragTarget = io; //pointer.startPoint = pointer.point;\n    }\n    /**\r\n     * If pointer is set we will not fire the event until the pointer has\r\n     * actually moved. If it's not set we don't have to wait for anything, so we\r\n     * just fire off the event right away.\r\n     */\n\n\n    if (pointer && pointer.dragStartEvents) {\n      pointer.dragStartEvents.push(imev);\n    } else {\n      if (!system.isPaused) {\n        io.dispatchImmediately(\"dragstart\", imev);\n      }\n    }\n  };\n  /**\r\n   * Finishes up element drag operation.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param io       Element\r\n   * @param pointer  Pointer\r\n   * @param ev       Original event\r\n   */\n\n\n  Interaction.prototype.processDragStop = function (io, pointer, ev) {\n    // Pointer set?\n    if (!pointer) {\n      pointer = this.getDragPointer(io);\n    } // Unset drag object\n\n\n    if (pointer) {\n      pointer.dragTarget = undefined;\n    } // Removed from transformedObjects\n\n\n    this.transformedObjects.removeValue(io); // Unlock document\n    //this.unlockDocument();\n    // Report dragstop\n\n    if (!pointer || this.moved(pointer, 0)) {\n      if (io.events.isEnabled(\"dragstop\") && !system.isPaused) {\n        var imev = {\n          type: \"dragstop\",\n          target: io,\n          touch: pointer ? pointer.touch : false\n        };\n        io.events.dispatchImmediately(\"dragstop\", imev);\n      }\n    }\n  };\n  /**\r\n   * Handles all the preparations of the element when it starts to be resized.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param io       Element\r\n   * @param pointer  Pointer\r\n   * @param ev       Original event\r\n   */\n\n\n  Interaction.prototype.processResizeStart = function (io, pointer, ev) {\n    // Add to draggedObjects\n    this.transformedObjects.moveValue(io);\n  };\n  /**\r\n   * Finishes up element drag operation.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param io       Element\r\n   * @param pointer  Pointer\r\n   * @param ev       Original event\r\n   */\n\n\n  Interaction.prototype.processResizeStop = function (io, pointer, ev) {\n    // Removed from transformedObjects\n    this.transformedObjects.removeValue(io);\n  };\n  /**\r\n   * ==========================================================================\r\n   * Controls for InteractionObjects initiating directly\r\n   * ==========================================================================\r\n   * @hidden\r\n   */\n\n  /**\r\n   * Manually triggers drag start on the element. Could be useful in cases\r\n   * where tracking or dragging one element can also influence dragging another\r\n   * element.\r\n   *\r\n   * Passing in `pointer` reference is advisable. If not passed in it will try\r\n   * to determine which pointer to attach to. However, it's better to specify\r\n   * it explicitly.\r\n   *\r\n   * @param io       Element\r\n   * @param pointer  Pointer\r\n   */\n\n\n  Interaction.prototype.dragStart = function (io, pointer) {\n    if (!pointer) {\n      pointer = this.getDragPointer(io);\n    }\n\n    if (pointer) {\n      this.handleDown(io, pointer, pointer.lastDownEvent);\n    }\n  };\n  /**\r\n   * Manually ends drag on the element.\r\n   *\r\n   * @param io       Element\r\n   * @param pointer  Pointer\r\n   */\n\n\n  Interaction.prototype.dragStop = function (io, pointer, cancelled) {\n    if (!pointer) {\n      pointer = this.getDragPointer(io);\n    }\n\n    if (pointer && !cancelled) {\n      this.handleGlobalUp(pointer, pointer.lastUpEvent, cancelled);\n    }\n  };\n  /**\r\n   * This method uses a fuzzy logic to find the pointer to be used for dragging.\r\n   * Beware that this is not a rock-solid solution. If there are a few objects\r\n   * being dragged at the same time, you may get unexepected results.\r\n   *\r\n   * @param io  InteractionObject to get pointers from\r\n   * @return Pointer currently being used for dragging\r\n   */\n\n\n  Interaction.prototype.getDragPointer = function (io) {\n    if (io) {\n      // InteractionObject is supplied\n      // Use it's first down pointer\n      return io.downPointers.getIndex(0);\n    } else if (this.transformedObjects.length) {\n      // Use first dragged object\n      return this.getDragPointer(this.transformedObjects.getIndex(0));\n    } else {\n      return undefined;\n    }\n  };\n  /**\r\n   * ==========================================================================\r\n   * Utils\r\n   * ==========================================================================\r\n   * @hidden\r\n   */\n\n  /**\r\n   * Returns pointer id for the given event object.\r\n   *\r\n   * @param ev  Event\r\n   * @return Pointer ID\r\n   */\n\n\n  Interaction.prototype.getPointerId = function (ev) {\n    var id = \"\";\n\n    if ($type.hasValue(ev.identifier)) {\n      id = \"\" + ev.identifier;\n    } else if ($type.hasValue(ev.pointerId)) {\n      id = \"\" + ev.pointerId;\n    } else {\n      id = \"m\";\n    }\n\n    return id.replace(\"-\", \"\");\n  };\n  /**\r\n   * Returns a cursor position of the event.\r\n   *\r\n   * @param ev  Original event\r\n   * @return Event point\r\n   */\n\n\n  Interaction.prototype.getPointerPoint = function (ev) {\n    return {\n      \"x\": ev.clientX,\n      \"y\": ev.clientY\n    };\n  };\n  /**\r\n   * Returns [[Pointer]] object that is associated with the Event.\r\n   *\r\n   * If no such [[Pointer]] object exists, it is created.\r\n   *\r\n   * @param ev  Event\r\n   * @return Pointer\r\n   */\n\n\n  Interaction.prototype.getPointer = function (ev) {\n    // Get pointer id\n    var id = this.getPointerId(ev); // Get current coordinates\n\n    var point = this.getPointerPoint(ev); // Look for the pointer in the Dictionary if it maybe already exists\n\n    var pointer;\n\n    if (this.pointers.hasKey(id)) {\n      // We already have such pointer\n      pointer = this.pointers.getKey(id); // We need this, because Edge reuses pointer ids across touch and mouse\n\n      pointer.touch = this.isPointerTouch(ev); // Reset pointer\n      //pointer.point = point;\n    } else {\n      // Init pointer\n      pointer = {\n        \"id\": id,\n        //\"touch\": !(ev instanceof MouseEvent) || ((<any>ev).pointerType && (<any>ev).pointerType != \"pointer\"),\n        //\"touch\": !(ev instanceof MouseEvent) || ((<any>ev).pointerType && (<any>ev).pointerType != \"mouse\"),\n        \"touch\": this.isPointerTouch(ev),\n        \"startPoint\": point,\n        \"startTime\": $time.getTime(),\n        \"point\": point,\n        \"track\": [],\n        \"swipeCanceled\": false,\n        \"dragStartEvents\": []\n      }; // Add first breadcrumb\n\n      this.addBreadCrumb(pointer, point); // Add for re-use later\n\n      this.pointers.setKey(id, pointer);\n    } // Log last event\n\n\n    pointer.lastEvent = ev;\n    this.lastPointer = pointer;\n    return pointer;\n  };\n  /**\r\n   * Determines if pointer event originated from a touch pointer or mouse.\r\n   *\r\n   * @param ev  Original event\r\n   * @return Touch pointer?\r\n   */\n\n\n  Interaction.prototype.isPointerTouch = function (ev) {\n    if (typeof Touch !== \"undefined\" && ev instanceof Touch) {\n      return true;\n    } else if (typeof PointerEvent !== \"undefined\" && ev instanceof PointerEvent && $type.hasValue(ev.pointerType)) {\n      switch (ev.pointerType) {\n        case \"touch\":\n        case \"pen\":\n        case 2:\n          return true;\n\n        case \"mouse\":\n        case 4:\n          return false;\n\n        default:\n          return !(ev instanceof MouseEvent);\n      }\n    } else if ($type.hasValue(ev.type)) {\n      if (ev.type.match(/^mouse/)) {\n        return false;\n      }\n    }\n\n    return true;\n  };\n  /**\r\n   * Resets the poiner to original state, i.e. cleans movement information,\r\n   * starting point, etc.\r\n   *\r\n   * @param pointer Pointer\r\n   */\n\n\n  Interaction.prototype.resetPointer = function (pointer, ev) {\n    // Get current coordinates\n    var point = this.getPointerPoint(ev);\n    ;\n    pointer.startTime = $time.getTime();\n    pointer.startPoint = {\n      x: point.x,\n      y: point.y\n    };\n    pointer.point = {\n      x: point.x,\n      y: point.y\n    };\n    pointer.track = [];\n    pointer.swipeCanceled = false; //clearTimeout(pointer.swipeTimeout);\n    //clearTimeout(pointer.holdTimeout);\n  };\n  /**\r\n   * Adds a \"breadcrumb\" point to the [[Pointer]] to log its movement path.\r\n   *\r\n   * @param pointer  Pointer\r\n   * @param point    Point coordinates\r\n   */\n\n\n  Interaction.prototype.addBreadCrumb = function (pointer, point) {\n    pointer.track.push({\n      \"timestamp\": $time.getTime(),\n      \"point\": point\n    });\n  };\n  /**\r\n   * Prepares the document for various touch-related operations.\r\n   *\r\n   * @ignore Exclude from docs\r\n   */\n\n\n  Interaction.prototype.lockDocument = function () {\n    this.prepElement(this.body);\n  };\n  /**\r\n   * Restores document functionality.\r\n   *\r\n   * @ignore Exclude from docs\r\n   */\n\n\n  Interaction.prototype.unlockDocument = function () {\n    if (this.transformedObjects.length == 0) {\n      this.restoreAllStyles(this.body);\n    }\n  };\n  /**\r\n   * Lock element (disable all touch)\r\n   *\r\n   * @ignore Exclude from docs\r\n   */\n\n\n  Interaction.prototype.lockElement = function (io) {\n    this.prepElement(io);\n  };\n  /**\r\n   * Restores element's functionality.\r\n   *\r\n   * @ignore Exclude from docs\r\n   */\n\n\n  Interaction.prototype.unlockElement = function (io) {\n    this.restoreAllStyles(io);\n  };\n  /**\r\n   * Locks document's wheel scroll.\r\n   *\r\n   * @ignore Exclude from docs\r\n   */\n\n\n  Interaction.prototype.lockWheel = function () {\n    window.addEventListener(this._pointerEvents.wheel, this.wheelLockEvent, this._passiveSupported ? {\n      passive: false\n    } : false);\n  };\n  /**\r\n   * Unlocks document's wheel scroll.\r\n   *\r\n   * @ignore Exclude from docs\r\n   */\n\n\n  Interaction.prototype.unlockWheel = function () {\n    window.removeEventListener(this._pointerEvents.wheel, this.wheelLockEvent);\n  };\n  /**\r\n   * Checks if top element at pointer's position belongs to the SVG.\r\n   *\r\n   * @ignore Exlude from docs\r\n   * @param pointer  Pointer\r\n   * @param svg      The <svg> element\r\n   * @param id       A unique identifier of the object that is checking for locality\r\n   * @return Belongs to SVG\r\n   */\n\n\n  Interaction.prototype.isLocalElement = function (pointer, svg, id) {\n    var cached = this.getCache(\"local_pointer_\" + pointer.id);\n\n    if ($type.hasValue(cached)) {\n      return cached;\n    }\n\n    var doc = $dom.getRoot(svg) || document;\n\n    if (doc.elementFromPoint) {\n      var target = doc.elementFromPoint(pointer.point.x, pointer.point.y);\n      var local = target && $dom.contains(svg, target);\n      this.setCache(\"local_pointer_\" + pointer.id + \"_\" + id, local, 100);\n      return local;\n    }\n\n    return false;\n  };\n  /**\r\n   * A function that cancels mouse wheel scroll.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param ev  Event object\r\n   * @return Returns `false` to cancel\r\n   */\n\n\n  Interaction.prototype.wheelLockEvent = function (ev) {\n    ev.preventDefault();\n    return false;\n  };\n  /**\r\n   * Applies a set of styles to an element. Stores the original styles so they\r\n   * can be restored later.\r\n   *\r\n   * @ignore\r\n   * @param io      Element\r\n   */\n\n\n  Interaction.prototype.prepElement = function (io) {\n    var el = io.element;\n\n    if (el) {\n      // Define possible props\n      var props = [\"touchAction\", \"webkitTouchAction\", \"MozTouchAction\", \"MSTouchAction\", \"msTouchAction\", \"oTouchAction\", \"userSelect\", \"webkitUserSelect\", \"MozUserSelect\", \"MSUserSelect\", \"msUserSelect\", \"oUserSelect\", \"touchSelect\", \"webkitTouchSelect\", \"MozTouchSelect\", \"MSTouchSelect\", \"msTouchSelect\", \"oTouchSelect\", \"touchCallout\", \"webkitTouchCallout\", \"MozTouchCallout\", \"MSTouchCallout\", \"msTouchCallout\", \"oTouchCallout\", \"contentZooming\", \"webkitContentZooming\", \"MozContentZooming\", \"MSContentZooming\", \"msContentZooming\", \"oContentZooming\", \"userDrag\", \"webkitUserDrag\", \"MozUserDrag\", \"MSUserDrag\", \"msUserDrag\", \"oUserDrag\"];\n\n      for (var i = 0; i < props.length; i++) {\n        if (props[i] in el.style) {\n          this.setTemporaryStyle(io, props[i], \"none\");\n        }\n      } // Remove iOS-specific selection;\n\n\n      this.setTemporaryStyle(io, \"tapHighlightColor\", \"rgba(0, 0, 0, 0)\"); //this.setTemporaryStyle(io, \"webkitOverflowScrolling\", \"none\");\n    }\n  };\n  /**\r\n   * Restores replaced styles\r\n   *\r\n   * @ignore\r\n   * @param  io  Element\r\n   */\n\n\n  Interaction.prototype.unprepElement = function (io) {\n    var el = io.element;\n\n    if (el) {\n      // Define possible props\n      var props = [\"touchAction\", \"webkitTouchAction\", \"MozTouchAction\", \"MSTouchAction\", \"msTouchAction\", \"oTouchAction\", \"userSelect\", \"webkitUserSelect\", \"MozUserSelect\", \"MSUserSelect\", \"msUserSelect\", \"oUserSelect\", \"touchSelect\", \"webkitTouchSelect\", \"MozTouchSelect\", \"MSTouchSelect\", \"msTouchSelect\", \"oTouchSelect\", \"touchCallout\", \"webkitTouchCallout\", \"MozTouchCallout\", \"MSTouchCallout\", \"msTouchCallout\", \"oTouchCallout\", \"contentZooming\", \"webkitContentZooming\", \"MozContentZooming\", \"MSContentZooming\", \"msContentZooming\", \"oContentZooming\", \"userDrag\", \"webkitUserDrag\", \"MozUserDrag\", \"MSUserDrag\", \"msUserDrag\", \"oUserDrag\"];\n\n      for (var i = 0; i < props.length; i++) {\n        if (props[i] in el.style) {\n          this.restoreStyle(io, props[i]);\n        }\n      } // Remove iOS-specific selection;\n\n\n      this.restoreStyle(io, \"tapHighlightColor\"); //this.restoreStyle(io, \"webkitOverflowScrolling\");\n    }\n  };\n  /**\r\n   * Returns an option associated with hit events.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param io      Element\r\n   * @param option  Option key\r\n   * @return Option value\r\n   */\n\n\n  Interaction.prototype.getHitOption = function (io, option) {\n    var res = io.hitOptions[option];\n\n    if (typeof res === \"undefined\") {\n      res = this.hitOptions[option];\n    }\n\n    return res;\n  };\n  /**\r\n   * Returns an option associated with hover events.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param io      Element\r\n   * @param option  Option key\r\n   * @return Option value\r\n   */\n\n\n  Interaction.prototype.getHoverOption = function (io, option) {\n    var res = io.hoverOptions[option];\n\n    if (typeof res === \"undefined\") {\n      res = this.hoverOptions[option];\n    }\n\n    return res;\n  };\n  /**\r\n   * Returns an option associated with swipe events.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param io      Element\r\n   * @param option  Option key\r\n   * @return Option value\r\n   */\n\n\n  Interaction.prototype.getSwipeOption = function (io, option) {\n    var res = io.swipeOptions[option];\n\n    if (typeof res === \"undefined\") {\n      res = this.swipeOptions[option];\n    }\n\n    return res;\n  };\n  /**\r\n   * Returns an option for keyboard.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param io      Element\r\n   * @param option  Option key\r\n   * @return Option value\r\n   */\n\n\n  Interaction.prototype.getKeyboardOption = function (io, option) {\n    var res = io.keyboardOptions[option];\n\n    if (typeof res === \"undefined\") {\n      res = this.keyboardOptions[option];\n    }\n\n    return res;\n  };\n  /**\r\n   * Returns an option for mouse.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param io      Element\r\n   * @param option  Option key\r\n   * @return Option value\r\n   */\n\n\n  Interaction.prototype.getMouseOption = function (io, option) {\n    var res = io.mouseOptions[option];\n\n    if (typeof res === \"undefined\") {\n      res = this.mouseOptions[option];\n    }\n\n    return res;\n  };\n  /**\r\n   * Returns an option associated with inertia.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param io      Element\r\n   * @param type    Inertia type\r\n   * @param option  Option key\r\n   * @return Option value\r\n   */\n\n\n  Interaction.prototype.getInertiaOption = function (io, type, option) {\n    var options = io.inertiaOptions.getKey(type);\n    var res;\n\n    if (options && $type.hasValue(options[option])) {\n      res = options[option];\n    } else {\n      res = this.inertiaOptions.getKey(type)[option];\n    }\n\n    return res;\n  };\n  /**\r\n   * Stops currently going on inertia. Useful if inertia is currently being\r\n   * animated and the object is being interacted with.\r\n   *\r\n   * @param io Element\r\n   */\n\n\n  Interaction.prototype.stopInertia = function (io) {\n    var x;\n    var inertias = [\"move\", \"resize\"];\n\n    for (var i = 0; i < inertias.length; i++) {\n      x = inertias[i];\n\n      if (io.inertias.hasKey(x)) {\n        var inertia = io.inertias.getKey(x);\n\n        if (inertia) {\n          inertia.dispose(); //io.inertiaAnimations.removeKey(x);\n          //this.processDragStop(io);\n\n          continue;\n        }\n      }\n    }\n  };\n  /**\r\n   * Check if swiping is currently being performed on an object.\r\n   *\r\n   * @param io       Element\r\n   * @param pointer  Pointer to check\r\n   * @return `true` if swiping\r\n   */\n\n\n  Interaction.prototype.swiping = function (io, pointer) {\n    var now = $time.getTime();\n\n    if (pointer.swipeCanceled || !io.swipeable) {\n      return false;\n    } else if (Math.abs(pointer.startPoint.y - pointer.point.y) < this.getSwipeOption(io, \"verticalThreshold\") && pointer.startTime > now - this.getSwipeOption(io, \"time\")) {\n      return true;\n    } else {\n      return false;\n    }\n  };\n  /**\r\n   * Returns `true` if a successfull swipe action was performed on an element.\r\n   *\r\n   * @param io       Element\r\n   * @param pointer  Pointer\r\n   * @return Swiped?\r\n   */\n\n\n  Interaction.prototype.swiped = function (io, pointer) {\n    var now = $time.getTime();\n\n    if (pointer.swipeCanceled) {\n      return false;\n    } else if (Math.abs(pointer.startPoint.x - pointer.point.x) > this.getSwipeOption(io, \"horizontalThreshold\") && Math.abs(pointer.startPoint.y - pointer.point.y) < this.getSwipeOption(io, \"verticalThreshold\") && pointer.startTime > now - this.getSwipeOption(io, \"time\")) {\n      return true;\n    } else {\n      return false;\n    }\n  };\n  /**\r\n   * Applies style to mouse cursor based on its stage in relation to\r\n   * [[InteractionObject]].\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param Element\r\n   */\n\n\n  Interaction.prototype.applyCursorOverStyle = function (io) {\n    // Get sprite's cursor ooptions\n    var options = io.cursorOptions;\n\n    if (!$type.hasValue(options.overStyle)) {\n      return;\n    } // Apply cursor down styles\n\n\n    for (var i = 0; i < options.overStyle.length; i++) {\n      $dom.setStyle(io.element, options.overStyle[i].property, options.overStyle[i].value);\n    }\n  };\n  /**\r\n   * Applies style to mouse cursor based on its stage in relation to\r\n   * [[InteractionObject]].\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param io       Element\r\n   * @param pointer  Pointer\r\n   */\n\n\n  Interaction.prototype.applyCursorDownStyle = function (io, pointer) {\n    // Not applicable for touch pointers since they don't display a cursor\n    if (pointer && pointer.touch) {\n      return;\n    }\n\n    var downStyle = io.cursorOptions.downStyle; // Is down?\n\n    if (io.downPointers.contains(pointer) && $type.hasValue(downStyle)) {\n      // Apply cursor down styles\n      for (var i = 0; i < downStyle.length; i++) {\n        this.setTemporaryStyle(this.body, downStyle[i].property, downStyle[i].value);\n        this.setTemporaryStyle(io, downStyle[i].property, downStyle[i].value);\n      }\n    }\n  };\n  /**\r\n   * Restores original cursor style for the element.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param io       Element\r\n   * @param pointer  Pointer\r\n   */\n\n\n  Interaction.prototype.restoreCursorDownStyle = function (io, pointer) {\n    // Not applicable for touch pointers since they don't display a cursor\n    if (pointer && pointer.touch) {\n      return;\n    }\n\n    var downStyle = io.cursorOptions.downStyle; // Is down?\n\n    if (io.downPointers.contains(pointer) && $type.hasValue(downStyle)) {\n      // Apply cursor down styles\n      for (var i = 0; i < downStyle.length; i++) {\n        this.restoreStyle(this.body, downStyle[i].property);\n        this.restoreStyle(io, downStyle[i].property);\n      }\n    }\n  };\n  /**\r\n   * Sets style on the body of the document.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param style  Style definitions\r\n   */\n\n\n  Interaction.prototype.setGlobalStyle = function (style) {\n    var body = getInteraction().body;\n    var styles = $type.isArray(style) ? style : [style];\n\n    for (var i = 0; i < styles.length; i++) {\n      this.setTemporaryStyle(body, styles[i].property, styles[i].value);\n    }\n  };\n  /**\r\n   * Restores style on the body of the document.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param style  Style definitions\r\n   */\n\n\n  Interaction.prototype.restoreGlobalStyle = function (style) {\n    var body = getInteraction().body;\n    var styles = $type.isArray(style) ? style : [style];\n\n    for (var i = 0; i < styles.length; i++) {\n      this.restoreStyle(body, styles[i].property);\n    }\n  };\n  /**\r\n   * Checks if element is a non-cahrt element.\r\n   *\r\n   * @param io  InteractionObject\r\n   * @return Global element?\r\n   */\n\n\n  Interaction.prototype.isGlobalElement = function (io) {\n    return document.body === io.element;\n  };\n  /**\r\n   * Checks if pointer has moved since it was created.\r\n   *\r\n   * @param pointer    Pointer\r\n   * @param tolerance  Tolerance in pixels\r\n   * @param minTime    Minimum time required for the pointer to be down to be considered moved\r\n   * @return `true` if the pointer has moved\r\n   */\n\n\n  Interaction.prototype.moved = function (pointer, tolerance, minTime) {\n    /*// If there was more time, we don't care if cursor actually moved\r\n    let duration = $time.getTime() - pointer.startTime;\r\n    if ($type.hasValue(minTime) && (minTime > duration)) {\r\n        return false;\r\n    }*/\n    if (minTime === void 0) {\n      minTime = 300;\n    } // That was quick measure shift\n\n\n    var shift = this.getShift(pointer);\n    return Math.abs(shift.x) > tolerance || Math.abs(shift.y) > tolerance;\n  };\n  /**\r\n   * Returns if pointer is \"old\", meaning it has been pressing for more than\r\n   * X milliseconds.\r\n   *\r\n   * @ignore\r\n   * @param pointer  Pointer\r\n   * @param minTime  Minimum time to consider pointer old\r\n   * @return {boolean}\r\n   */\n\n\n  Interaction.prototype.old = function (pointer, minTime) {\n    if (minTime === void 0) {\n      minTime = 300;\n    }\n\n    return $time.getTime() - pointer.startTime > minTime;\n  };\n  /**\r\n   * Returns total a shift in pointers coordinates between its original\r\n   * position and now.\r\n   *\r\n   * @param pointer  Pointer\r\n   * @return Shift in coordinates (x/y)\r\n   */\n\n\n  Interaction.prototype.getShift = function (pointer) {\n    return {\n      \"x\": pointer.startPoint.x - pointer.point.x,\n      \"y\": pointer.startPoint.y - pointer.point.y\n    };\n  };\n  /**\r\n   * Returns a point from [[Pointer]]'s move history at a certain timetamp.\r\n   *\r\n   * @param pointer    Pointer\r\n   * @param timestamp  Timestamp\r\n   * @return Point\r\n   */\n\n\n  Interaction.prototype.getTrailPoint = function (pointer, timestamp) {\n    var res;\n\n    for (var i = 0; i < pointer.track.length; i++) {\n      if (pointer.track[i].timestamp >= timestamp) {\n        res = pointer.track[i];\n        break;\n      }\n    }\n\n    return res;\n  };\n  /**\r\n   * Checks if same pointer already exists in the list.\r\n   *\r\n   * @param list     List to check agains\r\n   * @param pointer  Pointer\r\n   * @return Exists?\r\n   */\n\n\n  Interaction.prototype.pointerExists = function (list, pointer) {\n    var exists = false;\n    list.each(function (item) {\n      if (item == pointer) {\n        return;\n      }\n\n      exists = item.point.x == pointer.point.x && item.point.y == pointer.point.y;\n    });\n    return exists;\n  };\n  /**\r\n   * Returns an [[InteractionObject]] representation of a DOM element.\r\n   *\r\n   * You can use this on any HTML or SVG element, to add interactive features\r\n   * to it.\r\n   *\r\n   * @param element  Element\r\n   * @return InteractionObject\r\n   */\n\n\n  Interaction.prototype.getInteraction = function (element) {\n    return new InteractionObject(element);\n  };\n  /**\r\n   * Sets a style property on an element. Stores original value to be restored\r\n   * later with [[restoreStyle]].\r\n   *\r\n   * @see {@link restoreStyle}\r\n   * @param io        Element\r\n   * @param property  Property\r\n   * @param value     Value\r\n   */\n\n\n  Interaction.prototype.setTemporaryStyle = function (io, property, value) {\n    // Get element\n    //let el = io.element.tagName == \"g\" ? <SVGSVGElement>io.element.parentNode : io.element;\n    var el = io.element; // Save original property if it is set and hasn't been saved before already\n\n    if ($type.hasValue(el.style[property]) && !io.replacedStyles.hasKey(property)) {\n      io.replacedStyles.setKey(property, el.style[property]);\n    } // Replace with the new one\n\n\n    $dom.setStyle(el, property, value);\n  };\n  /**\r\n   * Restores specific style on an element.\r\n   *\r\n   * @param io        Element\r\n   * @param property  Style property\r\n   */\n\n\n  Interaction.prototype.restoreStyle = function (io, property) {\n    // Reset style\n    if (io.replacedStyles.hasKey(property)) {\n      io.element.style[property] = io.replacedStyles.getKey(property);\n      io.replacedStyles.removeKey(property);\n    } else {\n      delete io.element.style[property];\n    }\n  };\n  /**\r\n   * Restore temporarily reset styles on an element.\r\n   *\r\n   * @param io Element\r\n   */\n\n\n  Interaction.prototype.restoreAllStyles = function (io) {\n    $iter.each(io.replacedStyles.iterator(), function (a) {\n      var key = a[0];\n      var value = a[1];\n      io.element.style[key] = value;\n      io.replacedStyles.removeKey(key);\n    });\n  };\n  /**\r\n   * Disposes this object and cleans up after itself.\r\n   */\n\n\n  Interaction.prototype.dispose = function () {\n    if (!this.isDisposed()) {\n      _super.prototype.dispose.call(this);\n\n      this.restoreAllStyles(this.body);\n      this.unlockWheel();\n    }\n  }; // @ts-ignore Used for debugging\n\n\n  Interaction.prototype.log = function (text, ev, io) {\n    var show = true;\n\n    if (show) {\n      // Touchlist?\n      if (ev.changedTouches) {\n        for (var i = 0; i < ev.changedTouches.length; i++) {\n          this.logTouch(text, ev.type, ev.changedTouches[i]);\n        }\n\n        return;\n      } // Get type\n\n\n      var type = \"\";\n\n      if (ev.pointerType) {\n        switch (ev.pointerType) {\n          case 2:\n            type = \"touch\";\n            break;\n\n          case 4:\n            type = \"mouse\";\n            break;\n\n          default:\n            type = ev.pointerType;\n            break;\n        }\n      } else if (typeof TouchEvent != \"undefined\" && ev instanceof TouchEvent) {\n        type = \"touch\";\n      } else if (ev.type.match(/^mouse/)) {\n        type = \"mouse\";\n      } else {\n        type = \"???\";\n      } // Get ID\n\n\n      var id = \"\";\n\n      if ($type.hasValue(ev.identifier)) {\n        id = ev.identifier;\n      } else if ($type.hasValue(ev.pointerId)) {\n        id = ev.pointerId;\n      } else {\n        id = \"???\";\n      }\n\n      if (io) {\n        console.log(text + \" (\" + io.uid + \")  \" + ev.type + \"  \" + type + \"  \" + id);\n      } else {\n        console.log(text + \"  \" + ev.type + \"  \" + type + \"  \" + id);\n      }\n    }\n  };\n  /**\r\n   * Checks whether there are currently any objects being transformed (dragged\r\n   * or resized).\r\n   *\r\n   * If `except` is set, that object will be ignored.\r\n   *\r\n   * @since 4.9.3\r\n   * @param   except  Ignore this object(s)\r\n   * @return          Objects are being transformed\r\n   */\n\n\n  Interaction.prototype.areTransformed = function (except) {\n    var count = this.transformedObjects.length;\n\n    if (except) {\n      var ex = $type.isArray(except) ? except : [except];\n\n      for (var i = 0; i < ex.length; i++) {\n        if (this.transformedObjects.contains(ex[i])) {\n          count--;\n        }\n      }\n    }\n\n    return count > 0;\n  };\n  /**\r\n   * Log.\r\n   */\n\n\n  Interaction.prototype.logTouch = function (text, type, ev) {\n    console.log(text + \"  \" + type + \"  \" + \"touch\" + \"  \" + ev.identifier);\n  };\n\n  Object.defineProperty(Interaction, \"passiveSupported\", {\n    /**\r\n     * Indicates if passive mode options is supported by this browser.\r\n     */\n    get: function () {\n      var _this = this;\n\n      if (this._passiveSupported == null) {\n        // Check for passive mode support\n        try {\n          var options_1 = Object.defineProperty({}, \"passive\", {\n            get: function () {\n              _this._passiveSupported = true;\n            }\n          });\n          window.addEventListener(\"test\", options_1, options_1);\n          window.removeEventListener(\"test\", options_1, options_1);\n        } catch (err) {\n          this._passiveSupported = false;\n        }\n      }\n\n      return this._passiveSupported;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  return Interaction;\n}(BaseObjectEvents);\n\nexport { Interaction };\nvar interaction = null;\n/**\r\n * Returns a single unified global instance of [[Interaction]].\r\n *\r\n * All code should use this function, rather than create their own instances\r\n * of [[Interaction]].\r\n */\n\nexport function getInteraction() {\n  if (interaction == null) {\n    interaction = new Interaction();\n  }\n\n  return interaction;\n}","map":{"version":3,"names":["__extends","BaseObjectEvents","List","Animation","MultiDisposer","InteractionObject","InteractionKeyboardObject","Dictionary","Inertia","addEventListener","keyboard","system","options","$ease","$math","$array","$dom","$iter","$type","$time","Interaction","_super","_this","call","_globalEventsAdded","_pointerEvents","_usePointerEventsOnly","_useTouchEventsOnly","_addHoverEvents","_passiveSupported","_delayedEvents","out","overObjects","downObjects","trackedObjects","transformedObjects","pointers","inertiaOptions","hitOptions","hoverOptions","swipeOptions","keyboardOptions","mouseOptions","className","body","getInteraction","document","_disposers","push","window","hasOwnProperty","pointerdown","pointerup","pointermove","pointercancel","pointerover","pointerout","matchMedia","matches","navigator","userAgent","match","fullFF","createElement","wheel","hasValue","onmousewheel","setKey","polyOut3","passiveSupported","applyTheme","prototype","debug","addGlobalEvents","ev","handleGlobalPointerDown","handleGlobalPointerMove","handleGlobalPointerUp","relatedTarget","buttons","which","handleDocumentLeave","handleGlobalTouchStart","handleGlobalTouchMove","handleGlobalTouchEnd","handleGlobalKeyDown","handleGlobalKeyUp","processClickable","io","processTouchable","processContextMenu","contextMenuDisabled","eventDisposers","hasKey","element","e","preventDefault","getKey","dispose","processHoverable","hoverable","trackable","applyCursorOverStyle","handlePointerOut","handlePointerOver","disposer","removeKey","processMovable","draggable","swipeable","resizable","isGlobalElement","isTouchProtected","prepElement","processTrackable","moveValue","removeValue","processDraggable","processSwipeable","processResizable","processWheelable","wheelable","handleMouseWheel","passive","events","on","unlockWheel","lockWheel","processFocusable","focusable","tabindex","handleFocus","handleBlur","handleFocusBlur","clickable","handlePointerDown","handleTouchDown","isFocused","isEnabled","isPaused","imev","type","target","event","dispatchImmediately","getHitOption","once","disableType","blur","sprite","enableType","focusedObject","isKey","disposerKey","ko","getEventKey","directionY","directionX","showTooltipOn","pointer","getPointer","point","getPointerPoint","touch","addBreadCrumb","handleGlobalMove","processDelayed","preventTouchAction","defaultPrevented","cancelled","handleGlobalUp","i","changedTouches","length","button","resetPointer","handleDown","handleOver","handleOut","deltaX","deltaY","mod","deltaMode","getMouseOption","WheelEvent","Math","round","wheelDeltaX","wheelDeltaY","Error","handleWheel","maybePreventDefault","handleHit","now","getTime","lastHit","undefined","lastHitPointer","soft","hoversPaused","shouldCancelHovers","areTransformed","moved","cancelAllHovers","overPointers","isRealHover","isHover","handleTrack","force","hasDelayedOut","old","behavior","getHoverOption","keepUntil","timeout","setTimeout","isDisposed","clear","delayedEvent","pop","inert","stopInertia","downPointers","applyCursorDownStyle","isDown","processDragStart","processResizeStart","sorted","values","slice","sort","x","y","pos","compareDocumentPosition","Node","DOCUMENT_POSITION_CONTAINED_BY","DOCUMENT_POSITION_CONTAINS","each","contains","handleUp","backwards","iterator","restoreCursorDownStyle","swiped","handleSwipe","handleInertia","processDragStop","processResizeStop","cancelable","getIndex","disableHoverOnTransform","target_1","eventTarget","lastEvent","reset","swiping","handleTransform","skipCheck","startPoint","shift","handleMoveInertia","handleResizeInertia","interaction","inertia","ref","getTrailPoint","getInertiaOption","lastUpEvent","factor","animationOptions","animation","start","done","inertias","pointer1","point1","startPoint1","pointer2","point2","startPoint2","originalPosition","singlePoint","nextPointer","pointer1Moved","dragStartEvents","handleTransformMove","pointer2Moved","handleTransformResize","ctrlKey","pointerMoved","scale","getScale","dragTarget","getDragPointer","dragStart","lastDownEvent","dragStop","getPointerId","id","identifier","pointerId","replace","clientX","clientY","isPointerTouch","lastPointer","Touch","PointerEvent","pointerType","MouseEvent","startTime","track","swipeCanceled","lockDocument","unlockDocument","restoreAllStyles","lockElement","unlockElement","wheelLockEvent","removeEventListener","isLocalElement","svg","cached","getCache","doc","getRoot","elementFromPoint","local","setCache","el","props","style","setTemporaryStyle","unprepElement","restoreStyle","option","res","getSwipeOption","getKeyboardOption","abs","cursorOptions","overStyle","setStyle","property","value","downStyle","setGlobalStyle","styles","isArray","restoreGlobalStyle","tolerance","minTime","getShift","timestamp","pointerExists","list","exists","item","replacedStyles","a","key","log","text","show","logTouch","TouchEvent","console","uid","except","count","ex","Object","defineProperty","get","options_1","err","enumerable","configurable"],"sources":["D:/APPLICATION/UI/UPL/NEW/node_modules/@amcharts/amcharts4/.internal/core/interaction/Interaction.js"],"sourcesContent":["/**\r\n * Interaction manages all aspects of user interaction - mouse move,\r\n * click, hover, drag events, touch gestures.\r\n *\r\n * [[InteractionObject]] elements that want to use certain events, must attach event\r\n * listeners to Interaction instance.\r\n *\r\n * Interaction itself will not modify [[InteractionObject]] elements, it will be up to\r\n * those elements to handle interaction information received via event triggers.\r\n */\r\nimport { __extends } from \"tslib\";\r\n/**\r\n * ============================================================================\r\n * IMPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\r\nimport { BaseObjectEvents } from \"../Base\";\r\nimport { List } from \"../utils/List\";\r\nimport { Animation } from \"../utils/Animation\";\r\nimport { MultiDisposer } from \"../utils/Disposer\";\r\nimport { InteractionObject } from \"./InteractionObject\";\r\nimport { InteractionKeyboardObject } from \"./InteractionKeyboardObject\";\r\nimport { Dictionary } from \"../utils/Dictionary\";\r\nimport { Inertia } from \"./Inertia\";\r\nimport { addEventListener } from \"../utils/DOM\";\r\nimport { keyboard } from \"../utils/Keyboard\";\r\nimport { system } from \"./../System\";\r\nimport { options } from \"./../Options\";\r\nimport * as $ease from \"../utils/Ease\";\r\nimport * as $math from \"../utils/Math\";\r\nimport * as $array from \"../utils/Array\";\r\nimport * as $dom from \"../utils/DOM\";\r\nimport * as $iter from \"../utils/Iterator\";\r\nimport * as $type from \"../utils/Type\";\r\nimport * as $time from \"../utils/Time\";\r\n/**\r\n * ============================================================================\r\n * MAIN CLASS\r\n * ============================================================================\r\n * @hidden\r\n */\r\n/**\r\n* Interaction manages all aspects of user interaction - mouse move,\r\n* click, hover, drag events, touch gestures.\r\n*\r\n* [[InteractionObject]] elements that want to use certain events, must attach event\r\n* listeners to Interaction instance.\r\n*\r\n* Interaction itself will not modify [[InteractionObject]] elements, it will be up to\r\n* those elements to handle interaction information received via event triggers.\r\n*\r\n* @see {@link IInteractionEvents} for a list of available events\r\n*/\r\nvar Interaction = /** @class */ (function (_super) {\r\n    __extends(Interaction, _super);\r\n    /**\r\n     * Constructor. Sets up universal document-wide move events to handle stuff\r\n     * outside particular chart container.\r\n     */\r\n    function Interaction() {\r\n        var _this = \r\n        // Call super\r\n        _super.call(this) || this;\r\n        /**\r\n         * An indicator of global events were already initialized.\r\n         */\r\n        _this._globalEventsAdded = false;\r\n        /**\r\n         * Holds which mouse event listeners to use.\r\n         */\r\n        _this._pointerEvents = {\r\n            \"pointerdown\": \"mousedown\",\r\n            \"pointerup\": \"mouseup\",\r\n            \"pointermove\": \"mousemove\",\r\n            \"pointercancel\": \"mouseup\",\r\n            \"pointerover\": \"mouseover\",\r\n            \"pointerout\": \"mouseout\",\r\n            \"wheel\": \"wheel\"\r\n        };\r\n        /**\r\n         * Indicates if Interaction should use only \"pointer\" type events, like\r\n         * \"pointermove\", available in all modern browsers, ignoring \"legacy\"\r\n         * events, like \"touchmove\".\r\n         */\r\n        _this._usePointerEventsOnly = false;\r\n        /**\r\n         * Use only touch events (for touch only devices such as tablets and phones)\r\n         */\r\n        _this._useTouchEventsOnly = false;\r\n        /**\r\n         * Add special hover events. Normally, touch device tap will also simulate\r\n         * hover event. On some devices (ahem iOS) we want to prevent that so that\r\n         * over/out events are not duplicated.\r\n         */\r\n        _this._addHoverEvents = true;\r\n        /**\r\n         * Indicates if passive mode options is supported by this browser.\r\n         */\r\n        _this._passiveSupported = false;\r\n        /**\r\n         * Holds list of delayed events\r\n         */\r\n        _this._delayedEvents = { out: [] };\r\n        /**\r\n         * List of objects that current have a pointer hovered over them.\r\n         */\r\n        _this.overObjects = new List();\r\n        /**\r\n         * List of objects that currently has a pressed pointer.\r\n         */\r\n        _this.downObjects = new List();\r\n        /**\r\n         * List of objects that need mouse position to be reported to them.\r\n         */\r\n        _this.trackedObjects = new List();\r\n        /**\r\n         * List of objects that are currently being dragged.\r\n         */\r\n        _this.transformedObjects = new List();\r\n        /**\r\n         * Holds all known pointers.\r\n         */\r\n        _this.pointers = new Dictionary();\r\n        /**\r\n         * Inertia options that need to be applied to after element drag, if it's\r\n         * `inert = true`.\r\n         *\r\n         * This is just a default, which can and probably will be overridden by\r\n         * actual elements.\r\n         */\r\n        _this.inertiaOptions = new Dictionary();\r\n        /**\r\n         * Default options for click events. These can be overridden in\r\n         * [[InteractionObject]].\r\n         */\r\n        _this.hitOptions = {\r\n            \"doubleHitTime\": 300,\r\n            //\"delayFirstHit\": false,\r\n            \"hitTolerance\": 10,\r\n            \"noFocus\": true\r\n        };\r\n        /**\r\n         * Default options for hover events. These can be overridden in\r\n         * [[InteractionObject]].\r\n         */\r\n        _this.hoverOptions = {\r\n            \"touchOutBehavior\": \"leave\",\r\n            \"touchOutDelay\": 1000\r\n        };\r\n        /**\r\n         * Default options for detecting a swipe gesture. These can be overridden in\r\n         * [[InteractionObject]].\r\n         */\r\n        _this.swipeOptions = {\r\n            \"time\": 500,\r\n            \"verticalThreshold\": 75,\r\n            \"horizontalThreshold\": 30\r\n        };\r\n        /**\r\n         * Default options for keyboard operations. These can be overridden in\r\n         * [[InteractionObject]].\r\n         */\r\n        _this.keyboardOptions = {\r\n            \"speed\": 0.1,\r\n            \"accelleration\": 1.2,\r\n            \"accellerationDelay\": 2000\r\n        };\r\n        /**\r\n         * Default options for keyboard operations. These can be overridden in\r\n         * [[InteractionObject]].\r\n         *\r\n         * @since 4.5.14\r\n         */\r\n        _this.mouseOptions = {\r\n            \"sensitivity\": 1\r\n        };\r\n        // Set class name\r\n        _this.className = \"Interaction\";\r\n        // Create InteractionObject for <body>\r\n        _this.body = _this.getInteraction(document.body);\r\n        _this._disposers.push(_this.body);\r\n        // Detect browser capabilities and determine what event listeners to use\r\n        if (window.hasOwnProperty(\"PointerEvent\")) {\r\n            // IE10+/Edge without touch controls enabled\r\n            _this._pointerEvents.pointerdown = \"pointerdown\";\r\n            _this._pointerEvents.pointerup = \"pointerup\";\r\n            _this._pointerEvents.pointermove = \"pointermove\";\r\n            _this._pointerEvents.pointercancel = \"pointercancel\";\r\n            _this._pointerEvents.pointerover = \"pointerover\";\r\n            _this._pointerEvents.pointerout = \"pointerout\";\r\n            //this._usePointerEventsOnly = true;\r\n        }\r\n        else if (window.hasOwnProperty(\"MSPointerEvent\")) {\r\n            // IE9\r\n            _this._pointerEvents.pointerdown = \"MSPointerDown\";\r\n            _this._pointerEvents.pointerup = \"MSPointerUp\";\r\n            _this._pointerEvents.pointermove = \"MSPointerMove\";\r\n            _this._pointerEvents.pointercancel = \"MSPointerUp\";\r\n            _this._pointerEvents.pointerover = \"MSPointerOver\";\r\n            _this._pointerEvents.pointerout = \"MSPointerOut\";\r\n            //this._usePointerEventsOnly = true;\r\n        }\r\n        else if ((typeof matchMedia !== \"undefined\") && matchMedia('(pointer:fine)').matches) {\r\n            // This is only for Safari as it does not support PointerEvent\r\n            // Do nothing and let it use regular `mouse*` events\r\n            // Hi Apple ;)\r\n            // Additionally disable hover events for iOS devices\r\n            if ('ontouchstart' in window) {\r\n                _this._addHoverEvents = false;\r\n                _this._useTouchEventsOnly = true;\r\n            }\r\n        }\r\n        else if (window.navigator.userAgent.match(/MSIE /)) {\r\n            // Oh looky, an MSIE that does not support PointerEvent. Hi granpa IE9!\r\n            _this._usePointerEventsOnly = true;\r\n        }\r\n        else if (_this.fullFF()) {\r\n            // Old FF, let's use regular events.\r\n            // (Newer FFs would be detected by the PointerEvent availability check)\r\n            _this._usePointerEventsOnly = true;\r\n        }\r\n        else {\r\n            // Uses defaults for normal browsers\r\n            // We also assume that this must be a touch device that does not have\r\n            // any pointer events\r\n            _this._useTouchEventsOnly = true;\r\n        }\r\n        // Detect if device has a mouse\r\n        // This is turning out to be not reliable\r\n        // @todo remove\r\n        /*if (!window.navigator.msPointerEnabled && (typeof matchMedia !== \"undefined\") && !matchMedia('(pointer:fine)').matches && !this.fullFF()) {\r\n            this._useTouchEventsOnly = true;\r\n        }*/\r\n        // Detect proper mouse wheel events\r\n        if (\"onwheel\" in document.createElement(\"div\")) {\r\n            // Modern browsers\r\n            _this._pointerEvents.wheel = \"wheel\";\r\n        }\r\n        else if ($type.hasValue(document.onmousewheel)) {\r\n            // Webkit and IE support at least \"mousewheel\"\r\n            _this._pointerEvents.wheel = \"mousewheel\";\r\n        }\r\n        // Set up default inertia options\r\n        _this.inertiaOptions.setKey(\"move\", {\r\n            \"time\": 100,\r\n            \"duration\": 500,\r\n            \"factor\": 1,\r\n            \"easing\": $ease.polyOut3\r\n        });\r\n        _this.inertiaOptions.setKey(\"resize\", {\r\n            \"time\": 100,\r\n            \"duration\": 500,\r\n            \"factor\": 1,\r\n            \"easing\": $ease.polyOut3\r\n        });\r\n        // Set the passive mode support\r\n        _this._passiveSupported = Interaction.passiveSupported;\r\n        // Apply theme\r\n        _this.applyTheme();\r\n        return _this;\r\n    }\r\n    /**\r\n     * This is a nasty detection for Firefox. The reason why we have is that\r\n     * Firefox ESR version does not support matchMedia correctly.\r\n     *\r\n     * On iOS, Firefox uses different userAgent, so we don't have to detect iOS.\r\n     *\r\n     * @return Full Firefox?\r\n     */\r\n    Interaction.prototype.fullFF = function () {\r\n        return (window.navigator.userAgent.match(/Firefox/)) && !(window.navigator.userAgent.match(/Android/));\r\n    };\r\n    Interaction.prototype.debug = function () { };\r\n    /**\r\n     * ==========================================================================\r\n     * Processing\r\n     * ==========================================================================\r\n     * @hidden\r\n     */\r\n    /**\r\n     * Sets up global events.\r\n     *\r\n     * We need this so that we can track drag movement beyond chart's container.\r\n     *\r\n     * @ignore Exclude from docs\r\n     */\r\n    Interaction.prototype.addGlobalEvents = function () {\r\n        var _this = this;\r\n        if (!this._globalEventsAdded) {\r\n            if (!this._useTouchEventsOnly) {\r\n                this._disposers.push(addEventListener(document, this._pointerEvents.pointerdown, function (ev) { _this.handleGlobalPointerDown(ev); }));\r\n                this._disposers.push(addEventListener(document, this._pointerEvents.pointermove, function (ev) { _this.handleGlobalPointerMove(ev); }));\r\n                this._disposers.push(addEventListener(document, this._pointerEvents.pointerup, function (ev) { _this.handleGlobalPointerUp(ev); }));\r\n                this._disposers.push(addEventListener(document, this._pointerEvents.pointercancel, function (ev) { _this.handleGlobalPointerUp(ev, true); }));\r\n                this._disposers.push(addEventListener(document, \"mouseenter\", function (ev) {\r\n                    if (!$type.hasValue(ev.relatedTarget) && (ev.buttons == 0 || ev.which == 0)) {\r\n                        _this.handleDocumentLeave(ev);\r\n                    }\r\n                }));\r\n            }\r\n            // No need to duplicate events for hubrid systems that support both\r\n            // pointer events and touch events. Touch events are need only for\r\n            // some touch-only systems, like Mobile Safari.\r\n            if (!this._usePointerEventsOnly) {\r\n                this._disposers.push(addEventListener(document, \"touchstart\", function (ev) { _this.handleGlobalTouchStart(ev); }));\r\n                this._disposers.push(addEventListener(document, \"touchmove\", function (ev) { _this.handleGlobalTouchMove(ev); }));\r\n                this._disposers.push(addEventListener(document, \"touchend\", function (ev) { _this.handleGlobalTouchEnd(ev); }));\r\n            }\r\n            this._disposers.push(addEventListener(document, \"keydown\", function (ev) { _this.handleGlobalKeyDown(ev); }));\r\n            this._disposers.push(addEventListener(document, \"keyup\", function (ev) { _this.handleGlobalKeyUp(ev); }));\r\n            this._globalEventsAdded = true;\r\n        }\r\n    };\r\n    /**\r\n     * Sets if [[InteractionObject]] is clickable.\r\n     *\r\n     * @ignore Exclude from docs\r\n     * @param io [[InteractionObject]] instance\r\n     */\r\n    Interaction.prototype.processClickable = function (io) {\r\n        // Add or remove touch events\r\n        this.processTouchable(io);\r\n    };\r\n    /**\r\n     * Sets if [[InteractionObject]] will display context menu when right-clicked.\r\n     *\r\n     * @ignore Exclude from docs\r\n     * @param io [[InteractionObject]] instance\r\n     */\r\n    Interaction.prototype.processContextMenu = function (io) {\r\n        if (io.contextMenuDisabled) {\r\n            if (!io.eventDisposers.hasKey(\"contextMenuDisabled\")) {\r\n                io.eventDisposers.setKey(\"contextMenuDisabled\", addEventListener(io.element, \"contextmenu\", function (e) {\r\n                    e.preventDefault();\r\n                }));\r\n            }\r\n        }\r\n        else {\r\n            if (io.eventDisposers.hasKey(\"contextMenuDisabled\")) {\r\n                io.eventDisposers.getKey(\"contextMenuDisabled\").dispose();\r\n            }\r\n        }\r\n    };\r\n    /**\r\n     * Sets if [[InteractionObject]] is hoverable.\r\n     *\r\n     * @ignore Exclude from docs\r\n     * @param io [[InteractionObject]] instance\r\n     */\r\n    Interaction.prototype.processHoverable = function (io) {\r\n        var _this = this;\r\n        if (io.hoverable || io.trackable) {\r\n            // Add global events\r\n            this.addGlobalEvents();\r\n            // Add hover styles\r\n            this.applyCursorOverStyle(io);\r\n            // Add local events\r\n            if (!io.eventDisposers.hasKey(\"hoverable\") && this._addHoverEvents) {\r\n                io.eventDisposers.setKey(\"hoverable\", new MultiDisposer([\r\n                    addEventListener(io.element, this._pointerEvents.pointerout, function (e) { return _this.handlePointerOut(io, e); }),\r\n                    addEventListener(io.element, this._pointerEvents.pointerover, function (e) { return _this.handlePointerOver(io, e); })\r\n                ]));\r\n            }\r\n            if (io.trackable) {\r\n                //sprite.addEventListener(\"touchmove\", this.handleTouchMove, false, this);\r\n            }\r\n        }\r\n        else {\r\n            var disposer = io.eventDisposers.getKey(\"hoverable\");\r\n            if (disposer != null) {\r\n                disposer.dispose();\r\n                io.eventDisposers.removeKey(\"hoverable\");\r\n            }\r\n        }\r\n        // Add or remove touch events\r\n        this.processTouchable(io);\r\n    };\r\n    /**\r\n     * Sets up [[InteractionObject]] as movable. Movable can be any\r\n     * transformation, e.g. drag, swipe, resize, track.\r\n     *\r\n     * @ignore Exclude from docs\r\n     * @param io  Element\r\n     */\r\n    Interaction.prototype.processMovable = function (io) {\r\n        // Add unified events\r\n        if (io.draggable || io.swipeable || io.trackable || io.resizable) {\r\n            // Prep the element\r\n            if (!this.isGlobalElement(io) && !io.isTouchProtected) {\r\n                this.prepElement(io);\r\n            }\r\n            // Add hover styles\r\n            this.applyCursorOverStyle(io);\r\n        }\r\n        // Add or remove touch events\r\n        this.processTouchable(io);\r\n    };\r\n    /**\r\n     * Checks if [[InteractionObject]] is trackable and sets relative events.\r\n     *\r\n     * @ignore Exclude from docs\r\n     * @param io  Element\r\n     */\r\n    Interaction.prototype.processTrackable = function (io) {\r\n        this.processHoverable(io);\r\n        this.processMovable(io);\r\n        if (io.trackable) {\r\n            this.trackedObjects.moveValue(io);\r\n        }\r\n        else {\r\n            this.trackedObjects.removeValue(io);\r\n        }\r\n    };\r\n    /**\r\n     * Checks if [[InteractionObject]] is draggable.\r\n     *\r\n     * @ignore Exclude from docs\r\n     * @param io  Element\r\n     */\r\n    Interaction.prototype.processDraggable = function (io) {\r\n        this.processMovable(io);\r\n    };\r\n    /**\r\n     * Checks if [[InteractionObject]] is swipeable and sets relative events.\r\n     *\r\n     * A swipe event is triggered when a horizontal drag of 75px or more (and\r\n     * less than 30px vertically) occurs within 700 milliseconds. This can be\r\n     * overridden in sprites [[swipeOptions]].\r\n     *\r\n     * @ignore Exclude from docs\r\n     * @param io  Element\r\n     */\r\n    Interaction.prototype.processSwipeable = function (io) {\r\n        this.processMovable(io);\r\n    };\r\n    /**\r\n     * Checks if [[InteractionObject]] is resizable and attaches required events\r\n     * to it.\r\n     *\r\n     * @ignore Exclude from docs\r\n     * @param io  Element\r\n     */\r\n    Interaction.prototype.processResizable = function (io) {\r\n        this.processMovable(io);\r\n    };\r\n    /**\r\n     * Checks if [[InteractionObject]] is supposed to capture mouse wheel events\r\n     * and prepares it to catch those events.\r\n     *\r\n     * @ignore Exclude from docs\r\n     * @param io  Element\r\n     */\r\n    Interaction.prototype.processWheelable = function (io) {\r\n        var _this = this;\r\n        if (io.wheelable) {\r\n            //io.hoverable = true;\r\n            if (!io.eventDisposers.hasKey(\"wheelable\")) {\r\n                io.eventDisposers.setKey(\"wheelable\", new MultiDisposer([\r\n                    addEventListener(io.element, this._pointerEvents.wheel, function (e) { return _this.handleMouseWheel(io, e); }, this._passiveSupported ? { passive: false } : false),\r\n                    io.events.on(\"out\", function (e) {\r\n                        if (io.wheelable) {\r\n                            _this.unlockWheel();\r\n                        }\r\n                    }),\r\n                    io.events.on(\"over\", function (e) {\r\n                        //console.log(\"whelab over\")\r\n                        if (io.wheelable) {\r\n                            _this.lockWheel();\r\n                        }\r\n                    })\r\n                ]));\r\n            }\r\n        }\r\n        else {\r\n            var disposer = io.eventDisposers.getKey(\"wheelable\");\r\n            if (disposer != null) {\r\n                disposer.dispose();\r\n                io.eventDisposers.removeKey(\"wheelable\");\r\n            }\r\n        }\r\n    };\r\n    /**\r\n     * Checks if [[InteractionObject]] is focusable. A focusable element is an\r\n     * element that will be highlighted when users presses TAB key. If the\r\n     * element is focusable, this function will attach relative focus/blur\r\n     * events to it.\r\n     *\r\n     * @ignore Exclude from docs\r\n     * @param io  Element\r\n     */\r\n    Interaction.prototype.processFocusable = function (io) {\r\n        var _this = this;\r\n        if (io.focusable === true && (io.tabindex > -1) && !this._useTouchEventsOnly) {\r\n            if (!io.eventDisposers.hasKey(\"focusable\")) {\r\n                io.eventDisposers.setKey(\"focusable\", new MultiDisposer([\r\n                    addEventListener(io.element, \"focus\", function (e) { return _this.handleFocus(io, e); }),\r\n                    addEventListener(io.element, \"blur\", function (e) { return _this.handleBlur(io, e); }),\r\n                    addEventListener(io.element, this._pointerEvents.pointerdown, function (e) { return _this.handleFocusBlur(io, e); }),\r\n                    addEventListener(io.element, \"touchstart\", function (e) { return _this.handleFocusBlur(io, e); }, this._passiveSupported ? { passive: false } : false)\r\n                ]));\r\n            }\r\n        }\r\n        else {\r\n            var disposer = io.eventDisposers.getKey(\"focusable\");\r\n            if (disposer != null) {\r\n                disposer.dispose();\r\n                io.eventDisposers.removeKey(\"focusable\");\r\n            }\r\n        }\r\n    };\r\n    /**\r\n     * Checks if [[InteractionObject]] is \"touchable\". It means any interaction\r\n     * whatsoever: mouse click, touch screen tap, swipe, drag, resize, etc.\r\n     *\r\n     * @ignore Exclude from docs\r\n     * @param io  Element\r\n     */\r\n    Interaction.prototype.processTouchable = function (io) {\r\n        var _this = this;\r\n        // Add unified events\r\n        if (io.clickable || io.hoverable || io.trackable || io.draggable || io.swipeable || io.resizable) {\r\n            // Add global events\r\n            this.addGlobalEvents();\r\n            // Add local events\r\n            if (!io.eventDisposers.hasKey(\"touchable\")) {\r\n                if (!this._useTouchEventsOnly && !this._usePointerEventsOnly) {\r\n                    io.eventDisposers.setKey(\"touchable\", new MultiDisposer([\r\n                        addEventListener(io.element, this._pointerEvents.pointerdown, function (e) { return _this.handlePointerDown(io, e); }),\r\n                        addEventListener(io.element, \"touchstart\", function (e) { return _this.handleTouchDown(io, e); }, this._passiveSupported ? { passive: false } : false)\r\n                    ]));\r\n                }\r\n                else if (!this._useTouchEventsOnly) {\r\n                    io.eventDisposers.setKey(\"touchable\", addEventListener(io.element, this._pointerEvents.pointerdown, function (e) { return _this.handlePointerDown(io, e); }));\r\n                }\r\n                else if (!this._usePointerEventsOnly) {\r\n                    io.eventDisposers.setKey(\"touchable\", addEventListener(io.element, \"touchstart\", function (e) { return _this.handleTouchDown(io, e); }, this._passiveSupported ? { passive: false } : false));\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            var disposer = io.eventDisposers.getKey(\"touchable\");\r\n            if (disposer != null) {\r\n                disposer.dispose();\r\n                io.eventDisposers.removeKey(\"touchable\");\r\n            }\r\n        }\r\n    };\r\n    /**\r\n     * ==========================================================================\r\n     * Non-pointer events\r\n     * ==========================================================================\r\n     * @hidden\r\n     */\r\n    /**\r\n     * Dispatches \"focus\" event when element gains focus.\r\n     *\r\n     * @ignore Exclude from docs\r\n     * @param io  Element\r\n     * @param ev  Original event\r\n     */\r\n    Interaction.prototype.handleFocus = function (io, ev) {\r\n        if (!io.focusable) {\r\n            ev.preventDefault();\r\n            return;\r\n        }\r\n        io.isFocused = true;\r\n        if (io.events.isEnabled(\"focus\") && !system.isPaused) {\r\n            var imev = {\r\n                type: \"focus\",\r\n                target: io,\r\n                event: ev\r\n            };\r\n            io.events.dispatchImmediately(\"focus\", imev);\r\n        }\r\n    };\r\n    /**\r\n     * Used by regular click events to prevent focus if \"noFocus\" is set.\r\n     *\r\n     * This should not be called by \"focus\" handlers.\r\n     *\r\n     * @param io  Element\r\n     * @param ev  Original event\r\n     */\r\n    Interaction.prototype.handleFocusBlur = function (io, ev) {\r\n        if (io.focusable !== false && this.getHitOption(io, \"noFocus\")) {\r\n            io.events.once(\"focus\", function () {\r\n                io.events.disableType(\"blur\");\r\n                $dom.blur();\r\n                if (io.sprite) {\r\n                    io.sprite.handleBlur();\r\n                }\r\n                io.events.enableType(\"blur\");\r\n            });\r\n        }\r\n    };\r\n    /**\r\n     * Dispatches \"blur\" event when element loses focus.\r\n     *\r\n     * @ignore Exclude from docs\r\n     * @param io  Element\r\n     * @param ev  Original event\r\n     */\r\n    Interaction.prototype.handleBlur = function (io, ev) {\r\n        if (!io.focusable) {\r\n            ev.preventDefault();\r\n            return;\r\n        }\r\n        io.isFocused = false;\r\n        if (io.events.isEnabled(\"blur\") && !system.isPaused) {\r\n            var imev = {\r\n                type: \"blur\",\r\n                target: io,\r\n                event: ev\r\n            };\r\n            io.events.dispatchImmediately(\"blur\", imev);\r\n        }\r\n    };\r\n    /**\r\n     * ==========================================================================\r\n     * Global keyboard-related even handlers\r\n     * ==========================================================================\r\n     * @hidden\r\n     */\r\n    /**\r\n     * Checks if there is an item that has currently focus and that they key is\r\n     * one of the directional keys. If both of the conditions are true, it\r\n     * creates an object to simulate movement of dragable element with keyboard.\r\n     *\r\n     * @ignore Exclude from docs\r\n     * @param ev An original keyboard event\r\n     */\r\n    Interaction.prototype.handleGlobalKeyDown = function (ev) {\r\n        if (this.focusedObject) {\r\n            if (keyboard.isKey(ev, \"esc\")) {\r\n                // ESC removes focus\r\n                $dom.blur();\r\n            }\r\n            else if (this.focusedObject.draggable && keyboard.isKey(ev, [\"up\", \"down\", \"left\", \"right\"])) {\r\n                // Prevent scrolling of the document\r\n                ev.preventDefault();\r\n                // Get focused object\r\n                var io = this.focusedObject;\r\n                // Get particular key\r\n                var disposerKey = \"interactionKeyboardObject\";\r\n                // If such disposer already exists we know the event is going on so we\r\n                // just move on\r\n                if (io.eventDisposers.hasKey(disposerKey)) {\r\n                    return;\r\n                }\r\n                // Create a keyboard mover\r\n                var ko = new InteractionKeyboardObject(io, ev);\r\n                io.eventDisposers.setKey(disposerKey, ko);\r\n                switch (keyboard.getEventKey(ev)) {\r\n                    case \"up\":\r\n                        ko.directionY = -1;\r\n                        break;\r\n                    case \"down\":\r\n                        ko.directionY = 1;\r\n                        break;\r\n                    case \"left\":\r\n                        ko.directionX = -1;\r\n                        break;\r\n                    case \"right\":\r\n                        ko.directionX = 1;\r\n                        break;\r\n                }\r\n            }\r\n        }\r\n    };\r\n    /**\r\n     * Dispatches related events when the keyboard key is realeasd.\r\n     *\r\n     * @ignore Exclude from docs\r\n     * @param ev An original keyboard event\r\n     */\r\n    Interaction.prototype.handleGlobalKeyUp = function (ev) {\r\n        var disposerKey = \"interactionKeyboardObject\";\r\n        if (this.focusedObject) {\r\n            var disposer = this.focusedObject.eventDisposers.getKey(disposerKey);\r\n            if (disposer != null) {\r\n                // Prevent scrolling of the document\r\n                ev.preventDefault();\r\n                // Dispose stuff\r\n                disposer.dispose();\r\n                this.focusedObject.eventDisposers.removeKey(disposerKey);\r\n            }\r\n            // Does focused object have \"hit\" event?\r\n            var sprite = this.focusedObject.sprite;\r\n            if (keyboard.isKey(ev, \"enter\") && sprite) {\r\n                if (sprite.events.isEnabled(\"hit\") || sprite.events.isEnabled(\"toggled\")) {\r\n                    this.focusedObject.dispatchImmediately(\"hit\");\r\n                }\r\n                else if (sprite.showTooltipOn == \"hit\") {\r\n                    this.focusedObject.dispatchImmediately(\"up\");\r\n                }\r\n            }\r\n        }\r\n    };\r\n    /**\r\n     * ==========================================================================\r\n     * Global pointer-related even handlers\r\n     * ==========================================================================\r\n     * @hidden\r\n     */\r\n    /**\r\n     * Handler for a global \"pointermove\" event.\r\n     *\r\n     * @ignore Exclude from docs\r\n     * @param ev Event object\r\n     */\r\n    Interaction.prototype.handleGlobalPointerMove = function (ev) {\r\n        // Get pointer\r\n        var pointer = this.getPointer(ev);\r\n        // Update current point position\r\n        pointer.point = this.getPointerPoint(ev);\r\n        // Prepare and fire global event\r\n        if (this.events.isEnabled(\"track\") && !system.isPaused) {\r\n            var imev = {\r\n                type: \"track\",\r\n                target: this,\r\n                event: ev,\r\n                pointer: pointer,\r\n                touch: pointer.touch\r\n            };\r\n            this.events.dispatchImmediately(\"track\", imev);\r\n        }\r\n        // Track\r\n        this.addBreadCrumb(pointer, pointer.point);\r\n        // Process further\r\n        this.handleGlobalMove(pointer, ev);\r\n    };\r\n    /**\r\n     * Handler for a global \"pointerdown\" event.\r\n     *\r\n     * @ignore Exclude from docs\r\n     * @param ev Event object\r\n     */\r\n    Interaction.prototype.handleGlobalPointerDown = function (ev) {\r\n        // Remove delayed hovers\r\n        this.processDelayed();\r\n        // Get pointer\r\n        var pointer = this.getPointer(ev);\r\n        // Prepare and fire global event\r\n        if (this.events.isEnabled(\"down\") && !system.isPaused) {\r\n            var imev = {\r\n                type: \"down\",\r\n                target: this,\r\n                event: ev,\r\n                pointer: pointer,\r\n                touch: pointer.touch\r\n            };\r\n            this.events.dispatchImmediately(\"down\", imev);\r\n        }\r\n    };\r\n    /**\r\n     * Prevents touch action from firing.\r\n     *\r\n     * @ignore Exclude from docs\r\n     * @param ev Event\r\n     */\r\n    Interaction.prototype.preventTouchAction = function (ev) {\r\n        if (!ev.defaultPrevented) {\r\n            ev.preventDefault();\r\n        }\r\n    };\r\n    /**\r\n     * Handler for a global \"pointerup\" event.\r\n     *\r\n     * @ignore Exclude from docs\r\n     * @param ev Event object\r\n     */\r\n    Interaction.prototype.handleGlobalPointerUp = function (ev, cancelled) {\r\n        if (cancelled === void 0) { cancelled = false; }\r\n        // Get pointer\r\n        var pointer = this.getPointer(ev);\r\n        // Prepare and fire global event\r\n        if (this.events.isEnabled(\"up\") && !system.isPaused) {\r\n            var imev = {\r\n                type: \"up\",\r\n                target: this,\r\n                event: ev,\r\n                pointer: pointer,\r\n                touch: pointer.touch\r\n            };\r\n            this.events.dispatchImmediately(\"up\", imev);\r\n        }\r\n        // Process further\r\n        this.handleGlobalUp(pointer, ev, cancelled);\r\n    };\r\n    /**\r\n * ==========================================================================\r\n * Global touch-related even handlers\r\n * ==========================================================================\r\n */\r\n    /**\r\n     * Handler for a global \"touchmove\" event.\r\n     *\r\n     * @ignore Exclude from docs\r\n     * @param ev Event object\r\n     */\r\n    Interaction.prototype.handleGlobalTouchMove = function (ev) {\r\n        // Process each changed touch point\r\n        for (var i = 0; i < ev.changedTouches.length; i++) {\r\n            // Get pointer\r\n            var pointer = this.getPointer(ev.changedTouches[i]);\r\n            // Update current point position\r\n            pointer.point = this.getPointerPoint(ev.changedTouches[i]);\r\n            // Prepare and fire global event\r\n            if (this.events.isEnabled(\"track\") && !system.isPaused) {\r\n                var imev = {\r\n                    type: \"track\",\r\n                    target: this,\r\n                    event: ev,\r\n                    pointer: pointer,\r\n                    touch: pointer.touch\r\n                };\r\n                this.events.dispatchImmediately(\"track\", imev);\r\n            }\r\n            // Track\r\n            this.addBreadCrumb(pointer, pointer.point);\r\n            // Process further\r\n            this.handleGlobalMove(pointer, ev);\r\n        }\r\n    };\r\n    /**\r\n     * Handler for a global \"touchstart\" event.\r\n     *\r\n     * @ignore Exclude from docs\r\n     * @param ev Event object\r\n     */\r\n    Interaction.prototype.handleGlobalTouchStart = function (ev) {\r\n        // Remove delayed hovers\r\n        this.processDelayed();\r\n        // Process each changed touch point\r\n        for (var i = 0; i < ev.changedTouches.length; i++) {\r\n            // Get pointer\r\n            var pointer = this.getPointer(ev.changedTouches[i]);\r\n            // Prepare and fire global event\r\n            if (!this._usePointerEventsOnly && this.events.isEnabled(\"down\") && !system.isPaused) {\r\n                var imev = {\r\n                    type: \"down\",\r\n                    target: this,\r\n                    event: ev,\r\n                    pointer: pointer,\r\n                    touch: pointer.touch\r\n                };\r\n                this.events.dispatchImmediately(\"down\", imev);\r\n            }\r\n        }\r\n    };\r\n    /**\r\n     * Handler for a global \"touchend\" event.\r\n     *\r\n     * @ignore Exclude from docs\r\n     * @param ev Event object\r\n     */\r\n    Interaction.prototype.handleGlobalTouchEnd = function (ev) {\r\n        // Process each changed touch point\r\n        for (var i = 0; i < ev.changedTouches.length; i++) {\r\n            // Get pointer\r\n            var pointer = this.getPointer(ev.changedTouches[i]);\r\n            // Prepare and fire global event\r\n            if (this.events.isEnabled(\"up\") && !system.isPaused) {\r\n                var imev = {\r\n                    type: \"up\",\r\n                    target: this,\r\n                    event: ev,\r\n                    pointer: pointer,\r\n                    touch: pointer.touch\r\n                };\r\n                this.events.dispatchImmediately(\"up\", imev);\r\n            }\r\n            // Handle element-related events\r\n            this.handleGlobalUp(pointer, ev);\r\n        }\r\n    };\r\n    /**\r\n     * ==========================================================================\r\n     * Element-specific pointer-related even handlers\r\n     * ==========================================================================\r\n     * @hidden\r\n     */\r\n    /**\r\n     * Handles event when pointer is over [[InteractionObject]] and button is\r\n     * pressed.\r\n     *\r\n     * @ignore Exclude from docs\r\n     * @param io  Element\r\n     * @param ev  Original event\r\n     */\r\n    Interaction.prototype.handlePointerDown = function (io, ev) {\r\n        // Stop further propagation so we don't get multiple triggers on hybrid\r\n        // devices (both mouse and touch capabilities)\r\n        //ev.preventDefault();\r\n        //ev.stopPropagation();\r\n        //if (ev.defaultPrevented) {\r\n        //}\r\n        // Get pointer\r\n        var pointer = this.getPointer(ev);\r\n        // Ignore if it's anything but mouse's primary button\r\n        if (!pointer.touch && ev.which != 1 && ev.which != 3) {\r\n            return;\r\n        }\r\n        // Set mouse button\r\n        pointer.button = ev.which;\r\n        // Reset pointer\r\n        this.resetPointer(pointer, ev);\r\n        // Process down\r\n        this.handleDown(io, pointer, ev);\r\n    };\r\n    /**\r\n     * Handles event when [[InteractionObject]] is hovered by a mouse pointer.\r\n     *\r\n     * @ignore Exclude from docs\r\n     * @param io  Element\r\n     * @param ev  Original event\r\n     */\r\n    Interaction.prototype.handlePointerOver = function (io, ev) {\r\n        // Get pointer\r\n        var pointer = this.getPointer(ev);\r\n        // Process down\r\n        this.handleOver(io, pointer, ev);\r\n    };\r\n    /**\r\n     * Handles event when [[InteractionObject]] loses hover from a mouse pointer.\r\n     *\r\n     * @ignore Exclude from docs\r\n     * @param io  Element\r\n     * @param ev  Original event\r\n     */\r\n    Interaction.prototype.handlePointerOut = function (io, ev) {\r\n        // Get pointer\r\n        var pointer = this.getPointer(ev);\r\n        // Process down\r\n        this.handleOut(io, pointer, ev);\r\n    };\r\n    /**\r\n     * Handles event when mouse wheel is crolled over the [[InteractionObject]].\r\n     *\r\n     * @ignore Exclude from docs\r\n     * @param io  Element\r\n     * @param ev  Original event\r\n     * @todo Investigate more-cross browser stuff https://developer.mozilla.org/en-US/docs/Web/Events/wheel\r\n     */\r\n    Interaction.prototype.handleMouseWheel = function (io, ev) {\r\n        // Get pointer\r\n        var pointer = this.getPointer(ev);\r\n        // Update current point position\r\n        pointer.point = this.getPointerPoint(ev);\r\n        // Init delta values\r\n        var deltaX = 0, deltaY = 0;\r\n        // Set up modifier\r\n        // This is needed because FireFox reports wheel deltas in \"lines\" instead\r\n        // of pixels so we have to approximate pixel value\r\n        var mod = 1;\r\n        if (ev.deltaMode == 1) {\r\n            mod = 50;\r\n        }\r\n        // Adjust configurable sensitivity\r\n        mod *= this.getMouseOption(io, \"sensitivity\");\r\n        // Calculate deltas\r\n        if (ev instanceof WheelEvent) {\r\n            deltaX = Math.round((-1 * ev.wheelDeltaX) || (ev.deltaX * mod));\r\n            deltaY = Math.round((-1 * ev.wheelDeltaY) || (ev.deltaY * mod));\r\n        }\r\n        else {\r\n            throw new Error(\"Invalid event type\");\r\n        }\r\n        // Handle the event\r\n        this.handleWheel(io, pointer, deltaX, deltaY, ev);\r\n    };\r\n    /**\r\n     * ==========================================================================\r\n     * Element-specific touch-related even handlers\r\n     * ==========================================================================\r\n     * @hidden\r\n     */\r\n    /**\r\n      * Handles an event when an [[InteractionObject]] is touched on a touch\r\n      * device.\r\n      *\r\n      * @ignore Exclude from docs\r\n      * @param io  Element\r\n      * @param ev  Original event\r\n      */\r\n    Interaction.prototype.handleTouchDown = function (io, ev) {\r\n        // Stop further propagation so we don't get multiple triggers on hybrid\r\n        // devices (both mouse and touch capabilities)\r\n        //this.maybePreventDefault(io, ev);\r\n        //return;\r\n        // Process each changed touch point\r\n        for (var i = 0; i < ev.changedTouches.length; i++) {\r\n            // Get pointer\r\n            var pointer = this.getPointer(ev.changedTouches[i]);\r\n            this.maybePreventDefault(io, ev, pointer);\r\n            // Reset pointer\r\n            this.resetPointer(pointer, ev.changedTouches[i]);\r\n            // Process down\r\n            this.handleDown(io, pointer, ev);\r\n        }\r\n    };\r\n    /**\r\n     * ==========================================================================\r\n     * Universal handlers\r\n     * ==========================================================================\r\n     * @hidden\r\n     */\r\n    /**\r\n     * Handles click/tap. Checks for doublehit.\r\n     *\r\n     * @ignore Exclude from docs\r\n     * @param io       Interaction object\r\n     * @param pointer  Pointer\r\n     * @param ev       Original event\r\n     */\r\n    Interaction.prototype.handleHit = function (io, pointer, ev) {\r\n        // Check if this is a double-hit\r\n        var now = $time.getTime();\r\n        if (io.lastHit && (io.lastHit >= (now - this.getHitOption(io, \"doubleHitTime\")))) {\r\n            // Yup - it's a double-hit\r\n            // Cancel the hit\r\n            //clearTimeout(io.lastHitPointer.hitTimeout);\r\n            // If it happened too fast it probably means that hybrid device just\r\n            // generated two events for the same tap\r\n            if ((now - io.lastHit) < 100) {\r\n                // Ignore\r\n                return;\r\n            }\r\n            // Clear last hit\r\n            io.lastHit = undefined;\r\n            io.lastHitPointer = undefined;\r\n            // Dispatch event\r\n            if (io.events.isEnabled(\"doublehit\") && !system.isPaused) {\r\n                var imev = {\r\n                    type: \"doublehit\",\r\n                    target: io,\r\n                    point: pointer.point,\r\n                    event: ev,\r\n                    touch: pointer.touch\r\n                };\r\n                io.events.dispatchImmediately(\"doublehit\", imev);\r\n            }\r\n        }\r\n        else {\r\n            // Log last hit\r\n            io.lastHit = now;\r\n            io.lastHitPointer = pointer;\r\n            if (pointer.button === 3) {\r\n                // Execute HIT now\r\n                if (io.events.isEnabled(\"rightclick\") && !system.isPaused) {\r\n                    var imev = {\r\n                        type: \"rightclick\",\r\n                        target: io,\r\n                        event: ev\r\n                    };\r\n                    io.events.dispatchImmediately(\"rightclick\", imev);\r\n                }\r\n            }\r\n            else {\r\n                if (io.events.isEnabled(\"hit\") && !system.isPaused) {\r\n                    var imev = {\r\n                        type: \"hit\",\r\n                        target: io,\r\n                        event: ev,\r\n                        point: pointer.point,\r\n                        touch: pointer.touch\r\n                    };\r\n                    io.events.dispatchImmediately(\"hit\", imev);\r\n                }\r\n            }\r\n        }\r\n    };\r\n    /**\r\n     * Handles pointer hovering over [[InteractionObject]].\r\n     *\r\n     * @ignore Exclude from docs\r\n     * @param io       Interaction object\r\n     * @param pointer  Pointer\r\n     * @param ev       Original event\r\n     * @param soft     Invoked by helper function\r\n     */\r\n    Interaction.prototype.handleOver = function (io, pointer, ev, soft) {\r\n        if (soft === void 0) { soft = false; }\r\n        if (!io.hoverable) {\r\n            return;\r\n        }\r\n        var hoversPaused = false;\r\n        if (this.shouldCancelHovers(pointer) && this.areTransformed() && this.moved(pointer, this.getHitOption(io, \"hitTolerance\"))) {\r\n            hoversPaused = true;\r\n            this.cancelAllHovers(ev);\r\n        }\r\n        // Remove any delayed outs\r\n        this.processDelayed();\r\n        // Add pointer\r\n        io.overPointers.moveValue(pointer);\r\n        // Check if object is not yet hovered\r\n        if (!io.isRealHover) {\r\n            // Set element as hovered\r\n            if (!hoversPaused) {\r\n                io.isHover = true;\r\n                io.isRealHover = true;\r\n                this.overObjects.moveValue(io);\r\n            }\r\n            // Generate body track event. This is needed so that if element loads\r\n            // under unmoved mouse cursor, we still need all the actions that are\r\n            // required to happen to kick in.\r\n            this.handleTrack(this.body, pointer, ev, true);\r\n            // Event\r\n            if (io.events.isEnabled(\"over\") && !system.isPaused && !hoversPaused) {\r\n                var imev = {\r\n                    type: \"over\",\r\n                    target: io,\r\n                    event: ev,\r\n                    pointer: pointer,\r\n                    touch: pointer.touch\r\n                };\r\n                io.events.dispatchImmediately(\"over\", imev);\r\n            }\r\n        }\r\n    };\r\n    /**\r\n     * Handles when [[InteractionObject]] is no longer hovered.\r\n     *\r\n     * If `soft = true`, this means that method is being invoked by some other\r\n     * code, not hard \"out\" function, like `handleUp` which implies we need to\r\n     * run additional checks before unhovering the object.\r\n     *\r\n     * @ignore Exclude from docs\r\n     * @param io       Interaction object\r\n     * @param pointer  Pointer\r\n     * @param ev       Original event\r\n     * @param soft     Invoked by helper function\r\n     * @param force    Force imediate out\r\n     */\r\n    Interaction.prototype.handleOut = function (io, pointer, ev, soft, force) {\r\n        var _this = this;\r\n        if (soft === void 0) { soft = false; }\r\n        if (force === void 0) { force = false; }\r\n        if (!io.hoverable) {\r\n            return;\r\n        }\r\n        // Remove pointer\r\n        io.overPointers.removeValue(pointer);\r\n        // Check if element is still hovered\r\n        if (io.isHover && (!io.hasDelayedOut || force)) {\r\n            // Should we run additional checks?\r\n            if (soft && io.overPointers.length) {\r\n                // There are still pointers hovering - don't do anything else and\r\n                // wait until either no over pointers are there or we get a hard out\r\n                // event.\r\n                return;\r\n            }\r\n            // Should we delay \"out\" if this is happening on a touch device?\r\n            if (pointer && pointer.touch && !force && !this.old(pointer)) {\r\n                // This is a touch pointer, and it hasn't moved, let's pretend\r\n                // the object is still hovered, and act as per \"behavior\" setting\r\n                var behavior = this.getHoverOption(io, \"touchOutBehavior\");\r\n                if (behavior == \"leave\") {\r\n                    // Set to \"leave\", so we do not execute any \"out\" event.\r\n                    // It will be handled by any other interaction that happens\r\n                    // afterwards.\r\n                    this._delayedEvents.out.push({\r\n                        type: \"out\",\r\n                        io: io,\r\n                        pointer: pointer,\r\n                        event: ev,\r\n                        keepUntil: $time.getTime() + 500\r\n                    });\r\n                    io.hasDelayedOut = true;\r\n                    return;\r\n                }\r\n                else if (behavior == \"delay\" && this.getHoverOption(io, \"touchOutDelay\")) {\r\n                    this._delayedEvents.out.push({\r\n                        type: \"out\",\r\n                        io: io,\r\n                        pointer: pointer,\r\n                        event: ev,\r\n                        keepUntil: $time.getTime() + 500,\r\n                        timeout: this.setTimeout(function () {\r\n                            _this.handleOut(io, pointer, ev, true);\r\n                        }, this.getHoverOption(io, \"touchOutDelay\"))\r\n                    });\r\n                    return;\r\n                }\r\n                else {\r\n                    // Nothing for \"remove\" - that's how it works \"out-of-the-box\"\r\n                }\r\n            }\r\n            // Set element as not hovered\r\n            io.isHover = false;\r\n            this.overObjects.removeValue(io);\r\n            // Invoke event\r\n            if (!io.isDisposed() && io.events.isEnabled(\"out\") && !system.isPaused) {\r\n                var imev = {\r\n                    type: \"out\",\r\n                    target: io,\r\n                    event: ev,\r\n                    pointer: pointer,\r\n                    touch: pointer.touch\r\n                };\r\n                io.events.dispatchImmediately(\"out\", imev);\r\n            }\r\n            // Reset object from lefover delayed outs, pointers\r\n            io.overPointers.clear();\r\n            io.hasDelayedOut = false;\r\n            // @todo (clean delayed)\r\n        }\r\n    };\r\n    /**\r\n     * Processes dalyed events, such as \"out\" event that was initiated for\r\n     * elements by touch.\r\n     */\r\n    Interaction.prototype.processDelayed = function () {\r\n        var delayedEvent;\r\n        while (true) {\r\n            delayedEvent = this._delayedEvents.out.pop();\r\n            if (!delayedEvent) {\r\n                break;\r\n            }\r\n            if (delayedEvent.timeout) {\r\n                delayedEvent.timeout.dispose();\r\n            }\r\n            this.handleOut(delayedEvent.io, delayedEvent.pointer, delayedEvent.event, false, true);\r\n        }\r\n    };\r\n    /**\r\n     * Performs tasks on pointer down.\r\n     *\r\n     * @ignore Exclude from docs\r\n     * @param io       Element\r\n     * @param pointer  Pointer\r\n     * @param ev       Original event\r\n     */\r\n    Interaction.prototype.handleDown = function (io, pointer, ev) {\r\n        // Need to prevent default event from happening on transformable objects\r\n        this.maybePreventDefault(io, ev, pointer);\r\n        // Stop inertia animations if they're currently being played out\r\n        if (io.inert) {\r\n            this.stopInertia(io);\r\n        }\r\n        // Trigger hover because some touch devices won't trigger over events\r\n        // on their own\r\n        this.handleOver(io, pointer, ev, true);\r\n        // Add pointer to list\r\n        io.downPointers.moveValue(pointer);\r\n        // Apply styles if necessary\r\n        this.applyCursorDownStyle(io, pointer);\r\n        // Check if object is already down\r\n        if (!io.isDown) {\r\n            // Lose focus if needed\r\n            if (io.focusable !== false && this.getHitOption(io, \"noFocus\") && this.focusedObject) {\r\n                $dom.blur();\r\n            }\r\n            // Set object as hovered\r\n            io.isDown = true;\r\n            this.downObjects.moveValue(io);\r\n            // Prep object for dragging and/or resizing\r\n            if (io.draggable) {\r\n                this.processDragStart(io, pointer, ev);\r\n            }\r\n            if (io.resizable) {\r\n                this.processResizeStart(io, pointer, ev);\r\n            }\r\n        }\r\n        // Dispatch \"down\" event\r\n        if (io.events.isEnabled(\"down\") && !system.isPaused) {\r\n            var imev = {\r\n                type: \"down\",\r\n                target: io,\r\n                event: ev,\r\n                pointer: pointer,\r\n                touch: pointer.touch\r\n            };\r\n            io.events.dispatchImmediately(\"down\", imev);\r\n        }\r\n    };\r\n    /**\r\n     * Performs tasks on pointer up.\r\n     *\r\n     * @ignore Exclude from docs\r\n     * @param pointer  Pointer\r\n     * @param ev       Original event\r\n     */\r\n    Interaction.prototype.handleGlobalUp = function (pointer, ev, cancelled) {\r\n        var _this = this;\r\n        if (cancelled === void 0) { cancelled = false; }\r\n        var sorted = this.downObjects.values.slice();\r\n        sorted.sort(function (x, y) {\r\n            if (x && y) {\r\n                var pos = x.element.compareDocumentPosition(y.element);\r\n                if (pos & Node.DOCUMENT_POSITION_CONTAINED_BY) {\r\n                    return 1;\r\n                }\r\n                else if (pos & Node.DOCUMENT_POSITION_CONTAINS) {\r\n                    return -1;\r\n                }\r\n                else {\r\n                    return 0;\r\n                }\r\n            }\r\n            else {\r\n                return 0;\r\n            }\r\n        });\r\n        // Process all down objects\r\n        $array.each(sorted, function (io) {\r\n            // Check if this particular pointer is pressing down\r\n            // on object\r\n            if (io && io.downPointers.contains(pointer)) {\r\n                _this.handleUp(io, pointer, ev, cancelled);\r\n            }\r\n        });\r\n    };\r\n    /**\r\n     * Simulates all pointers being up once mouse leaves document area.\r\n     *\r\n     * @ignore Exclude from docs\r\n     * @param ev       Original event\r\n     */\r\n    Interaction.prototype.handleDocumentLeave = function (ev) {\r\n        var _this = this;\r\n        // Process all down objects\r\n        $iter.each(this.downObjects.backwards().iterator(), function (io) {\r\n            io.downPointers.each(function (pointer) {\r\n                _this.handleUp(io, pointer, ev);\r\n            });\r\n        });\r\n    };\r\n    /**\r\n     * Handles when [[InteractionObject]] is no longer hovered.\r\n     *\r\n     * @ignore Exclude from docs\r\n     * @param io       Interaction object\r\n     * @param pointer  Pointer\r\n     * @param ev       Original event\r\n     */\r\n    Interaction.prototype.handleUp = function (io, pointer, ev, cancelled) {\r\n        if (cancelled === void 0) { cancelled = false; }\r\n        // Restore cursor style\r\n        this.restoreCursorDownStyle(io, pointer);\r\n        // Remove pointer from the list\r\n        io.downPointers.removeValue(pointer);\r\n        // Trigger out because some touch devices won't trigger out events\r\n        // on their own\r\n        if ((pointer && pointer.touch) || this._useTouchEventsOnly) {\r\n            this.handleOut(io, pointer, ev, true);\r\n        }\r\n        // Check if object still down\r\n        if (io.isDown) {\r\n            // Check if there are no other pointers hovering this element\r\n            if (io.downPointers.length == 0) {\r\n                // Set element as no longer down\r\n                io.isDown = false;\r\n                this.downObjects.removeValue(io);\r\n            }\r\n            // Dispatch \"up\" event\r\n            if (io.events.isEnabled(\"up\") && !system.isPaused && pointer) {\r\n                var imev = {\r\n                    type: \"up\",\r\n                    target: io,\r\n                    event: ev,\r\n                    pointer: pointer,\r\n                    touch: pointer.touch\r\n                };\r\n                io.events.dispatchImmediately(\"up\", imev);\r\n            }\r\n            // Check if this was not a cancelled event.\r\n            // If event was canelled (which might happen if gesture resulted in\r\n            // navigation or page scroll) there's no point in triggering hit and\r\n            // other actions.\r\n            if (!cancelled) {\r\n                // Handle swiping-related stuff\r\n                if (io.swipeable && this.swiped(io, pointer)) {\r\n                    // Swiped - nothing else should happen\r\n                    this.handleSwipe(io, pointer, ev);\r\n                }\r\n                else {\r\n                    // Check if it maybe a click\r\n                    if (io.clickable && !this.moved(pointer, this.getHitOption(io, \"hitTolerance\"))) {\r\n                        this.handleHit(io, pointer, ev);\r\n                    }\r\n                    // Handle inertia\r\n                    if (io.inert && this.moved(pointer, this.getHitOption(io, \"hitTolerance\"))) {\r\n                        this.handleInertia(io, pointer);\r\n                    }\r\n                    else if (io.draggable) {\r\n                        this.processDragStop(io, pointer, ev);\r\n                    }\r\n                    if (io.resizable) {\r\n                        this.processResizeStop(io, pointer, ev);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    };\r\n    /**\r\n     * Checks if event needs to be prevented on draggable and such items, so that\r\n     * touch gestures like navigation and scroll do not kick in.\r\n     *\r\n     * @param io  Object\r\n     * @param ev  Event\r\n     */\r\n    Interaction.prototype.maybePreventDefault = function (io, ev, pointer) {\r\n        if ($type.hasValue(ev)\r\n            && (io.draggable || io.swipeable || io.trackable || io.resizable)\r\n            && !this.isGlobalElement(io)\r\n            && ev.cancelable !== false\r\n            && (!io.isTouchProtected || !pointer || !pointer.touch)) {\r\n            ev.preventDefault();\r\n        }\r\n    };\r\n    /**\r\n     * Cancels all hovers on all currently hovered objects.\r\n     *\r\n     * @param  pointer  Pointer\r\n     * @param  ev       Event\r\n     */\r\n    Interaction.prototype.cancelAllHovers = function (ev) {\r\n        var _this = this;\r\n        //this.overObjects.each((io) => {\r\n        $iter.each(this.overObjects.backwards().iterator(), function (io) {\r\n            if (io) {\r\n                var pointer = io.overPointers.getIndex(0);\r\n                _this.handleOut(io, pointer, ev, true, true);\r\n            }\r\n        });\r\n    };\r\n    /**\r\n     * Checks if hovers should be cancelled on transform as per global options.\r\n     * @param   pointer  Pointer\r\n     * @return           Cancel?\r\n     */\r\n    Interaction.prototype.shouldCancelHovers = function (pointer) {\r\n        return options.disableHoverOnTransform == \"always\" || (options.disableHoverOnTransform == \"touch\" && pointer.touch);\r\n    };\r\n    /**\r\n     * Handles pointer move.\r\n     *\r\n     * @ignore Exclude from docs\r\n     * @param pointer  Pointer\r\n     * @param ev       Original event\r\n     */\r\n    Interaction.prototype.handleGlobalMove = function (pointer, ev) {\r\n        var _this = this;\r\n        // Process hovered elements\r\n        // We check if the element became unhovered without reporting the mouseout\r\n        // event. (it happens in some cases)\r\n        if (!pointer.touch) {\r\n            var target_1 = $dom.eventTarget(pointer.lastEvent);\r\n            $iter.each(this.overObjects.backwards().iterator(), function (io) {\r\n                // Is this pointer relevant to element?\r\n                if (io && io.overPointers.contains(pointer) && io.hoverable) {\r\n                    // Check if the element is still hovered\r\n                    var reset = false;\r\n                    if (io.element && pointer.lastEvent) {\r\n                        if (!$dom.contains(io.element, target_1)) {\r\n                            reset = true;\r\n                        }\r\n                    }\r\n                    else {\r\n                        reset = true;\r\n                    }\r\n                    if (reset) {\r\n                        _this.handleOut(io, pointer, ev, true);\r\n                    }\r\n                }\r\n            });\r\n        }\r\n        // Process down elements\r\n        $iter.each(this.transformedObjects.backwards().iterator(), function (io) {\r\n            // Is this pointer relevant to element?\r\n            if (io.downPointers.contains(pointer) &&\r\n                // Swipe still happening?\r\n                !(io.swipeable && _this.swiping(io, pointer)) &&\r\n                (io.draggable || io.resizable)) {\r\n                _this.handleTransform(io, ev);\r\n            }\r\n        });\r\n        // Process tracked elements\r\n        $iter.each(this.trackedObjects.backwards().iterator(), function (io) {\r\n            // Is this pointer relevant to element?\r\n            if (!io.overPointers.contains(pointer)) {\r\n                _this.handleTrack(io, pointer, ev);\r\n            }\r\n        });\r\n    };\r\n    /**\r\n     * Handles reporting of pointer movement.\r\n     *\r\n     * @ignore Exclude from docs\r\n     * @param io        Element\r\n     * @param pointer    Pointer\r\n     * @param ev         Original event\r\n     * @param skipCheck  Sould we skip check if cursor actually moved\r\n     */\r\n    Interaction.prototype.handleTrack = function (io, pointer, ev, skipCheck) {\r\n        if (skipCheck === void 0) { skipCheck = false; }\r\n        // Do nothing if the cursor did not actually move\r\n        if (!skipCheck && !this.moved(pointer, 0)) {\r\n            return;\r\n        }\r\n        // Initiate TRACK event\r\n        if (io.events.isEnabled(\"track\") && !system.isPaused) {\r\n            var imev = {\r\n                type: \"track\",\r\n                target: io,\r\n                event: ev,\r\n                point: pointer.point,\r\n                pointer: pointer,\r\n                touch: pointer.touch\r\n            };\r\n            io.events.dispatchImmediately(\"track\", imev);\r\n        }\r\n    };\r\n    /**\r\n     * Handles swipe action.\r\n     *\r\n     * @ignore Exclude from docs\r\n     * @param io       Element\r\n     * @param pointer  Pointer\r\n     * @param ev       Original event\r\n     */\r\n    Interaction.prototype.handleSwipe = function (io, pointer, ev) {\r\n        // We pass in InteractionEvent with shift in mouse coordinates\r\n        // between when the drag started and ended\r\n        if (io.events.isEnabled(\"swipe\") && !system.isPaused) {\r\n            var imev = {\r\n                type: \"swipe\",\r\n                target: io,\r\n                event: ev,\r\n                touch: pointer.touch\r\n            };\r\n            io.events.dispatchImmediately(\"swipe\", imev);\r\n        }\r\n        if (pointer.startPoint.x < pointer.point.x) {\r\n            if (io.events.isEnabled(\"swiperight\") && !system.isPaused) {\r\n                var imev = {\r\n                    type: \"swiperight\",\r\n                    target: io,\r\n                    event: ev,\r\n                    touch: pointer.touch\r\n                };\r\n                io.events.dispatchImmediately(\"swiperight\", imev);\r\n            }\r\n        }\r\n        else {\r\n            if (io.events.isEnabled(\"swipeleft\") && !system.isPaused) {\r\n                var imev = {\r\n                    type: \"swipeleft\",\r\n                    target: io,\r\n                    event: ev,\r\n                    touch: pointer.touch\r\n                };\r\n                io.events.dispatchImmediately(\"swipeleft\", imev);\r\n            }\r\n        }\r\n    };\r\n    /**\r\n     * Handles event triggering for wheel rotation.\r\n     *\r\n     * @ignore Exclude from docs\r\n     * @param io       Element\r\n     * @param pointer  Pointer\r\n     * @param deltaX   Horizontal shift\r\n     * @param deltaY   Vertical shift\r\n     * @param ev       Original event\r\n     */\r\n    Interaction.prototype.handleWheel = function (io, pointer, deltaX, deltaY, ev) {\r\n        var shift = {\r\n            x: deltaX,\r\n            y: deltaY\r\n        };\r\n        // Trigger generic WHEEL event\r\n        if (io.events.isEnabled(\"wheel\") && !system.isPaused) {\r\n            io.events.dispatchImmediately(\"wheel\", {\r\n                type: \"wheel\",\r\n                target: io,\r\n                event: ev,\r\n                point: pointer.point,\r\n                shift: shift\r\n            });\r\n        }\r\n        // Trigger direction-specific events\r\n        // Horizontal\r\n        if (deltaX < 0) {\r\n            if (io.events.isEnabled(\"wheelleft\") && !system.isPaused) {\r\n                io.events.dispatchImmediately(\"wheelleft\", {\r\n                    type: \"wheelleft\",\r\n                    target: io,\r\n                    event: ev,\r\n                    point: pointer.point,\r\n                    shift: shift\r\n                });\r\n            }\r\n        }\r\n        else if (deltaX > 0) {\r\n            if (io.events.isEnabled(\"swiperight\") && !system.isPaused) {\r\n                io.events.dispatchImmediately(\"wheelright\", {\r\n                    type: \"wheelright\",\r\n                    target: io,\r\n                    event: ev,\r\n                    point: pointer.point,\r\n                    shift: shift\r\n                });\r\n            }\r\n            // Vertical\r\n        }\r\n        else if (deltaY < 0) {\r\n            if (io.events.isEnabled(\"wheelup\") && !system.isPaused) {\r\n                io.events.dispatchImmediately(\"wheelup\", {\r\n                    type: \"wheelup\",\r\n                    target: io,\r\n                    event: ev,\r\n                    point: pointer.point,\r\n                    shift: shift\r\n                });\r\n            }\r\n        }\r\n        else if (deltaY > 0) {\r\n            if (io.events.isEnabled(\"wheeldown\") && !system.isPaused) {\r\n                io.events.dispatchImmediately(\"wheeldown\", {\r\n                    type: \"wheeldown\",\r\n                    target: io,\r\n                    event: ev,\r\n                    point: pointer.point,\r\n                    shift: shift\r\n                });\r\n            }\r\n        }\r\n    };\r\n    /**\r\n     * Initiates inertia checking sub-routines for different movement types:\r\n     * drag, resize.\r\n     *\r\n     * @ignore Exclude from docs\r\n     * @param sprite\r\n     * @param pointer\r\n     */\r\n    Interaction.prototype.handleInertia = function (io, pointer) {\r\n        if (io.draggable && io.downPointers.length === 0) {\r\n            this.handleMoveInertia(io, pointer);\r\n        }\r\n        if (io.resizable && io.downPointers.length > 1) {\r\n            this.handleResizeInertia(io, pointer);\r\n        }\r\n    };\r\n    /**\r\n     * Continues moving the element to simulate the effect of inertia. Happens\r\n     * when `inert` and `draggable` object is dragged and then released.\r\n     *\r\n     * @ignore Exclude from docs\r\n     * @param io       Element\r\n     * @param pointer  Pointer\r\n     */\r\n    Interaction.prototype.handleMoveInertia = function (io, pointer) {\r\n        var interaction = io;\r\n        var type = \"move\";\r\n        var point = {\r\n            \"x\": pointer.point.x,\r\n            \"y\": pointer.point.y\r\n        };\r\n        var startPoint = {\r\n            \"x\": pointer.startPoint.x,\r\n            \"y\": pointer.startPoint.y\r\n        };\r\n        // Init inertia object\r\n        var inertia = new Inertia(interaction, type, point, startPoint);\r\n        // Get inertia data\r\n        var ref = this.getTrailPoint(pointer, $time.getTime() - this.getInertiaOption(io, \"move\", \"time\"));\r\n        if (typeof ref === \"undefined\") {\r\n            this.processDragStop(io, pointer, pointer.lastUpEvent);\r\n            return;\r\n        }\r\n        // Init animation options\r\n        var factor = this.getInertiaOption(io, \"move\", \"factor\");\r\n        var animationOptions = [{\r\n                \"to\": pointer.point.x + (pointer.point.x - ref.point.x) * factor,\r\n                \"property\": \"x\"\r\n            }, {\r\n                \"to\": pointer.point.y + (pointer.point.y - ref.point.y) * factor,\r\n                \"property\": \"y\"\r\n            }];\r\n        // Start animation\r\n        var animation = new Animation(inertia, animationOptions, this.getInertiaOption(io, \"move\", \"duration\"), this.getInertiaOption(io, \"move\", \"easing\")).start();\r\n        this._disposers.push(animation.events.on(\"animationended\", function (ev) {\r\n            inertia.done();\r\n        }));\r\n        // Add inertia object\r\n        io.inertias.setKey(\"move\", inertia);\r\n    };\r\n    /**\r\n     * Continues resizing of a `resizable` element after it is resized and\r\n     * released.\r\n     *\r\n     * **NOTE:** this is is just a placeholder function. No actual fucntionality\r\n     * is implemented, yet.\r\n     *\r\n     * @ignore Exclude from docs\r\n     * @param io       Element\r\n     * @param pointer  Pointer\r\n     */\r\n    Interaction.prototype.handleResizeInertia = function (io, pointer) {\r\n        // Some day, folks. Some day...\r\n    };\r\n    /**\r\n     * Recalculates element's position and size based on position of\r\n     * all its related pointers.\r\n     *\r\n     * @ignore Exclude from docs\r\n     * @param io  Element\r\n     * @param ev  Original event\r\n     */\r\n    Interaction.prototype.handleTransform = function (io, ev) {\r\n        // Get primary pointer and its respective points\r\n        var pointer1 = io.downPointers.getIndex(0);\r\n        var point1 = null;\r\n        var startPoint1 = null;\r\n        if (pointer1) {\r\n            point1 = pointer1.point;\r\n            startPoint1 = pointer1.startPoint;\r\n        }\r\n        // Init secondary pointer\r\n        var pointer2;\r\n        var point2;\r\n        var startPoint2;\r\n        // Use center of the sprite to simulate \"second\" point of touch\r\n        point2 = {\r\n            \"x\": io.originalPosition.x,\r\n            \"y\": io.originalPosition.y\r\n        };\r\n        startPoint2 = point2;\r\n        // Determine if it's a sinngle pointer or multi\r\n        var singlePoint = true;\r\n        for (var i = 1; i < io.downPointers.length; i++) {\r\n            // Get pointer\r\n            var nextPointer = io.downPointers.getIndex(i);\r\n            // Doublecheck if it's not the same pointer by comparing original position\r\n            if (startPoint1.x != nextPointer.startPoint.x && startPoint1.y != nextPointer.startPoint.y) {\r\n                // Several pointers down\r\n                singlePoint = false;\r\n                // Get second pointer\r\n                pointer2 = nextPointer;\r\n                point2 = pointer2.point;\r\n                startPoint2 = pointer2.startPoint;\r\n                // Stop looking\r\n                break;\r\n            }\r\n        }\r\n        // Primary touch point moved?\r\n        var pointer1Moved = pointer1 && this.moved(pointer1, 0);\r\n        // Report DRAG_START if necessary\r\n        if (io.draggable && pointer1 && pointer1.dragStartEvents && pointer1.dragStartEvents.length && pointer1Moved) {\r\n            if (io.events.isEnabled(\"dragstart\") && !system.isPaused) {\r\n                io.events.dispatchImmediately(\"dragstart\", pointer1.dragStartEvents.shift());\r\n            }\r\n            //delete pointer1.dragStartEvents;\r\n        }\r\n        // Determine what we do in order of superiority\r\n        if (singlePoint && io.draggable) {\r\n            // We have only one pointer and the Sprite is draggable\r\n            // There's nothing else to be done - just move it\r\n            this.handleTransformMove(io, point1, startPoint1, ev, pointer1Moved, pointer1.touch);\r\n            if (this.shouldCancelHovers(pointer1) && this.moved(pointer1, this.getHitOption(io, \"hitTolerance\"))) {\r\n                this.cancelAllHovers(ev);\r\n            }\r\n        }\r\n        else {\r\n            // Check if second touch point moved\r\n            var pointer2Moved = pointer2 && this.moved(pointer2, 0);\r\n            if ((this.shouldCancelHovers(pointer1) && this.moved(pointer1, this.getHitOption(io, \"hitTolerance\")))\r\n                ||\r\n                    (this.shouldCancelHovers(pointer2) && this.moved(pointer2, this.getHitOption(io, \"hitTolerance\")))) {\r\n                this.cancelAllHovers(ev);\r\n            }\r\n            if (io.draggable && io.resizable) {\r\n                //this.handleTransformAll(io, point1, startPoint1, point2, startPoint2, ev, pointer1Moved && pointer2Moved);\r\n                this.handleTransformMove(io, point1, startPoint1, ev, pointer1Moved && pointer2Moved, pointer1.touch);\r\n                this.handleTransformResize(io, point1, startPoint1, point2, startPoint2, ev, pointer1Moved && pointer2Moved, pointer1.touch);\r\n            }\r\n            else {\r\n                if (io.draggable) {\r\n                    this.handleTransformMove(io, point1, startPoint1, ev, pointer1Moved, pointer1.touch);\r\n                }\r\n                if (io.resizable && (!singlePoint || ev.ctrlKey)) {\r\n                    this.handleTransformResize(io, point1, startPoint1, point2, startPoint2, ev, pointer1Moved && pointer2Moved, pointer1.touch);\r\n                }\r\n            }\r\n        }\r\n    };\r\n    /**\r\n     * Handles movement of the dragged element.\r\n     *\r\n     * @ignore Exclude from docs\r\n     * @param io            Element\r\n     * @param point         Current point of the pointer\r\n     * @param startPoint    Starting point of the pointer\r\n     * @param ev            Original event\r\n     * @param pointerMoved  Did pointer move?\r\n     */\r\n    Interaction.prototype.handleTransformMove = function (io, point, startPoint, ev, pointerMoved, touch) {\r\n        if (pointerMoved) {\r\n            if (io.events.isEnabled(\"drag\") && !system.isPaused && (!io.isTouchProtected || !touch)) {\r\n                var imev = {\r\n                    type: \"drag\",\r\n                    target: io,\r\n                    event: ev,\r\n                    shift: {\r\n                        \"x\": point.x - startPoint.x,\r\n                        \"y\": point.y - startPoint.y\r\n                    },\r\n                    startPoint: startPoint,\r\n                    point: point,\r\n                    touch: touch\r\n                };\r\n                io.events.dispatchImmediately(\"drag\", imev);\r\n            }\r\n        }\r\n    };\r\n    /**\r\n     * Handles resizing of the element.\r\n     *\r\n     * @ignore Exclude from docs\r\n     * @param io            Element\r\n     * @param point1        Current position of reference point #1\r\n     * @param startPoint1   Original position of reference point #1\r\n     * @param point2        Current position of reference point #2\r\n     * @param startPoint2   Original position of reference point #2\r\n     * @param ev            Original event\r\n     * @param pointerMoved  Did pointer move?\r\n     */\r\n    Interaction.prototype.handleTransformResize = function (io, point1, startPoint1, point2, startPoint2, ev, pointerMoved, touch) {\r\n        if (io.events.isEnabled(\"resize\") && !system.isPaused && (!io.isTouchProtected || !touch)) {\r\n            var imev = {\r\n                type: \"resize\",\r\n                target: io,\r\n                event: ev,\r\n                scale: $math.getScale(point1, startPoint1, point2, startPoint2),\r\n                startPoint1: startPoint1,\r\n                point1: point1,\r\n                startPoint2: startPoint2,\r\n                point2: point2,\r\n                touch: touch\r\n            };\r\n            io.events.dispatchImmediately(\"resize\", imev);\r\n        }\r\n    };\r\n    /**\r\n     * Handles all the preparations of the element when it starts to be dragged.\r\n     *\r\n     * @ignore Exclude from docs\r\n     * @param io       Element\r\n     * @param pointer  Pointer\r\n     * @param ev       Original event\r\n     */\r\n    Interaction.prototype.processDragStart = function (io, pointer, ev) {\r\n        // Add to draggedObjects\r\n        this.transformedObjects.moveValue(io);\r\n        if (this.shouldCancelHovers(pointer)) {\r\n            this.cancelAllHovers(ev);\r\n        }\r\n        // Report \"dragstart\"\r\n        var imev = {\r\n            type: \"dragstart\",\r\n            target: io,\r\n            event: ev,\r\n            touch: pointer ? pointer.touch : false\r\n        };\r\n        // Log object that we are starting to drag, so we can check against and\r\n        // avoid hovers on other objects that might be in the path of movement.\r\n        if (pointer) {\r\n            pointer.dragTarget = io;\r\n            //pointer.startPoint = pointer.point;\r\n        }\r\n        /**\r\n         * If pointer is set we will not fire the event until the pointer has\r\n         * actually moved. If it's not set we don't have to wait for anything, so we\r\n         * just fire off the event right away.\r\n         */\r\n        if (pointer && pointer.dragStartEvents) {\r\n            pointer.dragStartEvents.push(imev);\r\n        }\r\n        else {\r\n            if (!system.isPaused) {\r\n                io.dispatchImmediately(\"dragstart\", imev);\r\n            }\r\n        }\r\n    };\r\n    /**\r\n     * Finishes up element drag operation.\r\n     *\r\n     * @ignore Exclude from docs\r\n     * @param io       Element\r\n     * @param pointer  Pointer\r\n     * @param ev       Original event\r\n     */\r\n    Interaction.prototype.processDragStop = function (io, pointer, ev) {\r\n        // Pointer set?\r\n        if (!pointer) {\r\n            pointer = this.getDragPointer(io);\r\n        }\r\n        // Unset drag object\r\n        if (pointer) {\r\n            pointer.dragTarget = undefined;\r\n        }\r\n        // Removed from transformedObjects\r\n        this.transformedObjects.removeValue(io);\r\n        // Unlock document\r\n        //this.unlockDocument();\r\n        // Report dragstop\r\n        if (!pointer || this.moved(pointer, 0)) {\r\n            if (io.events.isEnabled(\"dragstop\") && !system.isPaused) {\r\n                var imev = {\r\n                    type: \"dragstop\",\r\n                    target: io,\r\n                    touch: pointer ? pointer.touch : false\r\n                };\r\n                io.events.dispatchImmediately(\"dragstop\", imev);\r\n            }\r\n        }\r\n    };\r\n    /**\r\n     * Handles all the preparations of the element when it starts to be resized.\r\n     *\r\n     * @ignore Exclude from docs\r\n     * @param io       Element\r\n     * @param pointer  Pointer\r\n     * @param ev       Original event\r\n     */\r\n    Interaction.prototype.processResizeStart = function (io, pointer, ev) {\r\n        // Add to draggedObjects\r\n        this.transformedObjects.moveValue(io);\r\n    };\r\n    /**\r\n     * Finishes up element drag operation.\r\n     *\r\n     * @ignore Exclude from docs\r\n     * @param io       Element\r\n     * @param pointer  Pointer\r\n     * @param ev       Original event\r\n     */\r\n    Interaction.prototype.processResizeStop = function (io, pointer, ev) {\r\n        // Removed from transformedObjects\r\n        this.transformedObjects.removeValue(io);\r\n    };\r\n    /**\r\n     * ==========================================================================\r\n     * Controls for InteractionObjects initiating directly\r\n     * ==========================================================================\r\n     * @hidden\r\n     */\r\n    /**\r\n     * Manually triggers drag start on the element. Could be useful in cases\r\n     * where tracking or dragging one element can also influence dragging another\r\n     * element.\r\n     *\r\n     * Passing in `pointer` reference is advisable. If not passed in it will try\r\n     * to determine which pointer to attach to. However, it's better to specify\r\n     * it explicitly.\r\n     *\r\n     * @param io       Element\r\n     * @param pointer  Pointer\r\n     */\r\n    Interaction.prototype.dragStart = function (io, pointer) {\r\n        if (!pointer) {\r\n            pointer = this.getDragPointer(io);\r\n        }\r\n        if (pointer) {\r\n            this.handleDown(io, pointer, pointer.lastDownEvent);\r\n        }\r\n    };\r\n    /**\r\n     * Manually ends drag on the element.\r\n     *\r\n     * @param io       Element\r\n     * @param pointer  Pointer\r\n     */\r\n    Interaction.prototype.dragStop = function (io, pointer, cancelled) {\r\n        if (!pointer) {\r\n            pointer = this.getDragPointer(io);\r\n        }\r\n        if (pointer && !cancelled) {\r\n            this.handleGlobalUp(pointer, pointer.lastUpEvent, cancelled);\r\n        }\r\n    };\r\n    /**\r\n     * This method uses a fuzzy logic to find the pointer to be used for dragging.\r\n     * Beware that this is not a rock-solid solution. If there are a few objects\r\n     * being dragged at the same time, you may get unexepected results.\r\n     *\r\n     * @param io  InteractionObject to get pointers from\r\n     * @return Pointer currently being used for dragging\r\n     */\r\n    Interaction.prototype.getDragPointer = function (io) {\r\n        if (io) {\r\n            // InteractionObject is supplied\r\n            // Use it's first down pointer\r\n            return io.downPointers.getIndex(0);\r\n        }\r\n        else if (this.transformedObjects.length) {\r\n            // Use first dragged object\r\n            return this.getDragPointer(this.transformedObjects.getIndex(0));\r\n        }\r\n        else {\r\n            return undefined;\r\n        }\r\n    };\r\n    /**\r\n     * ==========================================================================\r\n     * Utils\r\n     * ==========================================================================\r\n     * @hidden\r\n     */\r\n    /**\r\n     * Returns pointer id for the given event object.\r\n     *\r\n     * @param ev  Event\r\n     * @return Pointer ID\r\n     */\r\n    Interaction.prototype.getPointerId = function (ev) {\r\n        var id = \"\";\r\n        if ($type.hasValue(ev.identifier)) {\r\n            id = \"\" + ev.identifier;\r\n        }\r\n        else if ($type.hasValue(ev.pointerId)) {\r\n            id = \"\" + ev.pointerId;\r\n        }\r\n        else {\r\n            id = \"m\";\r\n        }\r\n        return id.replace(\"-\", \"\");\r\n    };\r\n    /**\r\n     * Returns a cursor position of the event.\r\n     *\r\n     * @param ev  Original event\r\n     * @return Event point\r\n     */\r\n    Interaction.prototype.getPointerPoint = function (ev) {\r\n        return {\r\n            \"x\": ev.clientX,\r\n            \"y\": ev.clientY\r\n        };\r\n    };\r\n    /**\r\n     * Returns [[Pointer]] object that is associated with the Event.\r\n     *\r\n     * If no such [[Pointer]] object exists, it is created.\r\n     *\r\n     * @param ev  Event\r\n     * @return Pointer\r\n     */\r\n    Interaction.prototype.getPointer = function (ev) {\r\n        // Get pointer id\r\n        var id = this.getPointerId(ev);\r\n        // Get current coordinates\r\n        var point = this.getPointerPoint(ev);\r\n        // Look for the pointer in the Dictionary if it maybe already exists\r\n        var pointer;\r\n        if (this.pointers.hasKey(id)) {\r\n            // We already have such pointer\r\n            pointer = this.pointers.getKey(id);\r\n            // We need this, because Edge reuses pointer ids across touch and mouse\r\n            pointer.touch = this.isPointerTouch(ev);\r\n            // Reset pointer\r\n            //pointer.point = point;\r\n        }\r\n        else {\r\n            // Init pointer\r\n            pointer = {\r\n                \"id\": id,\r\n                //\"touch\": !(ev instanceof MouseEvent) || ((<any>ev).pointerType && (<any>ev).pointerType != \"pointer\"),\r\n                //\"touch\": !(ev instanceof MouseEvent) || ((<any>ev).pointerType && (<any>ev).pointerType != \"mouse\"),\r\n                \"touch\": this.isPointerTouch(ev),\r\n                \"startPoint\": point,\r\n                \"startTime\": $time.getTime(),\r\n                \"point\": point,\r\n                \"track\": [],\r\n                \"swipeCanceled\": false,\r\n                \"dragStartEvents\": []\r\n            };\r\n            // Add first breadcrumb\r\n            this.addBreadCrumb(pointer, point);\r\n            // Add for re-use later\r\n            this.pointers.setKey(id, pointer);\r\n        }\r\n        // Log last event\r\n        pointer.lastEvent = ev;\r\n        this.lastPointer = pointer;\r\n        return pointer;\r\n    };\r\n    /**\r\n     * Determines if pointer event originated from a touch pointer or mouse.\r\n     *\r\n     * @param ev  Original event\r\n     * @return Touch pointer?\r\n     */\r\n    Interaction.prototype.isPointerTouch = function (ev) {\r\n        if (typeof Touch !== \"undefined\" && ev instanceof Touch) {\r\n            return true;\r\n        }\r\n        else if (typeof PointerEvent !== \"undefined\" && ev instanceof PointerEvent && $type.hasValue(ev.pointerType)) {\r\n            switch (ev.pointerType) {\r\n                case \"touch\":\r\n                case \"pen\":\r\n                case 2:\r\n                    return true;\r\n                case \"mouse\":\r\n                case 4:\r\n                    return false;\r\n                default:\r\n                    return !(ev instanceof MouseEvent);\r\n            }\r\n        }\r\n        else if ($type.hasValue(ev.type)) {\r\n            if (ev.type.match(/^mouse/)) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    };\r\n    /**\r\n     * Resets the poiner to original state, i.e. cleans movement information,\r\n     * starting point, etc.\r\n     *\r\n     * @param pointer Pointer\r\n     */\r\n    Interaction.prototype.resetPointer = function (pointer, ev) {\r\n        // Get current coordinates\r\n        var point = this.getPointerPoint(ev);\r\n        ;\r\n        pointer.startTime = $time.getTime();\r\n        pointer.startPoint = { x: point.x, y: point.y };\r\n        pointer.point = { x: point.x, y: point.y };\r\n        pointer.track = [];\r\n        pointer.swipeCanceled = false;\r\n        //clearTimeout(pointer.swipeTimeout);\r\n        //clearTimeout(pointer.holdTimeout);\r\n    };\r\n    /**\r\n     * Adds a \"breadcrumb\" point to the [[Pointer]] to log its movement path.\r\n     *\r\n     * @param pointer  Pointer\r\n     * @param point    Point coordinates\r\n     */\r\n    Interaction.prototype.addBreadCrumb = function (pointer, point) {\r\n        pointer.track.push({\r\n            \"timestamp\": $time.getTime(),\r\n            \"point\": point\r\n        });\r\n    };\r\n    /**\r\n     * Prepares the document for various touch-related operations.\r\n     *\r\n     * @ignore Exclude from docs\r\n     */\r\n    Interaction.prototype.lockDocument = function () {\r\n        this.prepElement(this.body);\r\n    };\r\n    /**\r\n     * Restores document functionality.\r\n     *\r\n     * @ignore Exclude from docs\r\n     */\r\n    Interaction.prototype.unlockDocument = function () {\r\n        if (this.transformedObjects.length == 0) {\r\n            this.restoreAllStyles(this.body);\r\n        }\r\n    };\r\n    /**\r\n     * Lock element (disable all touch)\r\n     *\r\n     * @ignore Exclude from docs\r\n     */\r\n    Interaction.prototype.lockElement = function (io) {\r\n        this.prepElement(io);\r\n    };\r\n    /**\r\n     * Restores element's functionality.\r\n     *\r\n     * @ignore Exclude from docs\r\n     */\r\n    Interaction.prototype.unlockElement = function (io) {\r\n        this.restoreAllStyles(io);\r\n    };\r\n    /**\r\n     * Locks document's wheel scroll.\r\n     *\r\n     * @ignore Exclude from docs\r\n     */\r\n    Interaction.prototype.lockWheel = function () {\r\n        window.addEventListener(this._pointerEvents.wheel, this.wheelLockEvent, this._passiveSupported ? { passive: false } : false);\r\n    };\r\n    /**\r\n     * Unlocks document's wheel scroll.\r\n     *\r\n     * @ignore Exclude from docs\r\n     */\r\n    Interaction.prototype.unlockWheel = function () {\r\n        window.removeEventListener(this._pointerEvents.wheel, this.wheelLockEvent);\r\n    };\r\n    /**\r\n     * Checks if top element at pointer's position belongs to the SVG.\r\n     *\r\n     * @ignore Exlude from docs\r\n     * @param pointer  Pointer\r\n     * @param svg      The <svg> element\r\n     * @param id       A unique identifier of the object that is checking for locality\r\n     * @return Belongs to SVG\r\n     */\r\n    Interaction.prototype.isLocalElement = function (pointer, svg, id) {\r\n        var cached = this.getCache(\"local_pointer_\" + pointer.id);\r\n        if ($type.hasValue(cached)) {\r\n            return cached;\r\n        }\r\n        var doc = ($dom.getRoot(svg) || document);\r\n        if (doc.elementFromPoint) {\r\n            var target = doc.elementFromPoint(pointer.point.x, pointer.point.y);\r\n            var local = target && $dom.contains(svg, target);\r\n            this.setCache(\"local_pointer_\" + pointer.id + \"_\" + id, local, 100);\r\n            return local;\r\n        }\r\n        return false;\r\n    };\r\n    /**\r\n     * A function that cancels mouse wheel scroll.\r\n     *\r\n     * @ignore Exclude from docs\r\n     * @param ev  Event object\r\n     * @return Returns `false` to cancel\r\n     */\r\n    Interaction.prototype.wheelLockEvent = function (ev) {\r\n        ev.preventDefault();\r\n        return false;\r\n    };\r\n    /**\r\n     * Applies a set of styles to an element. Stores the original styles so they\r\n     * can be restored later.\r\n     *\r\n     * @ignore\r\n     * @param io      Element\r\n     */\r\n    Interaction.prototype.prepElement = function (io) {\r\n        var el = io.element;\r\n        if (el) {\r\n            // Define possible props\r\n            var props = [\r\n                \"touchAction\", \"webkitTouchAction\", \"MozTouchAction\", \"MSTouchAction\", \"msTouchAction\", \"oTouchAction\",\r\n                \"userSelect\", \"webkitUserSelect\", \"MozUserSelect\", \"MSUserSelect\", \"msUserSelect\", \"oUserSelect\",\r\n                \"touchSelect\", \"webkitTouchSelect\", \"MozTouchSelect\", \"MSTouchSelect\", \"msTouchSelect\", \"oTouchSelect\",\r\n                \"touchCallout\", \"webkitTouchCallout\", \"MozTouchCallout\", \"MSTouchCallout\", \"msTouchCallout\", \"oTouchCallout\",\r\n                \"contentZooming\", \"webkitContentZooming\", \"MozContentZooming\", \"MSContentZooming\", \"msContentZooming\", \"oContentZooming\",\r\n                \"userDrag\", \"webkitUserDrag\", \"MozUserDrag\", \"MSUserDrag\", \"msUserDrag\", \"oUserDrag\"\r\n            ];\r\n            for (var i = 0; i < props.length; i++) {\r\n                if (props[i] in el.style) {\r\n                    this.setTemporaryStyle(io, props[i], \"none\");\r\n                }\r\n            }\r\n            // Remove iOS-specific selection;\r\n            this.setTemporaryStyle(io, \"tapHighlightColor\", \"rgba(0, 0, 0, 0)\");\r\n            //this.setTemporaryStyle(io, \"webkitOverflowScrolling\", \"none\");\r\n        }\r\n    };\r\n    /**\r\n     * Restores replaced styles\r\n     *\r\n     * @ignore\r\n     * @param  io  Element\r\n     */\r\n    Interaction.prototype.unprepElement = function (io) {\r\n        var el = io.element;\r\n        if (el) {\r\n            // Define possible props\r\n            var props = [\r\n                \"touchAction\", \"webkitTouchAction\", \"MozTouchAction\", \"MSTouchAction\", \"msTouchAction\", \"oTouchAction\",\r\n                \"userSelect\", \"webkitUserSelect\", \"MozUserSelect\", \"MSUserSelect\", \"msUserSelect\", \"oUserSelect\",\r\n                \"touchSelect\", \"webkitTouchSelect\", \"MozTouchSelect\", \"MSTouchSelect\", \"msTouchSelect\", \"oTouchSelect\",\r\n                \"touchCallout\", \"webkitTouchCallout\", \"MozTouchCallout\", \"MSTouchCallout\", \"msTouchCallout\", \"oTouchCallout\",\r\n                \"contentZooming\", \"webkitContentZooming\", \"MozContentZooming\", \"MSContentZooming\", \"msContentZooming\", \"oContentZooming\",\r\n                \"userDrag\", \"webkitUserDrag\", \"MozUserDrag\", \"MSUserDrag\", \"msUserDrag\", \"oUserDrag\"\r\n            ];\r\n            for (var i = 0; i < props.length; i++) {\r\n                if (props[i] in el.style) {\r\n                    this.restoreStyle(io, props[i]);\r\n                }\r\n            }\r\n            // Remove iOS-specific selection;\r\n            this.restoreStyle(io, \"tapHighlightColor\");\r\n            //this.restoreStyle(io, \"webkitOverflowScrolling\");\r\n        }\r\n    };\r\n    /**\r\n     * Returns an option associated with hit events.\r\n     *\r\n     * @ignore Exclude from docs\r\n     * @param io      Element\r\n     * @param option  Option key\r\n     * @return Option value\r\n     */\r\n    Interaction.prototype.getHitOption = function (io, option) {\r\n        var res = io.hitOptions[option];\r\n        if (typeof res === \"undefined\") {\r\n            res = this.hitOptions[option];\r\n        }\r\n        return res;\r\n    };\r\n    /**\r\n     * Returns an option associated with hover events.\r\n     *\r\n     * @ignore Exclude from docs\r\n     * @param io      Element\r\n     * @param option  Option key\r\n     * @return Option value\r\n     */\r\n    Interaction.prototype.getHoverOption = function (io, option) {\r\n        var res = io.hoverOptions[option];\r\n        if (typeof res === \"undefined\") {\r\n            res = this.hoverOptions[option];\r\n        }\r\n        return res;\r\n    };\r\n    /**\r\n     * Returns an option associated with swipe events.\r\n     *\r\n     * @ignore Exclude from docs\r\n     * @param io      Element\r\n     * @param option  Option key\r\n     * @return Option value\r\n     */\r\n    Interaction.prototype.getSwipeOption = function (io, option) {\r\n        var res = io.swipeOptions[option];\r\n        if (typeof res === \"undefined\") {\r\n            res = this.swipeOptions[option];\r\n        }\r\n        return res;\r\n    };\r\n    /**\r\n     * Returns an option for keyboard.\r\n     *\r\n     * @ignore Exclude from docs\r\n     * @param io      Element\r\n     * @param option  Option key\r\n     * @return Option value\r\n     */\r\n    Interaction.prototype.getKeyboardOption = function (io, option) {\r\n        var res = io.keyboardOptions[option];\r\n        if (typeof res === \"undefined\") {\r\n            res = this.keyboardOptions[option];\r\n        }\r\n        return res;\r\n    };\r\n    /**\r\n     * Returns an option for mouse.\r\n     *\r\n     * @ignore Exclude from docs\r\n     * @param io      Element\r\n     * @param option  Option key\r\n     * @return Option value\r\n     */\r\n    Interaction.prototype.getMouseOption = function (io, option) {\r\n        var res = io.mouseOptions[option];\r\n        if (typeof res === \"undefined\") {\r\n            res = this.mouseOptions[option];\r\n        }\r\n        return res;\r\n    };\r\n    /**\r\n     * Returns an option associated with inertia.\r\n     *\r\n     * @ignore Exclude from docs\r\n     * @param io      Element\r\n     * @param type    Inertia type\r\n     * @param option  Option key\r\n     * @return Option value\r\n     */\r\n    Interaction.prototype.getInertiaOption = function (io, type, option) {\r\n        var options = io.inertiaOptions.getKey(type);\r\n        var res;\r\n        if (options && $type.hasValue(options[option])) {\r\n            res = options[option];\r\n        }\r\n        else {\r\n            res = this.inertiaOptions.getKey(type)[option];\r\n        }\r\n        return res;\r\n    };\r\n    /**\r\n     * Stops currently going on inertia. Useful if inertia is currently being\r\n     * animated and the object is being interacted with.\r\n     *\r\n     * @param io Element\r\n     */\r\n    Interaction.prototype.stopInertia = function (io) {\r\n        var x;\r\n        var inertias = [\"move\", \"resize\"];\r\n        for (var i = 0; i < inertias.length; i++) {\r\n            x = inertias[i];\r\n            if (io.inertias.hasKey(x)) {\r\n                var inertia = io.inertias.getKey(x);\r\n                if (inertia) {\r\n                    inertia.dispose();\r\n                    //io.inertiaAnimations.removeKey(x);\r\n                    //this.processDragStop(io);\r\n                    continue;\r\n                }\r\n            }\r\n        }\r\n    };\r\n    /**\r\n     * Check if swiping is currently being performed on an object.\r\n     *\r\n     * @param io       Element\r\n     * @param pointer  Pointer to check\r\n     * @return `true` if swiping\r\n     */\r\n    Interaction.prototype.swiping = function (io, pointer) {\r\n        var now = $time.getTime();\r\n        if (pointer.swipeCanceled || !io.swipeable) {\r\n            return false;\r\n        }\r\n        else if ((Math.abs(pointer.startPoint.y - pointer.point.y) < this.getSwipeOption(io, \"verticalThreshold\")) &&\r\n            (pointer.startTime > (now - this.getSwipeOption(io, \"time\")))) {\r\n            return true;\r\n        }\r\n        else {\r\n            return false;\r\n        }\r\n    };\r\n    /**\r\n     * Returns `true` if a successfull swipe action was performed on an element.\r\n     *\r\n     * @param io       Element\r\n     * @param pointer  Pointer\r\n     * @return Swiped?\r\n     */\r\n    Interaction.prototype.swiped = function (io, pointer) {\r\n        var now = $time.getTime();\r\n        if (pointer.swipeCanceled) {\r\n            return false;\r\n        }\r\n        else if ((Math.abs(pointer.startPoint.x - pointer.point.x) > this.getSwipeOption(io, \"horizontalThreshold\")) &&\r\n            (Math.abs(pointer.startPoint.y - pointer.point.y) < this.getSwipeOption(io, \"verticalThreshold\")) &&\r\n            (pointer.startTime > (now - this.getSwipeOption(io, \"time\")))) {\r\n            return true;\r\n        }\r\n        else {\r\n            return false;\r\n        }\r\n    };\r\n    /**\r\n     * Applies style to mouse cursor based on its stage in relation to\r\n     * [[InteractionObject]].\r\n     *\r\n     * @ignore Exclude from docs\r\n     * @param Element\r\n     */\r\n    Interaction.prototype.applyCursorOverStyle = function (io) {\r\n        // Get sprite's cursor ooptions\r\n        var options = io.cursorOptions;\r\n        if (!$type.hasValue(options.overStyle)) {\r\n            return;\r\n        }\r\n        // Apply cursor down styles\r\n        for (var i = 0; i < options.overStyle.length; i++) {\r\n            $dom.setStyle(io.element, options.overStyle[i].property, options.overStyle[i].value);\r\n        }\r\n    };\r\n    /**\r\n     * Applies style to mouse cursor based on its stage in relation to\r\n     * [[InteractionObject]].\r\n     *\r\n     * @ignore Exclude from docs\r\n     * @param io       Element\r\n     * @param pointer  Pointer\r\n     */\r\n    Interaction.prototype.applyCursorDownStyle = function (io, pointer) {\r\n        // Not applicable for touch pointers since they don't display a cursor\r\n        if (pointer && pointer.touch) {\r\n            return;\r\n        }\r\n        var downStyle = io.cursorOptions.downStyle;\r\n        // Is down?\r\n        if (io.downPointers.contains(pointer) && $type.hasValue(downStyle)) {\r\n            // Apply cursor down styles\r\n            for (var i = 0; i < downStyle.length; i++) {\r\n                this.setTemporaryStyle(this.body, downStyle[i].property, downStyle[i].value);\r\n                this.setTemporaryStyle(io, downStyle[i].property, downStyle[i].value);\r\n            }\r\n        }\r\n    };\r\n    /**\r\n     * Restores original cursor style for the element.\r\n     *\r\n     * @ignore Exclude from docs\r\n     * @param io       Element\r\n     * @param pointer  Pointer\r\n     */\r\n    Interaction.prototype.restoreCursorDownStyle = function (io, pointer) {\r\n        // Not applicable for touch pointers since they don't display a cursor\r\n        if (pointer && pointer.touch) {\r\n            return;\r\n        }\r\n        var downStyle = io.cursorOptions.downStyle;\r\n        // Is down?\r\n        if (io.downPointers.contains(pointer) && $type.hasValue(downStyle)) {\r\n            // Apply cursor down styles\r\n            for (var i = 0; i < downStyle.length; i++) {\r\n                this.restoreStyle(this.body, downStyle[i].property);\r\n                this.restoreStyle(io, downStyle[i].property);\r\n            }\r\n        }\r\n    };\r\n    /**\r\n     * Sets style on the body of the document.\r\n     *\r\n     * @ignore Exclude from docs\r\n     * @param style  Style definitions\r\n     */\r\n    Interaction.prototype.setGlobalStyle = function (style) {\r\n        var body = getInteraction().body;\r\n        var styles = ($type.isArray(style) ? style : [style]);\r\n        for (var i = 0; i < styles.length; i++) {\r\n            this.setTemporaryStyle(body, styles[i].property, styles[i].value);\r\n        }\r\n    };\r\n    /**\r\n     * Restores style on the body of the document.\r\n     *\r\n     * @ignore Exclude from docs\r\n     * @param style  Style definitions\r\n     */\r\n    Interaction.prototype.restoreGlobalStyle = function (style) {\r\n        var body = getInteraction().body;\r\n        var styles = ($type.isArray(style) ? style : [style]);\r\n        for (var i = 0; i < styles.length; i++) {\r\n            this.restoreStyle(body, styles[i].property);\r\n        }\r\n    };\r\n    /**\r\n     * Checks if element is a non-cahrt element.\r\n     *\r\n     * @param io  InteractionObject\r\n     * @return Global element?\r\n     */\r\n    Interaction.prototype.isGlobalElement = function (io) {\r\n        return document.body === io.element;\r\n    };\r\n    /**\r\n     * Checks if pointer has moved since it was created.\r\n     *\r\n     * @param pointer    Pointer\r\n     * @param tolerance  Tolerance in pixels\r\n     * @param minTime    Minimum time required for the pointer to be down to be considered moved\r\n     * @return `true` if the pointer has moved\r\n     */\r\n    Interaction.prototype.moved = function (pointer, tolerance, minTime) {\r\n        /*// If there was more time, we don't care if cursor actually moved\r\n        let duration = $time.getTime() - pointer.startTime;\r\n        if ($type.hasValue(minTime) && (minTime > duration)) {\r\n            return false;\r\n        }*/\r\n        if (minTime === void 0) { minTime = 300; }\r\n        // That was quick measure shift\r\n        var shift = this.getShift(pointer);\r\n        return (Math.abs(shift.x) > tolerance) || (Math.abs(shift.y) > tolerance);\r\n    };\r\n    /**\r\n     * Returns if pointer is \"old\", meaning it has been pressing for more than\r\n     * X milliseconds.\r\n     *\r\n     * @ignore\r\n     * @param pointer  Pointer\r\n     * @param minTime  Minimum time to consider pointer old\r\n     * @return {boolean}\r\n     */\r\n    Interaction.prototype.old = function (pointer, minTime) {\r\n        if (minTime === void 0) { minTime = 300; }\r\n        return $time.getTime() - pointer.startTime > minTime;\r\n    };\r\n    /**\r\n     * Returns total a shift in pointers coordinates between its original\r\n     * position and now.\r\n     *\r\n     * @param pointer  Pointer\r\n     * @return Shift in coordinates (x/y)\r\n     */\r\n    Interaction.prototype.getShift = function (pointer) {\r\n        return {\r\n            \"x\": pointer.startPoint.x - pointer.point.x,\r\n            \"y\": pointer.startPoint.y - pointer.point.y\r\n        };\r\n    };\r\n    /**\r\n     * Returns a point from [[Pointer]]'s move history at a certain timetamp.\r\n     *\r\n     * @param pointer    Pointer\r\n     * @param timestamp  Timestamp\r\n     * @return Point\r\n     */\r\n    Interaction.prototype.getTrailPoint = function (pointer, timestamp) {\r\n        var res;\r\n        for (var i = 0; i < pointer.track.length; i++) {\r\n            if (pointer.track[i].timestamp >= timestamp) {\r\n                res = pointer.track[i];\r\n                break;\r\n            }\r\n        }\r\n        return res;\r\n    };\r\n    /**\r\n     * Checks if same pointer already exists in the list.\r\n     *\r\n     * @param list     List to check agains\r\n     * @param pointer  Pointer\r\n     * @return Exists?\r\n     */\r\n    Interaction.prototype.pointerExists = function (list, pointer) {\r\n        var exists = false;\r\n        list.each(function (item) {\r\n            if (item == pointer) {\r\n                return;\r\n            }\r\n            exists = item.point.x == pointer.point.x && item.point.y == pointer.point.y;\r\n        });\r\n        return exists;\r\n    };\r\n    /**\r\n     * Returns an [[InteractionObject]] representation of a DOM element.\r\n     *\r\n     * You can use this on any HTML or SVG element, to add interactive features\r\n     * to it.\r\n     *\r\n     * @param element  Element\r\n     * @return InteractionObject\r\n     */\r\n    Interaction.prototype.getInteraction = function (element) {\r\n        return new InteractionObject(element);\r\n    };\r\n    /**\r\n     * Sets a style property on an element. Stores original value to be restored\r\n     * later with [[restoreStyle]].\r\n     *\r\n     * @see {@link restoreStyle}\r\n     * @param io        Element\r\n     * @param property  Property\r\n     * @param value     Value\r\n     */\r\n    Interaction.prototype.setTemporaryStyle = function (io, property, value) {\r\n        // Get element\r\n        //let el = io.element.tagName == \"g\" ? <SVGSVGElement>io.element.parentNode : io.element;\r\n        var el = io.element;\r\n        // Save original property if it is set and hasn't been saved before already\r\n        if ($type.hasValue(el.style[property]) && !io.replacedStyles.hasKey(property)) {\r\n            io.replacedStyles.setKey(property, el.style[property]);\r\n        }\r\n        // Replace with the new one\r\n        $dom.setStyle(el, property, value);\r\n    };\r\n    /**\r\n     * Restores specific style on an element.\r\n     *\r\n     * @param io        Element\r\n     * @param property  Style property\r\n     */\r\n    Interaction.prototype.restoreStyle = function (io, property) {\r\n        // Reset style\r\n        if (io.replacedStyles.hasKey(property)) {\r\n            io.element.style[property] = io.replacedStyles.getKey(property);\r\n            io.replacedStyles.removeKey(property);\r\n        }\r\n        else {\r\n            delete io.element.style[property];\r\n        }\r\n    };\r\n    /**\r\n     * Restore temporarily reset styles on an element.\r\n     *\r\n     * @param io Element\r\n     */\r\n    Interaction.prototype.restoreAllStyles = function (io) {\r\n        $iter.each(io.replacedStyles.iterator(), function (a) {\r\n            var key = a[0];\r\n            var value = a[1];\r\n            io.element.style[key] = value;\r\n            io.replacedStyles.removeKey(key);\r\n        });\r\n    };\r\n    /**\r\n     * Disposes this object and cleans up after itself.\r\n     */\r\n    Interaction.prototype.dispose = function () {\r\n        if (!this.isDisposed()) {\r\n            _super.prototype.dispose.call(this);\r\n            this.restoreAllStyles(this.body);\r\n            this.unlockWheel();\r\n        }\r\n    };\r\n    // @ts-ignore Used for debugging\r\n    Interaction.prototype.log = function (text, ev, io) {\r\n        var show = true;\r\n        if (show) {\r\n            // Touchlist?\r\n            if (ev.changedTouches) {\r\n                for (var i = 0; i < ev.changedTouches.length; i++) {\r\n                    this.logTouch(text, ev.type, ev.changedTouches[i]);\r\n                }\r\n                return;\r\n            }\r\n            // Get type\r\n            var type = \"\";\r\n            if (ev.pointerType) {\r\n                switch (ev.pointerType) {\r\n                    case 2:\r\n                        type = \"touch\";\r\n                        break;\r\n                    case 4:\r\n                        type = \"mouse\";\r\n                        break;\r\n                    default:\r\n                        type = ev.pointerType;\r\n                        break;\r\n                }\r\n            }\r\n            else if (typeof TouchEvent != \"undefined\" && ev instanceof TouchEvent) {\r\n                type = \"touch\";\r\n            }\r\n            else if (ev.type.match(/^mouse/)) {\r\n                type = \"mouse\";\r\n            }\r\n            else {\r\n                type = \"???\";\r\n            }\r\n            // Get ID\r\n            var id = \"\";\r\n            if ($type.hasValue(ev.identifier)) {\r\n                id = ev.identifier;\r\n            }\r\n            else if ($type.hasValue(ev.pointerId)) {\r\n                id = ev.pointerId;\r\n            }\r\n            else {\r\n                id = \"???\";\r\n            }\r\n            if (io) {\r\n                console.log(text + \" (\" + io.uid + \")  \" + ev.type + \"  \" + type + \"  \" + id);\r\n            }\r\n            else {\r\n                console.log(text + \"  \" + ev.type + \"  \" + type + \"  \" + id);\r\n            }\r\n        }\r\n    };\r\n    /**\r\n     * Checks whether there are currently any objects being transformed (dragged\r\n     * or resized).\r\n     *\r\n     * If `except` is set, that object will be ignored.\r\n     *\r\n     * @since 4.9.3\r\n     * @param   except  Ignore this object(s)\r\n     * @return          Objects are being transformed\r\n     */\r\n    Interaction.prototype.areTransformed = function (except) {\r\n        var count = this.transformedObjects.length;\r\n        if (except) {\r\n            var ex = $type.isArray(except) ? except : [except];\r\n            for (var i = 0; i < ex.length; i++) {\r\n                if (this.transformedObjects.contains(ex[i])) {\r\n                    count--;\r\n                }\r\n            }\r\n        }\r\n        return count > 0;\r\n    };\r\n    /**\r\n     * Log.\r\n     */\r\n    Interaction.prototype.logTouch = function (text, type, ev) {\r\n        console.log(text + \"  \" + type + \"  \" + \"touch\" + \"  \" + ev.identifier);\r\n    };\r\n    Object.defineProperty(Interaction, \"passiveSupported\", {\r\n        /**\r\n         * Indicates if passive mode options is supported by this browser.\r\n         */\r\n        get: function () {\r\n            var _this = this;\r\n            if (this._passiveSupported == null) {\r\n                // Check for passive mode support\r\n                try {\r\n                    var options_1 = Object.defineProperty({}, \"passive\", {\r\n                        get: function () {\r\n                            _this._passiveSupported = true;\r\n                        }\r\n                    });\r\n                    window.addEventListener(\"test\", options_1, options_1);\r\n                    window.removeEventListener(\"test\", options_1, options_1);\r\n                }\r\n                catch (err) {\r\n                    this._passiveSupported = false;\r\n                }\r\n            }\r\n            return this._passiveSupported;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    return Interaction;\r\n}(BaseObjectEvents));\r\nexport { Interaction };\r\nvar interaction = null;\r\n/**\r\n * Returns a single unified global instance of [[Interaction]].\r\n *\r\n * All code should use this function, rather than create their own instances\r\n * of [[Interaction]].\r\n */\r\nexport function getInteraction() {\r\n    if (interaction == null) {\r\n        interaction = new Interaction();\r\n    }\r\n    return interaction;\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}