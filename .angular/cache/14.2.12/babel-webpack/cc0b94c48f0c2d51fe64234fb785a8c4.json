{"ast":null,"code":"import { Injectable, EventEmitter, Component, NgZone, Input, Output, HostBinding, NgModule } from '@angular/core';\nimport { LinkedList, isBs3 } from 'ngx-bootstrap/utils';\nimport { CommonModule } from '@angular/common';\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\nimport * as ɵngcc0 from '@angular/core';\nimport * as ɵngcc1 from '@angular/common';\n\nfunction CarouselComponent_ol_1_li_1_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r7 = ɵngcc0.ɵɵgetCurrentView();\n\n    ɵngcc0.ɵɵelementStart(0, \"li\", 7);\n    ɵngcc0.ɵɵlistener(\"click\", function CarouselComponent_ol_1_li_1_Template_li_click_0_listener() {\n      const restoredCtx = ɵngcc0.ɵɵrestoreView(_r7);\n      const i_r5 = restoredCtx.index;\n      const ctx_r6 = ɵngcc0.ɵɵnextContext(2);\n      return ɵngcc0.ɵɵresetView(ctx_r6.selectSlide(i_r5));\n    });\n    ɵngcc0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const slidez_r4 = ctx.$implicit;\n    ɵngcc0.ɵɵclassProp(\"active\", slidez_r4.active === true);\n  }\n}\n\nfunction CarouselComponent_ol_1_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵelementStart(0, \"ol\", 5);\n    ɵngcc0.ɵɵtemplate(1, CarouselComponent_ol_1_li_1_Template, 1, 2, \"li\", 6);\n    ɵngcc0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r0 = ɵngcc0.ɵɵnextContext();\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵproperty(\"ngForOf\", ctx_r0.indicatorsSlides());\n  }\n}\n\nfunction CarouselComponent_a_4_span_2_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵelementStart(0, \"span\", 11);\n    ɵngcc0.ɵɵtext(1, \"Previous\");\n    ɵngcc0.ɵɵelementEnd();\n  }\n}\n\nfunction CarouselComponent_a_4_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r10 = ɵngcc0.ɵɵgetCurrentView();\n\n    ɵngcc0.ɵɵelementStart(0, \"a\", 8);\n    ɵngcc0.ɵɵlistener(\"click\", function CarouselComponent_a_4_Template_a_click_0_listener() {\n      ɵngcc0.ɵɵrestoreView(_r10);\n      const ctx_r9 = ɵngcc0.ɵɵnextContext();\n      return ɵngcc0.ɵɵresetView(ctx_r9.previousSlide());\n    });\n    ɵngcc0.ɵɵelement(1, \"span\", 9);\n    ɵngcc0.ɵɵtemplate(2, CarouselComponent_a_4_span_2_Template, 2, 0, \"span\", 10);\n    ɵngcc0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r1 = ɵngcc0.ɵɵnextContext();\n    ɵngcc0.ɵɵclassProp(\"disabled\", ctx_r1.activeSlide === 0 && ctx_r1.noWrap);\n    ɵngcc0.ɵɵadvance(2);\n    ɵngcc0.ɵɵproperty(\"ngIf\", ctx_r1.isBs4);\n  }\n}\n\nfunction CarouselComponent_a_5_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r12 = ɵngcc0.ɵɵgetCurrentView();\n\n    ɵngcc0.ɵɵelementStart(0, \"a\", 12);\n    ɵngcc0.ɵɵlistener(\"click\", function CarouselComponent_a_5_Template_a_click_0_listener() {\n      ɵngcc0.ɵɵrestoreView(_r12);\n      const ctx_r11 = ɵngcc0.ɵɵnextContext();\n      return ɵngcc0.ɵɵresetView(ctx_r11.nextSlide());\n    });\n    ɵngcc0.ɵɵelement(1, \"span\", 13);\n    ɵngcc0.ɵɵelementStart(2, \"span\", 11);\n    ɵngcc0.ɵɵtext(3, \"Next\");\n    ɵngcc0.ɵɵelementEnd()();\n  }\n\n  if (rf & 2) {\n    const ctx_r2 = ɵngcc0.ɵɵnextContext();\n    ɵngcc0.ɵɵclassProp(\"disabled\", ctx_r2.isLast(ctx_r2.activeSlide) && ctx_r2.noWrap);\n  }\n}\n\nconst _c0 = function (a0) {\n  return {\n    \"display\": a0\n  };\n};\n\nconst _c1 = [\"*\"];\n\nclass CarouselConfig {\n  constructor() {\n    /* Default interval of auto changing of slides */\n    this.interval = 5000;\n    /* Is loop of auto changing of slides can be paused */\n\n    this.noPause = false;\n    /* Is slides can wrap from the last to the first slide */\n\n    this.noWrap = false;\n    /* Show carousel-indicators */\n\n    this.showIndicators = true;\n    /* Slides can be paused on focus */\n\n    this.pauseOnFocus = false;\n    /* If `true` - carousel indicators indicate slides chunks works ONLY if singleSlideOffset = FALSE */\n\n    this.indicatorsByChunk = false;\n    /* If value more then 1 — carousel works in multilist mode */\n\n    this.itemsPerSlide = 1;\n    /* If `true` — carousel shifts by one element. By default carousel shifts by number\n        of visible elements (itemsPerSlide field) */\n\n    this.singleSlideOffset = false;\n  }\n\n}\n\nCarouselConfig.ɵfac = function CarouselConfig_Factory(t) {\n  return new (t || CarouselConfig)();\n};\n\nCarouselConfig.ɵprov = /*@__PURE__*/ɵngcc0.ɵɵdefineInjectable({\n  token: CarouselConfig,\n  factory: CarouselConfig.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(CarouselConfig, [{\n    type: Injectable\n  }], function () {\n    return [];\n  }, null);\n})();\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * Returns the index of the last element in the array where predicate is true, and -1\n * otherwise.\n * @template T\n * @param {?} array The source array to search in\n * @param {?} predicate find calls predicate once for each element of the array, in descending\n * order, until it finds one where predicate returns true. If such an element is found,\n * findLastIndex immediately returns that element index. Otherwise, findLastIndex returns -1.\n * @return {?}\n */\n\n\nfunction findLastIndex(array, predicate) {\n  /** @type {?} */\n  let l = array.length;\n\n  while (l--) {\n    if (predicate(array[l], l, array)) {\n      return l;\n    }\n  }\n\n  return -1;\n}\n/**\n * @template T\n * @param {?} array\n * @param {?} size\n * @return {?}\n */\n\n\nfunction chunkByNumber(array, size) {\n  /** @type {?} */\n  const out = [];\n  /** @type {?} */\n\n  const n = Math.ceil(array.length / size);\n  /** @type {?} */\n\n  let i = 0;\n\n  while (i < n) {\n    /** @type {?} */\n    const chunk = array.splice(0, i === n - 1 && size < array.length ? array.length : size);\n    out.push(chunk);\n    i++;\n  }\n\n  return out;\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/** @enum {number} */\n\n\nconst Direction = {\n  UNKNOWN: 0,\n  NEXT: 1,\n  PREV: 2\n};\nDirection[Direction.UNKNOWN] = 'UNKNOWN';\nDirection[Direction.NEXT] = 'NEXT';\nDirection[Direction.PREV] = 'PREV';\n/**\n * Base element to create carousel\n */\n\nclass CarouselComponent {\n  /**\n   * @param {?} config\n   * @param {?} ngZone\n   */\n  constructor(config, ngZone) {\n    this.ngZone = ngZone;\n    /* If `true` - carousel indicators indicate slides chunks\n         works ONLY if singleSlideOffset = FALSE */\n\n    this.indicatorsByChunk = false;\n    /* If value more then 1 — carousel works in multilist mode */\n\n    this.itemsPerSlide = 1;\n    /* If `true` — carousel shifts by one element. By default carousel shifts by number\n         of visible elements (itemsPerSlide field) */\n\n    this.singleSlideOffset = false;\n    /**\n     * Will be emitted when active slide has been changed. Part of two-way-bindable [(activeSlide)] property\n     */\n\n    this.activeSlideChange = new EventEmitter(false);\n    /**\n     * Will be emitted when active slides has been changed in multilist mode\n     */\n\n    this.slideRangeChange = new EventEmitter();\n    /* Index to start display slides from it */\n\n    this.startFromIndex = 0;\n    this._slides = new LinkedList();\n    this._currentVisibleSlidesIndex = 0;\n    this.destroyed = false;\n\n    this.getActive =\n    /**\n    * @param {?} slide\n    * @return {?}\n    */\n    slide => slide.active;\n\n    this.makeSlidesConsistent =\n    /**\n    * @param {?} slides\n    * @return {?}\n    */\n    slides => {\n      slides.forEach(\n      /**\n      * @param {?} slide\n      * @param {?} index\n      * @return {?}\n      */\n      (slide, index) => slide.item.order = index);\n    };\n\n    Object.assign(this, config);\n  }\n  /**\n   * Index of currently displayed slide(started for 0)\n   * @param {?} index\n   * @return {?}\n   */\n\n\n  set activeSlide(index) {\n    if (this.multilist) {\n      return;\n    }\n\n    if (this._slides.length && index !== this._currentActiveSlide) {\n      this._select(index);\n    }\n  }\n  /**\n   * @return {?}\n   */\n\n\n  get activeSlide() {\n    return this._currentActiveSlide;\n  }\n  /**\n   * Delay of item cycling in milliseconds. If false, carousel won't cycle\n   * automatically.\n   * @return {?}\n   */\n\n\n  get interval() {\n    return this._interval;\n  }\n  /**\n   * @param {?} value\n   * @return {?}\n   */\n\n\n  set interval(value) {\n    this._interval = value;\n    this.restartTimer();\n  }\n  /**\n   * @return {?}\n   */\n\n\n  get slides() {\n    return this._slides.toArray();\n  }\n  /**\n   * @return {?}\n   */\n\n\n  get isBs4() {\n    return !isBs3();\n  }\n  /**\n   * @return {?}\n   */\n\n\n  ngAfterViewInit() {\n    setTimeout(\n    /**\n    * @return {?}\n    */\n    () => {\n      if (this.singleSlideOffset) {\n        this.indicatorsByChunk = false;\n      }\n\n      if (this.multilist) {\n        this._chunkedSlides = chunkByNumber(this.mapSlidesAndIndexes(), this.itemsPerSlide);\n        this.selectInitialSlides();\n      }\n    }, 0);\n  }\n  /**\n   * @return {?}\n   */\n\n\n  ngOnDestroy() {\n    this.destroyed = true;\n  }\n  /**\n   * Adds new slide. If this slide is first in collection - set it as active\n   * and starts auto changing\n   * @param {?} slide\n   * @return {?}\n   */\n\n\n  addSlide(slide) {\n    this._slides.add(slide);\n\n    if (this.multilist && this._slides.length <= this.itemsPerSlide) {\n      slide.active = true;\n    }\n\n    if (!this.multilist && this._slides.length === 1) {\n      this._currentActiveSlide = undefined;\n      this.activeSlide = 0;\n      this.play();\n    }\n\n    if (this.multilist && this._slides.length > this.itemsPerSlide) {\n      this.play();\n    }\n  }\n  /**\n   * Removes specified slide. If this slide is active - will roll to another\n   * slide\n   * @param {?} slide\n   * @return {?}\n   */\n\n\n  removeSlide(slide) {\n    /** @type {?} */\n    const remIndex = this._slides.indexOf(slide);\n\n    if (this._currentActiveSlide === remIndex) {\n      // removing of active slide\n\n      /** @type {?} */\n      let nextSlideIndex = void 0;\n\n      if (this._slides.length > 1) {\n        // if this slide last - will roll to first slide, if noWrap flag is\n        // FALSE or to previous, if noWrap is TRUE in case, if this slide in\n        // middle of collection, index of next slide is same to removed\n        nextSlideIndex = !this.isLast(remIndex) ? remIndex : this.noWrap ? remIndex - 1 : 0;\n      }\n\n      this._slides.remove(remIndex); // prevents exception with changing some value after checking\n\n\n      setTimeout(\n      /**\n      * @return {?}\n      */\n      () => {\n        this._select(nextSlideIndex);\n      }, 0);\n    } else {\n      this._slides.remove(remIndex);\n      /** @type {?} */\n\n\n      const currentSlideIndex = this.getCurrentSlideIndex();\n      setTimeout(\n      /**\n      * @return {?}\n      */\n      () => {\n        // after removing, need to actualize index of current active slide\n        this._currentActiveSlide = currentSlideIndex;\n        this.activeSlideChange.emit(this._currentActiveSlide);\n      }, 0);\n    }\n  }\n  /**\n   * @param {?=} force\n   * @return {?}\n   */\n\n\n  nextSlideFromInterval(force = false) {\n    this.move(Direction.NEXT, force);\n  }\n  /**\n   * Rolling to next slide\n   * @param {?=} force\n   * @return {?}\n   */\n\n\n  nextSlide(force = false) {\n    if (this.isPlaying) {\n      this.restartTimer();\n    }\n\n    this.move(Direction.NEXT, force);\n  }\n  /**\n   * Rolling to previous slide\n   * @param {?=} force\n   * @return {?}\n   */\n\n\n  previousSlide(force = false) {\n    if (this.isPlaying) {\n      this.restartTimer();\n    }\n\n    this.move(Direction.PREV, force);\n  }\n  /**\n   * @return {?}\n   */\n\n\n  getFirstVisibleIndex() {\n    return this.slides.findIndex(this.getActive);\n  }\n  /**\n   * @return {?}\n   */\n\n\n  getLastVisibleIndex() {\n    return findLastIndex(this.slides, this.getActive);\n  }\n  /**\n   * @param {?} direction\n   * @param {?=} force\n   * @return {?}\n   */\n\n\n  move(direction, force = false) {\n    /** @type {?} */\n    const firstVisibleIndex = this.getFirstVisibleIndex();\n    /** @type {?} */\n\n    const lastVisibleIndex = this.getLastVisibleIndex();\n\n    if (this.noWrap) {\n      if (direction === Direction.NEXT && this.isLast(lastVisibleIndex) || direction === Direction.PREV && firstVisibleIndex === 0) {\n        return;\n      }\n    }\n\n    if (!this.multilist) {\n      this.activeSlide = this.findNextSlideIndex(direction, force);\n    } else {\n      this.moveMultilist(direction);\n    }\n  }\n  /**\n   * Swith slides by enter, space and arrows keys\n   * \\@internal\n   * @param {?} event\n   * @return {?}\n   */\n\n\n  keydownPress(event) {\n    // tslint:disable-next-line:deprecation\n    if (event.keyCode === 13 || event.key === 'Enter' || event.keyCode === 32 || event.key === 'Space') {\n      this.nextSlide();\n      event.preventDefault();\n      return;\n    } // tslint:disable-next-line:deprecation\n\n\n    if (event.keyCode === 37 || event.key === 'LeftArrow') {\n      this.previousSlide();\n      return;\n    } // tslint:disable-next-line:deprecation\n\n\n    if (event.keyCode === 39 || event.key === 'RightArrow') {\n      this.nextSlide();\n      return;\n    }\n  }\n  /**\n   * Play on mouse leave\n   * \\@internal\n   * @return {?}\n   */\n\n\n  onMouseLeave() {\n    if (!this.pauseOnFocus) {\n      this.play();\n    }\n  }\n  /**\n   * Play on mouse up\n   * \\@internal\n   * @return {?}\n   */\n\n\n  onMouseUp() {\n    if (!this.pauseOnFocus) {\n      this.play();\n    }\n  }\n  /**\n   * When slides on focus autoplay is stopped(optional)\n   * \\@internal\n   * @return {?}\n   */\n\n\n  pauseFocusIn() {\n    if (this.pauseOnFocus) {\n      this.isPlaying = false;\n      this.resetTimer();\n    }\n  }\n  /**\n   * When slides out of focus autoplay is started\n   * \\@internal\n   * @return {?}\n   */\n\n\n  pauseFocusOut() {\n    this.play();\n  }\n  /**\n   * Rolling to specified slide\n   * @param {?} index\n   * @return {?}\n   */\n\n\n  selectSlide(index) {\n    if (this.isPlaying) {\n      this.restartTimer();\n    }\n\n    if (!this.multilist) {\n      this.activeSlide = this.indicatorsByChunk ? index * this.itemsPerSlide : index;\n    } else {\n      this.selectSlideRange(this.indicatorsByChunk ? index * this.itemsPerSlide : index);\n    }\n  }\n  /**\n   * Starts a auto changing of slides\n   * @return {?}\n   */\n\n\n  play() {\n    if (!this.isPlaying) {\n      this.isPlaying = true;\n      this.restartTimer();\n    }\n  }\n  /**\n   * Stops a auto changing of slides\n   * @return {?}\n   */\n\n\n  pause() {\n    if (!this.noPause) {\n      this.isPlaying = false;\n      this.resetTimer();\n    }\n  }\n  /**\n   * Finds and returns index of currently displayed slide\n   * @return {?}\n   */\n\n\n  getCurrentSlideIndex() {\n    return this._slides.findIndex(this.getActive);\n  }\n  /**\n   * Defines, whether the specified index is last in collection\n   * @param {?} index\n   * @return {?}\n   */\n\n\n  isLast(index) {\n    return index + 1 >= this._slides.length;\n  }\n  /**\n   * Defines, whether the specified index is first in collection\n   * @param {?} index\n   * @return {?}\n   */\n\n\n  isFirst(index) {\n    return index === 0;\n  }\n  /**\n   * @return {?}\n   */\n\n\n  indicatorsSlides() {\n    return this.slides.filter(\n    /**\n    * @param {?} slide\n    * @param {?} index\n    * @return {?}\n    */\n    (slide, index) => !this.indicatorsByChunk || index % this.itemsPerSlide === 0);\n  }\n  /**\n   * @private\n   * @return {?}\n   */\n\n\n  selectInitialSlides() {\n    /** @type {?} */\n    const startIndex = this.startFromIndex <= this._slides.length ? this.startFromIndex : 0;\n    this.hideSlides();\n\n    if (this.singleSlideOffset) {\n      this._slidesWithIndexes = this.mapSlidesAndIndexes();\n\n      if (this._slides.length - startIndex < this.itemsPerSlide) {\n        /** @type {?} */\n        const slidesToAppend = this._slidesWithIndexes.slice(0, startIndex);\n\n        this._slidesWithIndexes = [...this._slidesWithIndexes, ...slidesToAppend].slice(slidesToAppend.length).slice(0, this.itemsPerSlide);\n      } else {\n        this._slidesWithIndexes = this._slidesWithIndexes.slice(startIndex, startIndex + this.itemsPerSlide);\n      }\n\n      this._slidesWithIndexes.forEach(\n      /**\n      * @param {?} slide\n      * @return {?}\n      */\n      slide => slide.item.active = true);\n\n      this.makeSlidesConsistent(this._slidesWithIndexes);\n    } else {\n      this.selectRangeByNestedIndex(startIndex);\n    }\n\n    this.slideRangeChange.emit(this.getVisibleIndexes());\n  }\n  /**\n   * Defines next slide index, depending of direction\n   * @private\n   * @param {?} direction\n   * @param {?} force\n   * @return {?}\n   */\n\n\n  findNextSlideIndex(direction, force) {\n    /** @type {?} */\n    let nextSlideIndex = 0;\n\n    if (!force && this.isLast(this.activeSlide) && direction !== Direction.PREV && this.noWrap) {\n      return undefined;\n    }\n\n    switch (direction) {\n      case Direction.NEXT:\n        // if this is last slide, not force, looping is disabled\n        // and need to going forward - select current slide, as a next\n        nextSlideIndex = !this.isLast(this._currentActiveSlide) ? this._currentActiveSlide + 1 : !force && this.noWrap ? this._currentActiveSlide : 0;\n        break;\n\n      case Direction.PREV:\n        // if this is first slide, not force, looping is disabled\n        // and need to going backward - select current slide, as a next\n        nextSlideIndex = this._currentActiveSlide > 0 ? this._currentActiveSlide - 1 : !force && this.noWrap ? this._currentActiveSlide : this._slides.length - 1;\n        break;\n\n      default:\n        throw new Error('Unknown direction');\n    }\n\n    return nextSlideIndex;\n  }\n  /**\n   * @private\n   * @return {?}\n   */\n\n\n  mapSlidesAndIndexes() {\n    return this.slides.slice().map(\n    /**\n    * @param {?} slide\n    * @param {?} index\n    * @return {?}\n    */\n    (slide, index) => {\n      return {\n        index,\n        item: slide\n      };\n    });\n  }\n  /**\n   * @private\n   * @param {?} index\n   * @return {?}\n   */\n\n\n  selectSlideRange(index) {\n    if (this.isIndexInRange(index)) {\n      return;\n    }\n\n    this.hideSlides();\n\n    if (!this.singleSlideOffset) {\n      this.selectRangeByNestedIndex(index);\n    } else {\n      /** @type {?} */\n      const startIndex = this.isIndexOnTheEdges(index) ? index : index - this.itemsPerSlide + 1;\n      /** @type {?} */\n\n      const endIndex = this.isIndexOnTheEdges(index) ? index + this.itemsPerSlide : index + 1;\n      this._slidesWithIndexes = this.mapSlidesAndIndexes().slice(startIndex, endIndex);\n      this.makeSlidesConsistent(this._slidesWithIndexes);\n\n      this._slidesWithIndexes.forEach(\n      /**\n      * @param {?} slide\n      * @return {?}\n      */\n      slide => slide.item.active = true);\n    }\n\n    this.slideRangeChange.emit(this.getVisibleIndexes());\n  }\n  /**\n   * @private\n   * @param {?} index\n   * @return {?}\n   */\n\n\n  selectRangeByNestedIndex(index) {\n    /** @type {?} */\n    const selectedRange = this._chunkedSlides.map(\n    /**\n    * @param {?} slidesList\n    * @param {?} i\n    * @return {?}\n    */\n    (slidesList, i) => {\n      return {\n        index: i,\n        list: slidesList\n      };\n    }).find(\n    /**\n    * @param {?} slidesList\n    * @return {?}\n    */\n    slidesList => {\n      return slidesList.list.find(\n      /**\n      * @param {?} slide\n      * @return {?}\n      */\n      slide => slide.index === index) !== undefined;\n    });\n\n    this._currentVisibleSlidesIndex = selectedRange.index;\n\n    this._chunkedSlides[selectedRange.index].forEach(\n    /**\n    * @param {?} slide\n    * @return {?}\n    */\n    slide => {\n      slide.item.active = true;\n    });\n  }\n  /**\n   * @private\n   * @param {?} index\n   * @return {?}\n   */\n\n\n  isIndexOnTheEdges(index) {\n    return index + 1 - this.itemsPerSlide <= 0 || index + this.itemsPerSlide <= this._slides.length;\n  }\n  /**\n   * @private\n   * @param {?} index\n   * @return {?}\n   */\n\n\n  isIndexInRange(index) {\n    if (this.singleSlideOffset) {\n      /** @type {?} */\n      const visibleIndexes = this._slidesWithIndexes.map(\n      /**\n      * @param {?} slide\n      * @return {?}\n      */\n      slide => slide.index);\n\n      return visibleIndexes.indexOf(index) >= 0;\n    }\n\n    return index <= this.getLastVisibleIndex() && index >= this.getFirstVisibleIndex();\n  }\n  /**\n   * @private\n   * @return {?}\n   */\n\n\n  hideSlides() {\n    this.slides.forEach(\n    /**\n    * @param {?} slide\n    * @return {?}\n    */\n    slide => slide.active = false);\n  }\n  /**\n   * @private\n   * @return {?}\n   */\n\n\n  isVisibleSlideListLast() {\n    return this._currentVisibleSlidesIndex === this._chunkedSlides.length - 1;\n  }\n  /**\n   * @private\n   * @return {?}\n   */\n\n\n  isVisibleSlideListFirst() {\n    return this._currentVisibleSlidesIndex === 0;\n  }\n  /**\n   * @private\n   * @param {?} direction\n   * @return {?}\n   */\n\n\n  moveSliderByOneItem(direction) {\n    /** @type {?} */\n    let firstVisibleIndex;\n    /** @type {?} */\n\n    let lastVisibleIndex;\n    /** @type {?} */\n\n    let indexToHide;\n    /** @type {?} */\n\n    let indexToShow;\n\n    if (this.noWrap) {\n      firstVisibleIndex = this.getFirstVisibleIndex();\n      lastVisibleIndex = this.getLastVisibleIndex();\n      indexToHide = direction === Direction.NEXT ? firstVisibleIndex : lastVisibleIndex;\n      indexToShow = direction !== Direction.NEXT ? firstVisibleIndex - 1 : !this.isLast(lastVisibleIndex) ? lastVisibleIndex + 1 : 0;\n      this._slides.get(indexToHide).active = false;\n      this._slides.get(indexToShow).active = true;\n      /** @type {?} */\n\n      const slidesToReorder = this.mapSlidesAndIndexes().filter(\n      /**\n      * @param {?} slide\n      * @return {?}\n      */\n      slide => slide.item.active);\n      this.makeSlidesConsistent(slidesToReorder);\n      this.slideRangeChange.emit(this.getVisibleIndexes());\n    } else {\n      /** @type {?} */\n      let displayedIndex;\n      firstVisibleIndex = this._slidesWithIndexes[0].index;\n      lastVisibleIndex = this._slidesWithIndexes[this._slidesWithIndexes.length - 1].index;\n\n      if (direction === Direction.NEXT) {\n        this._slidesWithIndexes.shift();\n\n        displayedIndex = this.isLast(lastVisibleIndex) ? 0 : lastVisibleIndex + 1;\n\n        this._slidesWithIndexes.push({\n          index: displayedIndex,\n          item: this._slides.get(displayedIndex)\n        });\n      } else {\n        this._slidesWithIndexes.pop();\n\n        displayedIndex = this.isFirst(firstVisibleIndex) ? this._slides.length - 1 : firstVisibleIndex - 1;\n        this._slidesWithIndexes = [{\n          index: displayedIndex,\n          item: this._slides.get(displayedIndex)\n        }, ...this._slidesWithIndexes];\n      }\n\n      this.hideSlides();\n\n      this._slidesWithIndexes.forEach(\n      /**\n      * @param {?} slide\n      * @return {?}\n      */\n      slide => slide.item.active = true);\n\n      this.makeSlidesConsistent(this._slidesWithIndexes);\n      this.slideRangeChange.emit(this._slidesWithIndexes.map(\n      /**\n      * @param {?} slide\n      * @return {?}\n      */\n      slide => slide.index));\n    }\n  }\n  /**\n   * @private\n   * @param {?} direction\n   * @return {?}\n   */\n\n\n  moveMultilist(direction) {\n    if (this.singleSlideOffset) {\n      this.moveSliderByOneItem(direction);\n    } else {\n      this.hideSlides();\n\n      if (this.noWrap) {\n        this._currentVisibleSlidesIndex = direction === Direction.NEXT ? this._currentVisibleSlidesIndex + 1 : this._currentVisibleSlidesIndex - 1;\n      } else {\n        if (direction === Direction.NEXT) {\n          this._currentVisibleSlidesIndex = this.isVisibleSlideListLast() ? 0 : this._currentVisibleSlidesIndex + 1;\n        } else {\n          this._currentVisibleSlidesIndex = this.isVisibleSlideListFirst() ? this._chunkedSlides.length - 1 : this._currentVisibleSlidesIndex - 1;\n        }\n      }\n\n      this._chunkedSlides[this._currentVisibleSlidesIndex].forEach(\n      /**\n      * @param {?} slide\n      * @return {?}\n      */\n      slide => slide.item.active = true);\n\n      this.slideRangeChange.emit(this.getVisibleIndexes());\n    }\n  }\n  /**\n   * @private\n   * @return {?}\n   */\n\n\n  getVisibleIndexes() {\n    if (!this.singleSlideOffset) {\n      return this._chunkedSlides[this._currentVisibleSlidesIndex].map(\n      /**\n      * @param {?} slide\n      * @return {?}\n      */\n      slide => slide.index);\n    } else {\n      return this._slidesWithIndexes.map(\n      /**\n      * @param {?} slide\n      * @return {?}\n      */\n      slide => slide.index);\n    }\n  }\n  /**\n   * Sets a slide, which specified through index, as active\n   * @private\n   * @param {?} index\n   * @return {?}\n   */\n\n\n  _select(index) {\n    if (isNaN(index)) {\n      this.pause();\n      return;\n    }\n\n    if (!this.multilist) {\n      /** @type {?} */\n      const currentSlide = this._slides.get(this._currentActiveSlide);\n\n      if (currentSlide) {\n        currentSlide.active = false;\n      }\n    }\n    /** @type {?} */\n\n\n    const nextSlide = this._slides.get(index);\n\n    if (nextSlide) {\n      this._currentActiveSlide = index;\n      nextSlide.active = true;\n      this.activeSlide = index;\n      this.activeSlideChange.emit(index);\n    }\n  }\n  /**\n   * Starts loop of auto changing of slides\n   * @private\n   * @return {?}\n   */\n\n\n  restartTimer() {\n    this.resetTimer();\n    /** @type {?} */\n\n    const interval = +this.interval;\n\n    if (!isNaN(interval) && interval > 0) {\n      this.currentInterval = this.ngZone.runOutsideAngular(\n      /**\n      * @return {?}\n      */\n      () => {\n        return setInterval(\n        /**\n        * @return {?}\n        */\n        () => {\n          /** @type {?} */\n          const nInterval = +this.interval;\n          this.ngZone.run(\n          /**\n          * @return {?}\n          */\n          () => {\n            if (this.isPlaying && !isNaN(this.interval) && nInterval > 0 && this.slides.length) {\n              this.nextSlideFromInterval();\n            } else {\n              this.pause();\n            }\n          });\n        }, interval);\n      });\n    }\n  }\n  /**\n   * @return {?}\n   */\n\n\n  get multilist() {\n    return this.itemsPerSlide > 1;\n  }\n  /**\n   * Stops loop of auto changing of slides\n   * @private\n   * @return {?}\n   */\n\n\n  resetTimer() {\n    if (this.currentInterval) {\n      clearInterval(this.currentInterval);\n      this.currentInterval = void 0;\n    }\n  }\n\n}\n\nCarouselComponent.ɵfac = function CarouselComponent_Factory(t) {\n  return new (t || CarouselComponent)(ɵngcc0.ɵɵdirectiveInject(CarouselConfig), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone));\n};\n\nCarouselComponent.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n  type: CarouselComponent,\n  selectors: [[\"carousel\"]],\n  inputs: {\n    indicatorsByChunk: \"indicatorsByChunk\",\n    itemsPerSlide: \"itemsPerSlide\",\n    singleSlideOffset: \"singleSlideOffset\",\n    startFromIndex: \"startFromIndex\",\n    activeSlide: \"activeSlide\",\n    interval: \"interval\",\n    noWrap: \"noWrap\",\n    noPause: \"noPause\",\n    showIndicators: \"showIndicators\",\n    pauseOnFocus: \"pauseOnFocus\"\n  },\n  outputs: {\n    activeSlideChange: \"activeSlideChange\",\n    slideRangeChange: \"slideRangeChange\"\n  },\n  ngContentSelectors: _c1,\n  decls: 6,\n  vars: 6,\n  consts: [[\"tabindex\", \"0\", 1, \"carousel\", \"slide\", 3, \"mouseenter\", \"mouseleave\", \"mouseup\", \"keydown\", \"focusin\", \"focusout\"], [\"class\", \"carousel-indicators\", 4, \"ngIf\"], [1, \"carousel-inner\", 3, \"ngStyle\"], [\"class\", \"left carousel-control carousel-control-prev\", \"tabindex\", \"0\", \"role\", \"button\", 3, \"disabled\", \"click\", 4, \"ngIf\"], [\"class\", \"right carousel-control carousel-control-next\", \"tabindex\", \"0\", \"role\", \"button\", 3, \"disabled\", \"click\", 4, \"ngIf\"], [1, \"carousel-indicators\"], [3, \"active\", \"click\", 4, \"ngFor\", \"ngForOf\"], [3, \"click\"], [\"tabindex\", \"0\", \"role\", \"button\", 1, \"left\", \"carousel-control\", \"carousel-control-prev\", 3, \"click\"], [\"aria-hidden\", \"true\", 1, \"icon-prev\", \"carousel-control-prev-icon\"], [\"class\", \"sr-only\", 4, \"ngIf\"], [1, \"sr-only\"], [\"tabindex\", \"0\", \"role\", \"button\", 1, \"right\", \"carousel-control\", \"carousel-control-next\", 3, \"click\"], [\"aria-hidden\", \"true\", 1, \"icon-next\", \"carousel-control-next-icon\"]],\n  template: function CarouselComponent_Template(rf, ctx) {\n    if (rf & 1) {\n      ɵngcc0.ɵɵprojectionDef();\n      ɵngcc0.ɵɵelementStart(0, \"div\", 0);\n      ɵngcc0.ɵɵlistener(\"mouseenter\", function CarouselComponent_Template_div_mouseenter_0_listener() {\n        return ctx.pause();\n      })(\"mouseleave\", function CarouselComponent_Template_div_mouseleave_0_listener() {\n        return ctx.onMouseLeave();\n      })(\"mouseup\", function CarouselComponent_Template_div_mouseup_0_listener() {\n        return ctx.onMouseUp();\n      })(\"keydown\", function CarouselComponent_Template_div_keydown_0_listener($event) {\n        return ctx.keydownPress($event);\n      })(\"focusin\", function CarouselComponent_Template_div_focusin_0_listener() {\n        return ctx.pauseFocusIn();\n      })(\"focusout\", function CarouselComponent_Template_div_focusout_0_listener() {\n        return ctx.pauseFocusOut();\n      });\n      ɵngcc0.ɵɵtemplate(1, CarouselComponent_ol_1_Template, 2, 1, \"ol\", 1);\n      ɵngcc0.ɵɵelementStart(2, \"div\", 2);\n      ɵngcc0.ɵɵprojection(3);\n      ɵngcc0.ɵɵelementEnd();\n      ɵngcc0.ɵɵtemplate(4, CarouselComponent_a_4_Template, 3, 3, \"a\", 3);\n      ɵngcc0.ɵɵtemplate(5, CarouselComponent_a_5_Template, 4, 2, \"a\", 4);\n      ɵngcc0.ɵɵelementEnd();\n    }\n\n    if (rf & 2) {\n      ɵngcc0.ɵɵadvance(1);\n      ɵngcc0.ɵɵproperty(\"ngIf\", ctx.showIndicators && ctx.slides.length > 1);\n      ɵngcc0.ɵɵadvance(1);\n      ɵngcc0.ɵɵproperty(\"ngStyle\", ɵngcc0.ɵɵpureFunction1(4, _c0, ctx.multilist ? \"flex\" : \"block\"));\n      ɵngcc0.ɵɵadvance(2);\n      ɵngcc0.ɵɵproperty(\"ngIf\", ctx.slides.length > 1);\n      ɵngcc0.ɵɵadvance(1);\n      ɵngcc0.ɵɵproperty(\"ngIf\", ctx.slides.length > 1);\n    }\n  },\n  dependencies: [ɵngcc1.NgForOf, ɵngcc1.NgIf, ɵngcc1.NgStyle],\n  encapsulation: 2\n});\n/** @nocollapse */\n\nCarouselComponent.ctorParameters = () => [{\n  type: CarouselConfig\n}, {\n  type: NgZone\n}];\n\nCarouselComponent.propDecorators = {\n  noWrap: [{\n    type: Input\n  }],\n  noPause: [{\n    type: Input\n  }],\n  showIndicators: [{\n    type: Input\n  }],\n  pauseOnFocus: [{\n    type: Input\n  }],\n  indicatorsByChunk: [{\n    type: Input\n  }],\n  itemsPerSlide: [{\n    type: Input\n  }],\n  singleSlideOffset: [{\n    type: Input\n  }],\n  activeSlideChange: [{\n    type: Output\n  }],\n  slideRangeChange: [{\n    type: Output\n  }],\n  activeSlide: [{\n    type: Input\n  }],\n  startFromIndex: [{\n    type: Input\n  }],\n  interval: [{\n    type: Input\n  }]\n};\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(CarouselComponent, [{\n    type: Component,\n    args: [{\n      selector: 'carousel',\n      template: \"<div (mouseenter)=\\\"pause()\\\" (mouseleave)=\\\"onMouseLeave()\\\" (mouseup)=\\\"onMouseUp()\\\" class=\\\"carousel slide\\\" (keydown)=\\\"keydownPress($event)\\\" (focusin)=\\\"pauseFocusIn()\\\" (focusout)=\\\"pauseFocusOut()\\\" tabindex=\\\"0\\\">\\n  <ol class=\\\"carousel-indicators\\\" *ngIf=\\\"showIndicators && slides.length > 1\\\">\\n    <li *ngFor=\\\"let slidez of indicatorsSlides(); let i = index;\\\" [class.active]=\\\"slidez.active === true\\\" (click)=\\\"selectSlide(i)\\\"></li>\\n  </ol>\\n  <div class=\\\"carousel-inner\\\" [ngStyle]=\\\"{'display': multilist ? 'flex' : 'block'}\\\"><ng-content></ng-content></div>\\n  <a class=\\\"left carousel-control carousel-control-prev\\\" [class.disabled]=\\\"activeSlide === 0 && noWrap\\\" (click)=\\\"previousSlide()\\\" *ngIf=\\\"slides.length > 1\\\"\\n      tabindex=\\\"0\\\" role=\\\"button\\\">\\n    <span class=\\\"icon-prev carousel-control-prev-icon\\\" aria-hidden=\\\"true\\\"></span>\\n    <span *ngIf=\\\"isBs4\\\" class=\\\"sr-only\\\">Previous</span>\\n  </a>\\n  <a class=\\\"right carousel-control carousel-control-next\\\" (click)=\\\"nextSlide()\\\" [class.disabled]=\\\"isLast(activeSlide) && noWrap\\\" *ngIf=\\\"slides.length > 1\\\"\\n     tabindex=\\\"0\\\" role=\\\"button\\\">\\n    <span class=\\\"icon-next carousel-control-next-icon\\\" aria-hidden=\\\"true\\\"></span>\\n    <span class=\\\"sr-only\\\">Next</span>\\n  </a>\\n</div>\\n\"\n    }]\n  }], function () {\n    return [{\n      type: CarouselConfig\n    }, {\n      type: ɵngcc0.NgZone\n    }];\n  }, {\n    indicatorsByChunk: [{\n      type: Input\n    }],\n    itemsPerSlide: [{\n      type: Input\n    }],\n    singleSlideOffset: [{\n      type: Input\n    }],\n    activeSlideChange: [{\n      type: Output\n    }],\n    slideRangeChange: [{\n      type: Output\n    }],\n    startFromIndex: [{\n      type: Input\n    }],\n    activeSlide: [{\n      type: Input\n    }],\n    interval: [{\n      type: Input\n    }],\n    noWrap: [{\n      type: Input\n    }],\n    noPause: [{\n      type: Input\n    }],\n    showIndicators: [{\n      type: Input\n    }],\n    pauseOnFocus: [{\n      type: Input\n    }]\n  });\n})();\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n\nclass SlideComponent {\n  /**\n   * @param {?} carousel\n   */\n  constructor(carousel) {\n    this.itemWidth = '100%';\n    this.order = 0;\n    /**\n     * Wraps element by appropriate CSS classes\n     */\n\n    this.addClass = true;\n    this.carousel = carousel;\n  }\n  /**\n   * Fires changes in container collection after adding a new slide instance\n   * @return {?}\n   */\n\n\n  ngOnInit() {\n    this.carousel.addSlide(this);\n    this.itemWidth = `${100 / this.carousel.itemsPerSlide}%`;\n  }\n  /**\n   * Fires changes in container collection after removing of this slide instance\n   * @return {?}\n   */\n\n\n  ngOnDestroy() {\n    this.carousel.removeSlide(this);\n  }\n\n}\n\nSlideComponent.ɵfac = function SlideComponent_Factory(t) {\n  return new (t || SlideComponent)(ɵngcc0.ɵɵdirectiveInject(CarouselComponent));\n};\n\nSlideComponent.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n  type: SlideComponent,\n  selectors: [[\"slide\"]],\n  hostVars: 11,\n  hostBindings: function SlideComponent_HostBindings(rf, ctx) {\n    if (rf & 2) {\n      ɵngcc0.ɵɵattribute(\"aria-hidden\", !ctx.active);\n      ɵngcc0.ɵɵstyleProp(\"width\", ctx.itemWidth)(\"order\", ctx.order);\n      ɵngcc0.ɵɵclassProp(\"item\", ctx.addClass)(\"carousel-item\", ctx.addClass)(\"active\", ctx.active);\n    }\n  },\n  inputs: {\n    active: \"active\"\n  },\n  ngContentSelectors: _c1,\n  decls: 2,\n  vars: 2,\n  consts: [[1, \"item\"]],\n  template: function SlideComponent_Template(rf, ctx) {\n    if (rf & 1) {\n      ɵngcc0.ɵɵprojectionDef();\n      ɵngcc0.ɵɵelementStart(0, \"div\", 0);\n      ɵngcc0.ɵɵprojection(1);\n      ɵngcc0.ɵɵelementEnd();\n    }\n\n    if (rf & 2) {\n      ɵngcc0.ɵɵclassProp(\"active\", ctx.active);\n    }\n  },\n  encapsulation: 2\n});\n/** @nocollapse */\n\nSlideComponent.ctorParameters = () => [{\n  type: CarouselComponent\n}];\n\nSlideComponent.propDecorators = {\n  active: [{\n    type: HostBinding,\n    args: ['class.active']\n  }, {\n    type: Input\n  }],\n  itemWidth: [{\n    type: HostBinding,\n    args: ['style.width']\n  }],\n  order: [{\n    type: HostBinding,\n    args: ['style.order']\n  }],\n  addClass: [{\n    type: HostBinding,\n    args: ['class.item']\n  }, {\n    type: HostBinding,\n    args: ['class.carousel-item']\n  }]\n};\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(SlideComponent, [{\n    type: Component,\n    args: [{\n      selector: 'slide',\n      template: `\n    <div [class.active]=\"active\" class=\"item\">\n      <ng-content></ng-content>\n    </div>\n  `,\n      host: {\n        '[attr.aria-hidden]': '!active'\n      }\n    }]\n  }], function () {\n    return [{\n      type: CarouselComponent\n    }];\n  }, {\n    itemWidth: [{\n      type: HostBinding,\n      args: ['style.width']\n    }],\n    order: [{\n      type: HostBinding,\n      args: ['style.order']\n    }],\n    addClass: [{\n      type: HostBinding,\n      args: ['class.item']\n    }, {\n      type: HostBinding,\n      args: ['class.carousel-item']\n    }],\n    active: [{\n      type: HostBinding,\n      args: ['class.active']\n    }, {\n      type: Input\n    }]\n  });\n})();\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n\nclass CarouselModule {\n  /**\n   * @return {?}\n   */\n  static forRoot() {\n    return {\n      ngModule: CarouselModule,\n      providers: []\n    };\n  }\n\n}\n\nCarouselModule.ɵfac = function CarouselModule_Factory(t) {\n  return new (t || CarouselModule)();\n};\n\nCarouselModule.ɵmod = /*@__PURE__*/ɵngcc0.ɵɵdefineNgModule({\n  type: CarouselModule\n});\nCarouselModule.ɵinj = /*@__PURE__*/ɵngcc0.ɵɵdefineInjector({\n  providers: [CarouselConfig],\n  imports: [CommonModule]\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(CarouselModule, [{\n    type: NgModule,\n    args: [{\n      imports: [CommonModule],\n      declarations: [SlideComponent, CarouselComponent],\n      exports: [SlideComponent, CarouselComponent],\n      providers: [CarouselConfig]\n    }]\n  }], null, null);\n})();\n\n(function () {\n  (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(CarouselModule, {\n    declarations: function () {\n      return [SlideComponent, CarouselComponent];\n    },\n    imports: function () {\n      return [CommonModule];\n    },\n    exports: function () {\n      return [SlideComponent, CarouselComponent];\n    }\n  });\n})();\n\nexport { CarouselComponent, CarouselConfig, CarouselModule, SlideComponent };","map":{"version":3,"names":["Injectable","EventEmitter","Component","NgZone","Input","Output","HostBinding","NgModule","LinkedList","isBs3","CommonModule","ɵngcc0","ɵngcc1","CarouselComponent_ol_1_li_1_Template","rf","ctx","_r7","ɵɵgetCurrentView","ɵɵelementStart","ɵɵlistener","CarouselComponent_ol_1_li_1_Template_li_click_0_listener","restoredCtx","ɵɵrestoreView","i_r5","index","ctx_r6","ɵɵnextContext","ɵɵresetView","selectSlide","ɵɵelementEnd","slidez_r4","$implicit","ɵɵclassProp","active","CarouselComponent_ol_1_Template","ɵɵtemplate","ctx_r0","ɵɵadvance","ɵɵproperty","indicatorsSlides","CarouselComponent_a_4_span_2_Template","ɵɵtext","CarouselComponent_a_4_Template","_r10","CarouselComponent_a_4_Template_a_click_0_listener","ctx_r9","previousSlide","ɵɵelement","ctx_r1","activeSlide","noWrap","isBs4","CarouselComponent_a_5_Template","_r12","CarouselComponent_a_5_Template_a_click_0_listener","ctx_r11","nextSlide","ctx_r2","isLast","_c0","a0","_c1","CarouselConfig","constructor","interval","noPause","showIndicators","pauseOnFocus","indicatorsByChunk","itemsPerSlide","singleSlideOffset","ɵfac","CarouselConfig_Factory","t","ɵprov","ɵɵdefineInjectable","token","factory","ngDevMode","ɵsetClassMetadata","type","findLastIndex","array","predicate","l","length","chunkByNumber","size","out","n","Math","ceil","i","chunk","splice","push","Direction","UNKNOWN","NEXT","PREV","CarouselComponent","config","ngZone","activeSlideChange","slideRangeChange","startFromIndex","_slides","_currentVisibleSlidesIndex","destroyed","getActive","slide","makeSlidesConsistent","slides","forEach","item","order","Object","assign","multilist","_currentActiveSlide","_select","_interval","value","restartTimer","toArray","ngAfterViewInit","setTimeout","_chunkedSlides","mapSlidesAndIndexes","selectInitialSlides","ngOnDestroy","addSlide","add","undefined","play","removeSlide","remIndex","indexOf","nextSlideIndex","remove","currentSlideIndex","getCurrentSlideIndex","emit","nextSlideFromInterval","force","move","isPlaying","getFirstVisibleIndex","findIndex","getLastVisibleIndex","direction","firstVisibleIndex","lastVisibleIndex","findNextSlideIndex","moveMultilist","keydownPress","event","keyCode","key","preventDefault","onMouseLeave","onMouseUp","pauseFocusIn","resetTimer","pauseFocusOut","selectSlideRange","pause","isFirst","filter","startIndex","hideSlides","_slidesWithIndexes","slidesToAppend","slice","selectRangeByNestedIndex","getVisibleIndexes","Error","map","isIndexInRange","isIndexOnTheEdges","endIndex","selectedRange","slidesList","list","find","visibleIndexes","isVisibleSlideListLast","isVisibleSlideListFirst","moveSliderByOneItem","indexToHide","indexToShow","get","slidesToReorder","displayedIndex","shift","pop","isNaN","currentSlide","currentInterval","runOutsideAngular","setInterval","nInterval","run","clearInterval","CarouselComponent_Factory","ɵɵdirectiveInject","ɵcmp","ɵɵdefineComponent","selectors","inputs","outputs","ngContentSelectors","decls","vars","consts","template","CarouselComponent_Template","ɵɵprojectionDef","CarouselComponent_Template_div_mouseenter_0_listener","CarouselComponent_Template_div_mouseleave_0_listener","CarouselComponent_Template_div_mouseup_0_listener","CarouselComponent_Template_div_keydown_0_listener","$event","CarouselComponent_Template_div_focusin_0_listener","CarouselComponent_Template_div_focusout_0_listener","ɵɵprojection","ɵɵpureFunction1","dependencies","NgForOf","NgIf","NgStyle","encapsulation","ctorParameters","propDecorators","args","selector","SlideComponent","carousel","itemWidth","addClass","ngOnInit","SlideComponent_Factory","hostVars","hostBindings","SlideComponent_HostBindings","ɵɵattribute","ɵɵstyleProp","SlideComponent_Template","host","CarouselModule","forRoot","ngModule","providers","CarouselModule_Factory","ɵmod","ɵɵdefineNgModule","ɵinj","ɵɵdefineInjector","imports","declarations","exports","ngJitMode","ɵɵsetNgModuleScope"],"sources":["D:/APPLICATION/UI/UPL/NEW/node_modules/ngx-bootstrap/__ivy_ngcc__/carousel/fesm2015/ngx-bootstrap-carousel.js"],"sourcesContent":["import { Injectable, EventEmitter, Component, NgZone, Input, Output, HostBinding, NgModule } from '@angular/core';\nimport { LinkedList, isBs3 } from 'ngx-bootstrap/utils';\nimport { CommonModule } from '@angular/common';\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nimport * as ɵngcc0 from '@angular/core';\nimport * as ɵngcc1 from '@angular/common';\n\nfunction CarouselComponent_ol_1_li_1_Template(rf, ctx) { if (rf & 1) {\n    const _r7 = ɵngcc0.ɵɵgetCurrentView();\n    ɵngcc0.ɵɵelementStart(0, \"li\", 7);\n    ɵngcc0.ɵɵlistener(\"click\", function CarouselComponent_ol_1_li_1_Template_li_click_0_listener() { const restoredCtx = ɵngcc0.ɵɵrestoreView(_r7); const i_r5 = restoredCtx.index; const ctx_r6 = ɵngcc0.ɵɵnextContext(2); return ɵngcc0.ɵɵresetView(ctx_r6.selectSlide(i_r5)); });\n    ɵngcc0.ɵɵelementEnd();\n} if (rf & 2) {\n    const slidez_r4 = ctx.$implicit;\n    ɵngcc0.ɵɵclassProp(\"active\", slidez_r4.active === true);\n} }\nfunction CarouselComponent_ol_1_Template(rf, ctx) { if (rf & 1) {\n    ɵngcc0.ɵɵelementStart(0, \"ol\", 5);\n    ɵngcc0.ɵɵtemplate(1, CarouselComponent_ol_1_li_1_Template, 1, 2, \"li\", 6);\n    ɵngcc0.ɵɵelementEnd();\n} if (rf & 2) {\n    const ctx_r0 = ɵngcc0.ɵɵnextContext();\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵproperty(\"ngForOf\", ctx_r0.indicatorsSlides());\n} }\nfunction CarouselComponent_a_4_span_2_Template(rf, ctx) { if (rf & 1) {\n    ɵngcc0.ɵɵelementStart(0, \"span\", 11);\n    ɵngcc0.ɵɵtext(1, \"Previous\");\n    ɵngcc0.ɵɵelementEnd();\n} }\nfunction CarouselComponent_a_4_Template(rf, ctx) { if (rf & 1) {\n    const _r10 = ɵngcc0.ɵɵgetCurrentView();\n    ɵngcc0.ɵɵelementStart(0, \"a\", 8);\n    ɵngcc0.ɵɵlistener(\"click\", function CarouselComponent_a_4_Template_a_click_0_listener() { ɵngcc0.ɵɵrestoreView(_r10); const ctx_r9 = ɵngcc0.ɵɵnextContext(); return ɵngcc0.ɵɵresetView(ctx_r9.previousSlide()); });\n    ɵngcc0.ɵɵelement(1, \"span\", 9);\n    ɵngcc0.ɵɵtemplate(2, CarouselComponent_a_4_span_2_Template, 2, 0, \"span\", 10);\n    ɵngcc0.ɵɵelementEnd();\n} if (rf & 2) {\n    const ctx_r1 = ɵngcc0.ɵɵnextContext();\n    ɵngcc0.ɵɵclassProp(\"disabled\", ctx_r1.activeSlide === 0 && ctx_r1.noWrap);\n    ɵngcc0.ɵɵadvance(2);\n    ɵngcc0.ɵɵproperty(\"ngIf\", ctx_r1.isBs4);\n} }\nfunction CarouselComponent_a_5_Template(rf, ctx) { if (rf & 1) {\n    const _r12 = ɵngcc0.ɵɵgetCurrentView();\n    ɵngcc0.ɵɵelementStart(0, \"a\", 12);\n    ɵngcc0.ɵɵlistener(\"click\", function CarouselComponent_a_5_Template_a_click_0_listener() { ɵngcc0.ɵɵrestoreView(_r12); const ctx_r11 = ɵngcc0.ɵɵnextContext(); return ɵngcc0.ɵɵresetView(ctx_r11.nextSlide()); });\n    ɵngcc0.ɵɵelement(1, \"span\", 13);\n    ɵngcc0.ɵɵelementStart(2, \"span\", 11);\n    ɵngcc0.ɵɵtext(3, \"Next\");\n    ɵngcc0.ɵɵelementEnd()();\n} if (rf & 2) {\n    const ctx_r2 = ɵngcc0.ɵɵnextContext();\n    ɵngcc0.ɵɵclassProp(\"disabled\", ctx_r2.isLast(ctx_r2.activeSlide) && ctx_r2.noWrap);\n} }\nconst _c0 = function (a0) { return { \"display\": a0 }; };\nconst _c1 = [\"*\"];\nclass CarouselConfig {\n    constructor() {\n        /* Default interval of auto changing of slides */\n        this.interval = 5000;\n        /* Is loop of auto changing of slides can be paused */\n        this.noPause = false;\n        /* Is slides can wrap from the last to the first slide */\n        this.noWrap = false;\n        /* Show carousel-indicators */\n        this.showIndicators = true;\n        /* Slides can be paused on focus */\n        this.pauseOnFocus = false;\n        /* If `true` - carousel indicators indicate slides chunks works ONLY if singleSlideOffset = FALSE */\n        this.indicatorsByChunk = false;\n        /* If value more then 1 — carousel works in multilist mode */\n        this.itemsPerSlide = 1;\n        /* If `true` — carousel shifts by one element. By default carousel shifts by number\n            of visible elements (itemsPerSlide field) */\n        this.singleSlideOffset = false;\n    }\n}\nCarouselConfig.ɵfac = function CarouselConfig_Factory(t) { return new (t || CarouselConfig)(); };\nCarouselConfig.ɵprov = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjectable({ token: CarouselConfig, factory: CarouselConfig.ɵfac });\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(CarouselConfig, [{\n        type: Injectable\n    }], function () { return []; }, null); })();\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * Returns the index of the last element in the array where predicate is true, and -1\n * otherwise.\n * @template T\n * @param {?} array The source array to search in\n * @param {?} predicate find calls predicate once for each element of the array, in descending\n * order, until it finds one where predicate returns true. If such an element is found,\n * findLastIndex immediately returns that element index. Otherwise, findLastIndex returns -1.\n * @return {?}\n */\nfunction findLastIndex(array, predicate) {\n    /** @type {?} */\n    let l = array.length;\n    while (l--) {\n        if (predicate(array[l], l, array)) {\n            return l;\n        }\n    }\n    return -1;\n}\n/**\n * @template T\n * @param {?} array\n * @param {?} size\n * @return {?}\n */\nfunction chunkByNumber(array, size) {\n    /** @type {?} */\n    const out = [];\n    /** @type {?} */\n    const n = Math.ceil((array.length) / size);\n    /** @type {?} */\n    let i = 0;\n    while (i < n) {\n        /** @type {?} */\n        const chunk = array.splice(0, (i === n - 1) && size < array.length ? array.length : size);\n        out.push(chunk);\n        i++;\n    }\n    return out;\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/** @enum {number} */\nconst Direction = {\n    UNKNOWN: 0,\n    NEXT: 1,\n    PREV: 2,\n};\nDirection[Direction.UNKNOWN] = 'UNKNOWN';\nDirection[Direction.NEXT] = 'NEXT';\nDirection[Direction.PREV] = 'PREV';\n/**\n * Base element to create carousel\n */\nclass CarouselComponent {\n    /**\n     * @param {?} config\n     * @param {?} ngZone\n     */\n    constructor(config, ngZone) {\n        this.ngZone = ngZone;\n        /* If `true` - carousel indicators indicate slides chunks\n             works ONLY if singleSlideOffset = FALSE */\n        this.indicatorsByChunk = false;\n        /* If value more then 1 — carousel works in multilist mode */\n        this.itemsPerSlide = 1;\n        /* If `true` — carousel shifts by one element. By default carousel shifts by number\n             of visible elements (itemsPerSlide field) */\n        this.singleSlideOffset = false;\n        /**\n         * Will be emitted when active slide has been changed. Part of two-way-bindable [(activeSlide)] property\n         */\n        this.activeSlideChange = new EventEmitter(false);\n        /**\n         * Will be emitted when active slides has been changed in multilist mode\n         */\n        this.slideRangeChange = new EventEmitter();\n        /* Index to start display slides from it */\n        this.startFromIndex = 0;\n        this._slides = new LinkedList();\n        this._currentVisibleSlidesIndex = 0;\n        this.destroyed = false;\n        this.getActive = (/**\n         * @param {?} slide\n         * @return {?}\n         */\n        (slide) => slide.active);\n        this.makeSlidesConsistent = (/**\n         * @param {?} slides\n         * @return {?}\n         */\n        (slides) => {\n            slides.forEach((/**\n             * @param {?} slide\n             * @param {?} index\n             * @return {?}\n             */\n            (slide, index) => slide.item.order = index));\n        });\n        Object.assign(this, config);\n    }\n    /**\n     * Index of currently displayed slide(started for 0)\n     * @param {?} index\n     * @return {?}\n     */\n    set activeSlide(index) {\n        if (this.multilist) {\n            return;\n        }\n        if (this._slides.length && index !== this._currentActiveSlide) {\n            this._select(index);\n        }\n    }\n    /**\n     * @return {?}\n     */\n    get activeSlide() {\n        return this._currentActiveSlide;\n    }\n    /**\n     * Delay of item cycling in milliseconds. If false, carousel won't cycle\n     * automatically.\n     * @return {?}\n     */\n    get interval() {\n        return this._interval;\n    }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n    set interval(value) {\n        this._interval = value;\n        this.restartTimer();\n    }\n    /**\n     * @return {?}\n     */\n    get slides() {\n        return this._slides.toArray();\n    }\n    /**\n     * @return {?}\n     */\n    get isBs4() {\n        return !isBs3();\n    }\n    /**\n     * @return {?}\n     */\n    ngAfterViewInit() {\n        setTimeout((/**\n         * @return {?}\n         */\n        () => {\n            if (this.singleSlideOffset) {\n                this.indicatorsByChunk = false;\n            }\n            if (this.multilist) {\n                this._chunkedSlides = chunkByNumber(this.mapSlidesAndIndexes(), this.itemsPerSlide);\n                this.selectInitialSlides();\n            }\n        }), 0);\n    }\n    /**\n     * @return {?}\n     */\n    ngOnDestroy() {\n        this.destroyed = true;\n    }\n    /**\n     * Adds new slide. If this slide is first in collection - set it as active\n     * and starts auto changing\n     * @param {?} slide\n     * @return {?}\n     */\n    addSlide(slide) {\n        this._slides.add(slide);\n        if (this.multilist && this._slides.length <= this.itemsPerSlide) {\n            slide.active = true;\n        }\n        if (!this.multilist && this._slides.length === 1) {\n            this._currentActiveSlide = undefined;\n            this.activeSlide = 0;\n            this.play();\n        }\n        if (this.multilist && this._slides.length > this.itemsPerSlide) {\n            this.play();\n        }\n    }\n    /**\n     * Removes specified slide. If this slide is active - will roll to another\n     * slide\n     * @param {?} slide\n     * @return {?}\n     */\n    removeSlide(slide) {\n        /** @type {?} */\n        const remIndex = this._slides.indexOf(slide);\n        if (this._currentActiveSlide === remIndex) {\n            // removing of active slide\n            /** @type {?} */\n            let nextSlideIndex = void 0;\n            if (this._slides.length > 1) {\n                // if this slide last - will roll to first slide, if noWrap flag is\n                // FALSE or to previous, if noWrap is TRUE in case, if this slide in\n                // middle of collection, index of next slide is same to removed\n                nextSlideIndex = !this.isLast(remIndex)\n                    ? remIndex\n                    : this.noWrap ? remIndex - 1 : 0;\n            }\n            this._slides.remove(remIndex);\n            // prevents exception with changing some value after checking\n            setTimeout((/**\n             * @return {?}\n             */\n            () => {\n                this._select(nextSlideIndex);\n            }), 0);\n        }\n        else {\n            this._slides.remove(remIndex);\n            /** @type {?} */\n            const currentSlideIndex = this.getCurrentSlideIndex();\n            setTimeout((/**\n             * @return {?}\n             */\n            () => {\n                // after removing, need to actualize index of current active slide\n                this._currentActiveSlide = currentSlideIndex;\n                this.activeSlideChange.emit(this._currentActiveSlide);\n            }), 0);\n        }\n    }\n    /**\n     * @param {?=} force\n     * @return {?}\n     */\n    nextSlideFromInterval(force = false) {\n        this.move(Direction.NEXT, force);\n    }\n    /**\n     * Rolling to next slide\n     * @param {?=} force\n     * @return {?}\n     */\n    nextSlide(force = false) {\n        if (this.isPlaying) {\n            this.restartTimer();\n        }\n        this.move(Direction.NEXT, force);\n    }\n    /**\n     * Rolling to previous slide\n     * @param {?=} force\n     * @return {?}\n     */\n    previousSlide(force = false) {\n        if (this.isPlaying) {\n            this.restartTimer();\n        }\n        this.move(Direction.PREV, force);\n    }\n    /**\n     * @return {?}\n     */\n    getFirstVisibleIndex() {\n        return this.slides.findIndex(this.getActive);\n    }\n    /**\n     * @return {?}\n     */\n    getLastVisibleIndex() {\n        return findLastIndex(this.slides, this.getActive);\n    }\n    /**\n     * @param {?} direction\n     * @param {?=} force\n     * @return {?}\n     */\n    move(direction, force = false) {\n        /** @type {?} */\n        const firstVisibleIndex = this.getFirstVisibleIndex();\n        /** @type {?} */\n        const lastVisibleIndex = this.getLastVisibleIndex();\n        if (this.noWrap) {\n            if (direction === Direction.NEXT &&\n                this.isLast(lastVisibleIndex) ||\n                direction === Direction.PREV &&\n                    firstVisibleIndex === 0) {\n                return;\n            }\n        }\n        if (!this.multilist) {\n            this.activeSlide = this.findNextSlideIndex(direction, force);\n        }\n        else {\n            this.moveMultilist(direction);\n        }\n    }\n    /**\n     * Swith slides by enter, space and arrows keys\n     * \\@internal\n     * @param {?} event\n     * @return {?}\n     */\n    keydownPress(event) {\n        // tslint:disable-next-line:deprecation\n        if (event.keyCode === 13 || event.key === 'Enter' || event.keyCode === 32 || event.key === 'Space') {\n            this.nextSlide();\n            event.preventDefault();\n            return;\n        }\n        // tslint:disable-next-line:deprecation\n        if (event.keyCode === 37 || event.key === 'LeftArrow') {\n            this.previousSlide();\n            return;\n        }\n        // tslint:disable-next-line:deprecation\n        if (event.keyCode === 39 || event.key === 'RightArrow') {\n            this.nextSlide();\n            return;\n        }\n    }\n    /**\n     * Play on mouse leave\n     * \\@internal\n     * @return {?}\n     */\n    onMouseLeave() {\n        if (!this.pauseOnFocus) {\n            this.play();\n        }\n    }\n    /**\n     * Play on mouse up\n     * \\@internal\n     * @return {?}\n     */\n    onMouseUp() {\n        if (!this.pauseOnFocus) {\n            this.play();\n        }\n    }\n    /**\n     * When slides on focus autoplay is stopped(optional)\n     * \\@internal\n     * @return {?}\n     */\n    pauseFocusIn() {\n        if (this.pauseOnFocus) {\n            this.isPlaying = false;\n            this.resetTimer();\n        }\n    }\n    /**\n     * When slides out of focus autoplay is started\n     * \\@internal\n     * @return {?}\n     */\n    pauseFocusOut() {\n        this.play();\n    }\n    /**\n     * Rolling to specified slide\n     * @param {?} index\n     * @return {?}\n     */\n    selectSlide(index) {\n        if (this.isPlaying) {\n            this.restartTimer();\n        }\n        if (!this.multilist) {\n            this.activeSlide = this.indicatorsByChunk ? index * this.itemsPerSlide : index;\n        }\n        else {\n            this.selectSlideRange(this.indicatorsByChunk ? index * this.itemsPerSlide : index);\n        }\n    }\n    /**\n     * Starts a auto changing of slides\n     * @return {?}\n     */\n    play() {\n        if (!this.isPlaying) {\n            this.isPlaying = true;\n            this.restartTimer();\n        }\n    }\n    /**\n     * Stops a auto changing of slides\n     * @return {?}\n     */\n    pause() {\n        if (!this.noPause) {\n            this.isPlaying = false;\n            this.resetTimer();\n        }\n    }\n    /**\n     * Finds and returns index of currently displayed slide\n     * @return {?}\n     */\n    getCurrentSlideIndex() {\n        return this._slides.findIndex(this.getActive);\n    }\n    /**\n     * Defines, whether the specified index is last in collection\n     * @param {?} index\n     * @return {?}\n     */\n    isLast(index) {\n        return index + 1 >= this._slides.length;\n    }\n    /**\n     * Defines, whether the specified index is first in collection\n     * @param {?} index\n     * @return {?}\n     */\n    isFirst(index) {\n        return index === 0;\n    }\n    /**\n     * @return {?}\n     */\n    indicatorsSlides() {\n        return this.slides.filter((/**\n         * @param {?} slide\n         * @param {?} index\n         * @return {?}\n         */\n        (slide, index) => !this.indicatorsByChunk || index % this.itemsPerSlide === 0));\n    }\n    /**\n     * @private\n     * @return {?}\n     */\n    selectInitialSlides() {\n        /** @type {?} */\n        const startIndex = this.startFromIndex <= this._slides.length\n            ? this.startFromIndex\n            : 0;\n        this.hideSlides();\n        if (this.singleSlideOffset) {\n            this._slidesWithIndexes = this.mapSlidesAndIndexes();\n            if (this._slides.length - startIndex < this.itemsPerSlide) {\n                /** @type {?} */\n                const slidesToAppend = this._slidesWithIndexes.slice(0, startIndex);\n                this._slidesWithIndexes = [\n                    ...this._slidesWithIndexes,\n                    ...slidesToAppend\n                ]\n                    .slice(slidesToAppend.length)\n                    .slice(0, this.itemsPerSlide);\n            }\n            else {\n                this._slidesWithIndexes = this._slidesWithIndexes.slice(startIndex, startIndex + this.itemsPerSlide);\n            }\n            this._slidesWithIndexes.forEach((/**\n             * @param {?} slide\n             * @return {?}\n             */\n            (slide) => slide.item.active = true));\n            this.makeSlidesConsistent(this._slidesWithIndexes);\n        }\n        else {\n            this.selectRangeByNestedIndex(startIndex);\n        }\n        this.slideRangeChange.emit(this.getVisibleIndexes());\n    }\n    /**\n     * Defines next slide index, depending of direction\n     * @private\n     * @param {?} direction\n     * @param {?} force\n     * @return {?}\n     */\n    findNextSlideIndex(direction, force) {\n        /** @type {?} */\n        let nextSlideIndex = 0;\n        if (!force &&\n            (this.isLast(this.activeSlide) &&\n                direction !== Direction.PREV &&\n                this.noWrap)) {\n            return undefined;\n        }\n        switch (direction) {\n            case Direction.NEXT:\n                // if this is last slide, not force, looping is disabled\n                // and need to going forward - select current slide, as a next\n                nextSlideIndex = !this.isLast(this._currentActiveSlide)\n                    ? this._currentActiveSlide + 1\n                    : !force && this.noWrap ? this._currentActiveSlide : 0;\n                break;\n            case Direction.PREV:\n                // if this is first slide, not force, looping is disabled\n                // and need to going backward - select current slide, as a next\n                nextSlideIndex =\n                    this._currentActiveSlide > 0\n                        ? this._currentActiveSlide - 1\n                        : !force && this.noWrap\n                            ? this._currentActiveSlide\n                            : this._slides.length - 1;\n                break;\n            default:\n                throw new Error('Unknown direction');\n        }\n        return nextSlideIndex;\n    }\n    /**\n     * @private\n     * @return {?}\n     */\n    mapSlidesAndIndexes() {\n        return this.slides\n            .slice()\n            .map((/**\n         * @param {?} slide\n         * @param {?} index\n         * @return {?}\n         */\n        (slide, index) => {\n            return {\n                index,\n                item: slide\n            };\n        }));\n    }\n    /**\n     * @private\n     * @param {?} index\n     * @return {?}\n     */\n    selectSlideRange(index) {\n        if (this.isIndexInRange(index)) {\n            return;\n        }\n        this.hideSlides();\n        if (!this.singleSlideOffset) {\n            this.selectRangeByNestedIndex(index);\n        }\n        else {\n            /** @type {?} */\n            const startIndex = this.isIndexOnTheEdges(index)\n                ? index\n                : index - this.itemsPerSlide + 1;\n            /** @type {?} */\n            const endIndex = this.isIndexOnTheEdges(index)\n                ? index + this.itemsPerSlide\n                : index + 1;\n            this._slidesWithIndexes = this.mapSlidesAndIndexes().slice(startIndex, endIndex);\n            this.makeSlidesConsistent(this._slidesWithIndexes);\n            this._slidesWithIndexes.forEach((/**\n             * @param {?} slide\n             * @return {?}\n             */\n            (slide) => slide.item.active = true));\n        }\n        this.slideRangeChange.emit(this.getVisibleIndexes());\n    }\n    /**\n     * @private\n     * @param {?} index\n     * @return {?}\n     */\n    selectRangeByNestedIndex(index) {\n        /** @type {?} */\n        const selectedRange = this._chunkedSlides\n            .map((/**\n         * @param {?} slidesList\n         * @param {?} i\n         * @return {?}\n         */\n        (slidesList, i) => {\n            return {\n                index: i,\n                list: slidesList\n            };\n        }))\n            .find((/**\n         * @param {?} slidesList\n         * @return {?}\n         */\n        (slidesList) => {\n            return slidesList.list.find((/**\n             * @param {?} slide\n             * @return {?}\n             */\n            slide => slide.index === index)) !== undefined;\n        }));\n        this._currentVisibleSlidesIndex = selectedRange.index;\n        this._chunkedSlides[selectedRange.index].forEach((/**\n         * @param {?} slide\n         * @return {?}\n         */\n        (slide) => {\n            slide.item.active = true;\n        }));\n    }\n    /**\n     * @private\n     * @param {?} index\n     * @return {?}\n     */\n    isIndexOnTheEdges(index) {\n        return (index + 1 - this.itemsPerSlide <= 0 ||\n            index + this.itemsPerSlide <= this._slides.length);\n    }\n    /**\n     * @private\n     * @param {?} index\n     * @return {?}\n     */\n    isIndexInRange(index) {\n        if (this.singleSlideOffset) {\n            /** @type {?} */\n            const visibleIndexes = this._slidesWithIndexes.map((/**\n             * @param {?} slide\n             * @return {?}\n             */\n            (slide) => slide.index));\n            return visibleIndexes.indexOf(index) >= 0;\n        }\n        return (index <= this.getLastVisibleIndex() &&\n            index >= this.getFirstVisibleIndex());\n    }\n    /**\n     * @private\n     * @return {?}\n     */\n    hideSlides() {\n        this.slides.forEach((/**\n         * @param {?} slide\n         * @return {?}\n         */\n        (slide) => slide.active = false));\n    }\n    /**\n     * @private\n     * @return {?}\n     */\n    isVisibleSlideListLast() {\n        return this._currentVisibleSlidesIndex === this._chunkedSlides.length - 1;\n    }\n    /**\n     * @private\n     * @return {?}\n     */\n    isVisibleSlideListFirst() {\n        return this._currentVisibleSlidesIndex === 0;\n    }\n    /**\n     * @private\n     * @param {?} direction\n     * @return {?}\n     */\n    moveSliderByOneItem(direction) {\n        /** @type {?} */\n        let firstVisibleIndex;\n        /** @type {?} */\n        let lastVisibleIndex;\n        /** @type {?} */\n        let indexToHide;\n        /** @type {?} */\n        let indexToShow;\n        if (this.noWrap) {\n            firstVisibleIndex = this.getFirstVisibleIndex();\n            lastVisibleIndex = this.getLastVisibleIndex();\n            indexToHide = direction === Direction.NEXT\n                ? firstVisibleIndex\n                : lastVisibleIndex;\n            indexToShow = direction !== Direction.NEXT\n                ? firstVisibleIndex - 1\n                : !this.isLast(lastVisibleIndex)\n                    ? lastVisibleIndex + 1 : 0;\n            this._slides.get(indexToHide).active = false;\n            this._slides.get(indexToShow).active = true;\n            /** @type {?} */\n            const slidesToReorder = this.mapSlidesAndIndexes().filter((/**\n             * @param {?} slide\n             * @return {?}\n             */\n            (slide) => slide.item.active));\n            this.makeSlidesConsistent(slidesToReorder);\n            this.slideRangeChange.emit(this.getVisibleIndexes());\n        }\n        else {\n            /** @type {?} */\n            let displayedIndex;\n            firstVisibleIndex = this._slidesWithIndexes[0].index;\n            lastVisibleIndex = this._slidesWithIndexes[this._slidesWithIndexes.length - 1].index;\n            if (direction === Direction.NEXT) {\n                this._slidesWithIndexes.shift();\n                displayedIndex = this.isLast(lastVisibleIndex)\n                    ? 0\n                    : lastVisibleIndex + 1;\n                this._slidesWithIndexes.push({\n                    index: displayedIndex,\n                    item: this._slides.get(displayedIndex)\n                });\n            }\n            else {\n                this._slidesWithIndexes.pop();\n                displayedIndex = this.isFirst(firstVisibleIndex)\n                    ? this._slides.length - 1\n                    : firstVisibleIndex - 1;\n                this._slidesWithIndexes = [{\n                        index: displayedIndex,\n                        item: this._slides.get(displayedIndex)\n                    }, ...this._slidesWithIndexes];\n            }\n            this.hideSlides();\n            this._slidesWithIndexes.forEach((/**\n             * @param {?} slide\n             * @return {?}\n             */\n            slide => slide.item.active = true));\n            this.makeSlidesConsistent(this._slidesWithIndexes);\n            this.slideRangeChange.emit(this._slidesWithIndexes.map((/**\n             * @param {?} slide\n             * @return {?}\n             */\n            (slide) => slide.index)));\n        }\n    }\n    /**\n     * @private\n     * @param {?} direction\n     * @return {?}\n     */\n    moveMultilist(direction) {\n        if (this.singleSlideOffset) {\n            this.moveSliderByOneItem(direction);\n        }\n        else {\n            this.hideSlides();\n            if (this.noWrap) {\n                this._currentVisibleSlidesIndex = direction === Direction.NEXT\n                    ? this._currentVisibleSlidesIndex + 1\n                    : this._currentVisibleSlidesIndex - 1;\n            }\n            else {\n                if (direction === Direction.NEXT) {\n                    this._currentVisibleSlidesIndex = this.isVisibleSlideListLast()\n                        ? 0\n                        : this._currentVisibleSlidesIndex + 1;\n                }\n                else {\n                    this._currentVisibleSlidesIndex = this.isVisibleSlideListFirst()\n                        ? this._chunkedSlides.length - 1\n                        : this._currentVisibleSlidesIndex - 1;\n                }\n            }\n            this._chunkedSlides[this._currentVisibleSlidesIndex].forEach((/**\n             * @param {?} slide\n             * @return {?}\n             */\n            (slide) => slide.item.active = true));\n            this.slideRangeChange.emit(this.getVisibleIndexes());\n        }\n    }\n    /**\n     * @private\n     * @return {?}\n     */\n    getVisibleIndexes() {\n        if (!this.singleSlideOffset) {\n            return this._chunkedSlides[this._currentVisibleSlidesIndex]\n                .map((/**\n             * @param {?} slide\n             * @return {?}\n             */\n            (slide) => slide.index));\n        }\n        else {\n            return this._slidesWithIndexes.map((/**\n             * @param {?} slide\n             * @return {?}\n             */\n            (slide) => slide.index));\n        }\n    }\n    /**\n     * Sets a slide, which specified through index, as active\n     * @private\n     * @param {?} index\n     * @return {?}\n     */\n    _select(index) {\n        if (isNaN(index)) {\n            this.pause();\n            return;\n        }\n        if (!this.multilist) {\n            /** @type {?} */\n            const currentSlide = this._slides.get(this._currentActiveSlide);\n            if (currentSlide) {\n                currentSlide.active = false;\n            }\n        }\n        /** @type {?} */\n        const nextSlide = this._slides.get(index);\n        if (nextSlide) {\n            this._currentActiveSlide = index;\n            nextSlide.active = true;\n            this.activeSlide = index;\n            this.activeSlideChange.emit(index);\n        }\n    }\n    /**\n     * Starts loop of auto changing of slides\n     * @private\n     * @return {?}\n     */\n    restartTimer() {\n        this.resetTimer();\n        /** @type {?} */\n        const interval = +this.interval;\n        if (!isNaN(interval) && interval > 0) {\n            this.currentInterval = this.ngZone.runOutsideAngular((/**\n             * @return {?}\n             */\n            () => {\n                return setInterval((/**\n                 * @return {?}\n                 */\n                () => {\n                    /** @type {?} */\n                    const nInterval = +this.interval;\n                    this.ngZone.run((/**\n                     * @return {?}\n                     */\n                    () => {\n                        if (this.isPlaying &&\n                            !isNaN(this.interval) &&\n                            nInterval > 0 &&\n                            this.slides.length) {\n                            this.nextSlideFromInterval();\n                        }\n                        else {\n                            this.pause();\n                        }\n                    }));\n                }), interval);\n            }));\n        }\n    }\n    /**\n     * @return {?}\n     */\n    get multilist() {\n        return this.itemsPerSlide > 1;\n    }\n    /**\n     * Stops loop of auto changing of slides\n     * @private\n     * @return {?}\n     */\n    resetTimer() {\n        if (this.currentInterval) {\n            clearInterval(this.currentInterval);\n            this.currentInterval = void 0;\n        }\n    }\n}\nCarouselComponent.ɵfac = function CarouselComponent_Factory(t) { return new (t || CarouselComponent)(ɵngcc0.ɵɵdirectiveInject(CarouselConfig), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone)); };\nCarouselComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: CarouselComponent, selectors: [[\"carousel\"]], inputs: { indicatorsByChunk: \"indicatorsByChunk\", itemsPerSlide: \"itemsPerSlide\", singleSlideOffset: \"singleSlideOffset\", startFromIndex: \"startFromIndex\", activeSlide: \"activeSlide\", interval: \"interval\", noWrap: \"noWrap\", noPause: \"noPause\", showIndicators: \"showIndicators\", pauseOnFocus: \"pauseOnFocus\" }, outputs: { activeSlideChange: \"activeSlideChange\", slideRangeChange: \"slideRangeChange\" }, ngContentSelectors: _c1, decls: 6, vars: 6, consts: [[\"tabindex\", \"0\", 1, \"carousel\", \"slide\", 3, \"mouseenter\", \"mouseleave\", \"mouseup\", \"keydown\", \"focusin\", \"focusout\"], [\"class\", \"carousel-indicators\", 4, \"ngIf\"], [1, \"carousel-inner\", 3, \"ngStyle\"], [\"class\", \"left carousel-control carousel-control-prev\", \"tabindex\", \"0\", \"role\", \"button\", 3, \"disabled\", \"click\", 4, \"ngIf\"], [\"class\", \"right carousel-control carousel-control-next\", \"tabindex\", \"0\", \"role\", \"button\", 3, \"disabled\", \"click\", 4, \"ngIf\"], [1, \"carousel-indicators\"], [3, \"active\", \"click\", 4, \"ngFor\", \"ngForOf\"], [3, \"click\"], [\"tabindex\", \"0\", \"role\", \"button\", 1, \"left\", \"carousel-control\", \"carousel-control-prev\", 3, \"click\"], [\"aria-hidden\", \"true\", 1, \"icon-prev\", \"carousel-control-prev-icon\"], [\"class\", \"sr-only\", 4, \"ngIf\"], [1, \"sr-only\"], [\"tabindex\", \"0\", \"role\", \"button\", 1, \"right\", \"carousel-control\", \"carousel-control-next\", 3, \"click\"], [\"aria-hidden\", \"true\", 1, \"icon-next\", \"carousel-control-next-icon\"]], template: function CarouselComponent_Template(rf, ctx) { if (rf & 1) {\n        ɵngcc0.ɵɵprojectionDef();\n        ɵngcc0.ɵɵelementStart(0, \"div\", 0);\n        ɵngcc0.ɵɵlistener(\"mouseenter\", function CarouselComponent_Template_div_mouseenter_0_listener() { return ctx.pause(); })(\"mouseleave\", function CarouselComponent_Template_div_mouseleave_0_listener() { return ctx.onMouseLeave(); })(\"mouseup\", function CarouselComponent_Template_div_mouseup_0_listener() { return ctx.onMouseUp(); })(\"keydown\", function CarouselComponent_Template_div_keydown_0_listener($event) { return ctx.keydownPress($event); })(\"focusin\", function CarouselComponent_Template_div_focusin_0_listener() { return ctx.pauseFocusIn(); })(\"focusout\", function CarouselComponent_Template_div_focusout_0_listener() { return ctx.pauseFocusOut(); });\n        ɵngcc0.ɵɵtemplate(1, CarouselComponent_ol_1_Template, 2, 1, \"ol\", 1);\n        ɵngcc0.ɵɵelementStart(2, \"div\", 2);\n        ɵngcc0.ɵɵprojection(3);\n        ɵngcc0.ɵɵelementEnd();\n        ɵngcc0.ɵɵtemplate(4, CarouselComponent_a_4_Template, 3, 3, \"a\", 3);\n        ɵngcc0.ɵɵtemplate(5, CarouselComponent_a_5_Template, 4, 2, \"a\", 4);\n        ɵngcc0.ɵɵelementEnd();\n    } if (rf & 2) {\n        ɵngcc0.ɵɵadvance(1);\n        ɵngcc0.ɵɵproperty(\"ngIf\", ctx.showIndicators && ctx.slides.length > 1);\n        ɵngcc0.ɵɵadvance(1);\n        ɵngcc0.ɵɵproperty(\"ngStyle\", ɵngcc0.ɵɵpureFunction1(4, _c0, ctx.multilist ? \"flex\" : \"block\"));\n        ɵngcc0.ɵɵadvance(2);\n        ɵngcc0.ɵɵproperty(\"ngIf\", ctx.slides.length > 1);\n        ɵngcc0.ɵɵadvance(1);\n        ɵngcc0.ɵɵproperty(\"ngIf\", ctx.slides.length > 1);\n    } }, dependencies: [ɵngcc1.NgForOf, ɵngcc1.NgIf, ɵngcc1.NgStyle], encapsulation: 2 });\n/** @nocollapse */\nCarouselComponent.ctorParameters = () => [\n    { type: CarouselConfig },\n    { type: NgZone }\n];\nCarouselComponent.propDecorators = {\n    noWrap: [{ type: Input }],\n    noPause: [{ type: Input }],\n    showIndicators: [{ type: Input }],\n    pauseOnFocus: [{ type: Input }],\n    indicatorsByChunk: [{ type: Input }],\n    itemsPerSlide: [{ type: Input }],\n    singleSlideOffset: [{ type: Input }],\n    activeSlideChange: [{ type: Output }],\n    slideRangeChange: [{ type: Output }],\n    activeSlide: [{ type: Input }],\n    startFromIndex: [{ type: Input }],\n    interval: [{ type: Input }]\n};\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(CarouselComponent, [{\n        type: Component,\n        args: [{\n                selector: 'carousel',\n                template: \"<div (mouseenter)=\\\"pause()\\\" (mouseleave)=\\\"onMouseLeave()\\\" (mouseup)=\\\"onMouseUp()\\\" class=\\\"carousel slide\\\" (keydown)=\\\"keydownPress($event)\\\" (focusin)=\\\"pauseFocusIn()\\\" (focusout)=\\\"pauseFocusOut()\\\" tabindex=\\\"0\\\">\\n  <ol class=\\\"carousel-indicators\\\" *ngIf=\\\"showIndicators && slides.length > 1\\\">\\n    <li *ngFor=\\\"let slidez of indicatorsSlides(); let i = index;\\\" [class.active]=\\\"slidez.active === true\\\" (click)=\\\"selectSlide(i)\\\"></li>\\n  </ol>\\n  <div class=\\\"carousel-inner\\\" [ngStyle]=\\\"{'display': multilist ? 'flex' : 'block'}\\\"><ng-content></ng-content></div>\\n  <a class=\\\"left carousel-control carousel-control-prev\\\" [class.disabled]=\\\"activeSlide === 0 && noWrap\\\" (click)=\\\"previousSlide()\\\" *ngIf=\\\"slides.length > 1\\\"\\n      tabindex=\\\"0\\\" role=\\\"button\\\">\\n    <span class=\\\"icon-prev carousel-control-prev-icon\\\" aria-hidden=\\\"true\\\"></span>\\n    <span *ngIf=\\\"isBs4\\\" class=\\\"sr-only\\\">Previous</span>\\n  </a>\\n  <a class=\\\"right carousel-control carousel-control-next\\\" (click)=\\\"nextSlide()\\\" [class.disabled]=\\\"isLast(activeSlide) && noWrap\\\" *ngIf=\\\"slides.length > 1\\\"\\n     tabindex=\\\"0\\\" role=\\\"button\\\">\\n    <span class=\\\"icon-next carousel-control-next-icon\\\" aria-hidden=\\\"true\\\"></span>\\n    <span class=\\\"sr-only\\\">Next</span>\\n  </a>\\n</div>\\n\"\n            }]\n    }], function () { return [{ type: CarouselConfig }, { type: ɵngcc0.NgZone }]; }, { indicatorsByChunk: [{\n            type: Input\n        }], itemsPerSlide: [{\n            type: Input\n        }], singleSlideOffset: [{\n            type: Input\n        }], activeSlideChange: [{\n            type: Output\n        }], slideRangeChange: [{\n            type: Output\n        }], startFromIndex: [{\n            type: Input\n        }], activeSlide: [{\n            type: Input\n        }], interval: [{\n            type: Input\n        }], noWrap: [{\n            type: Input\n        }], noPause: [{\n            type: Input\n        }], showIndicators: [{\n            type: Input\n        }], pauseOnFocus: [{\n            type: Input\n        }] }); })();\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nclass SlideComponent {\n    /**\n     * @param {?} carousel\n     */\n    constructor(carousel) {\n        this.itemWidth = '100%';\n        this.order = 0;\n        /**\n         * Wraps element by appropriate CSS classes\n         */\n        this.addClass = true;\n        this.carousel = carousel;\n    }\n    /**\n     * Fires changes in container collection after adding a new slide instance\n     * @return {?}\n     */\n    ngOnInit() {\n        this.carousel.addSlide(this);\n        this.itemWidth = `${100 / this.carousel.itemsPerSlide}%`;\n    }\n    /**\n     * Fires changes in container collection after removing of this slide instance\n     * @return {?}\n     */\n    ngOnDestroy() {\n        this.carousel.removeSlide(this);\n    }\n}\nSlideComponent.ɵfac = function SlideComponent_Factory(t) { return new (t || SlideComponent)(ɵngcc0.ɵɵdirectiveInject(CarouselComponent)); };\nSlideComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: SlideComponent, selectors: [[\"slide\"]], hostVars: 11, hostBindings: function SlideComponent_HostBindings(rf, ctx) { if (rf & 2) {\n        ɵngcc0.ɵɵattribute(\"aria-hidden\", !ctx.active);\n        ɵngcc0.ɵɵstyleProp(\"width\", ctx.itemWidth)(\"order\", ctx.order);\n        ɵngcc0.ɵɵclassProp(\"item\", ctx.addClass)(\"carousel-item\", ctx.addClass)(\"active\", ctx.active);\n    } }, inputs: { active: \"active\" }, ngContentSelectors: _c1, decls: 2, vars: 2, consts: [[1, \"item\"]], template: function SlideComponent_Template(rf, ctx) { if (rf & 1) {\n        ɵngcc0.ɵɵprojectionDef();\n        ɵngcc0.ɵɵelementStart(0, \"div\", 0);\n        ɵngcc0.ɵɵprojection(1);\n        ɵngcc0.ɵɵelementEnd();\n    } if (rf & 2) {\n        ɵngcc0.ɵɵclassProp(\"active\", ctx.active);\n    } }, encapsulation: 2 });\n/** @nocollapse */\nSlideComponent.ctorParameters = () => [\n    { type: CarouselComponent }\n];\nSlideComponent.propDecorators = {\n    active: [{ type: HostBinding, args: ['class.active',] }, { type: Input }],\n    itemWidth: [{ type: HostBinding, args: ['style.width',] }],\n    order: [{ type: HostBinding, args: ['style.order',] }],\n    addClass: [{ type: HostBinding, args: ['class.item',] }, { type: HostBinding, args: ['class.carousel-item',] }]\n};\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(SlideComponent, [{\n        type: Component,\n        args: [{\n                selector: 'slide',\n                template: `\n    <div [class.active]=\"active\" class=\"item\">\n      <ng-content></ng-content>\n    </div>\n  `,\n                host: {\n                    '[attr.aria-hidden]': '!active'\n                }\n            }]\n    }], function () { return [{ type: CarouselComponent }]; }, { itemWidth: [{\n            type: HostBinding,\n            args: ['style.width']\n        }], order: [{\n            type: HostBinding,\n            args: ['style.order']\n        }], addClass: [{\n            type: HostBinding,\n            args: ['class.item']\n        }, {\n            type: HostBinding,\n            args: ['class.carousel-item']\n        }], active: [{\n            type: HostBinding,\n            args: ['class.active']\n        }, {\n            type: Input\n        }] }); })();\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nclass CarouselModule {\n    /**\n     * @return {?}\n     */\n    static forRoot() {\n        return { ngModule: CarouselModule, providers: [] };\n    }\n}\nCarouselModule.ɵfac = function CarouselModule_Factory(t) { return new (t || CarouselModule)(); };\nCarouselModule.ɵmod = /*@__PURE__*/ ɵngcc0.ɵɵdefineNgModule({ type: CarouselModule });\nCarouselModule.ɵinj = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjector({ providers: [CarouselConfig], imports: [CommonModule] });\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(CarouselModule, [{\n        type: NgModule,\n        args: [{\n                imports: [CommonModule],\n                declarations: [SlideComponent, CarouselComponent],\n                exports: [SlideComponent, CarouselComponent],\n                providers: [CarouselConfig]\n            }]\n    }], null, null); })();\n(function () { (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(CarouselModule, { declarations: function () { return [SlideComponent, CarouselComponent]; }, imports: function () { return [CommonModule]; }, exports: function () { return [SlideComponent, CarouselComponent]; } }); })();\n\nexport { CarouselComponent, CarouselConfig, CarouselModule, SlideComponent };\n\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}