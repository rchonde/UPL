{"ast":null,"code":"/**\r\n * HeatLegend module\r\n */\nimport { __extends } from \"tslib\";\n/**\r\n * ============================================================================\r\n * IMPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\n\nimport { Container } from \"../../core/Container\";\nimport { LinearGradient } from \"../../core/rendering/fills/LinearGradient\";\nimport { registry } from \"../../core/Registry\";\nimport { toColor, Color } from \"../../core/utils/Color\";\nimport { ListTemplate, ListDisposer } from \"../../core/utils/List\";\nimport { percent } from \"../../core/utils/Percent\";\nimport { ValueAxis } from \"../../charts/axes/ValueAxis\";\nimport { AxisRendererX } from \"../../charts/axes/AxisRendererX\";\nimport { AxisRendererY } from \"../../charts/axes/AxisRendererY\";\nimport * as $iter from \"../../core/utils/Iterator\";\nimport * as $type from \"../../core/utils/Type\";\nimport * as $colors from \"../../core/utils/Colors\";\nimport { RoundedRectangle } from \"../../core/elements/RoundedRectangle\";\n/**\r\n * ============================================================================\r\n * MAIN CLASS\r\n * ============================================================================\r\n * @hidden\r\n */\n\n/**\r\n * This class creates a link (waved color-filled line) between two nodes in a\r\n * Sankey Diagram.\r\n *\r\n * @see {@link IHeatLegendEvents} for a list of available events\r\n * @see {@link IHeatLegendAdapters} for a list of available Adapters\r\n * @important\r\n */\n\nvar HeatLegend =\n/** @class */\nfunction (_super) {\n  __extends(HeatLegend, _super);\n  /**\r\n   * Constructor\r\n   */\n\n\n  function HeatLegend() {\n    var _this = _super.call(this) || this;\n\n    _this.className = \"HeatLegend\";\n    _this.markerContainer = _this.createChild(Container);\n    _this.markerContainer.shouldClone = false;\n    _this.markerCount = 1; // Create a template container and list for the a marker\n\n    var marker = new RoundedRectangle();\n    marker.minHeight = 20;\n    marker.minWidth = 20;\n    marker.interactionsEnabled = false;\n    marker.fillOpacity = 1;\n    marker.cornerRadius(0, 0, 0, 0);\n    _this.markerContainer.minHeight = 20;\n    _this.markerContainer.minWidth = 20;\n    _this.orientation = \"horizontal\";\n    _this.markers = new ListTemplate(marker);\n\n    _this._disposers.push(new ListDisposer(_this.markers));\n\n    _this._disposers.push(_this.markers.template);\n\n    _this.applyTheme();\n\n    return _this;\n  }\n\n  HeatLegend.prototype.getMinFromRules = function (property) {\n    var series = this.series;\n\n    if (series) {\n      var minValue_1;\n      $iter.eachContinue(series.heatRules.iterator(), function (heatRule) {\n        if (heatRule.property == property) {\n          minValue_1 = heatRule.min;\n          return false;\n        }\n\n        return true;\n      });\n      return minValue_1;\n    }\n  };\n\n  HeatLegend.prototype.getMaxFromRules = function (property) {\n    var series = this.series;\n\n    if (series) {\n      var maxValue_1;\n      $iter.each(series.heatRules.iterator(), function (heatRule) {\n        if (heatRule.property == property) {\n          maxValue_1 = heatRule.max;\n          return false;\n        }\n\n        return true;\n      });\n      return maxValue_1;\n    }\n  };\n  /**\r\n   *\r\n   * @ignore Exclude from docs\r\n   */\n\n\n  HeatLegend.prototype.validate = function () {\n    _super.prototype.validate.call(this);\n\n    this.valueAxis.renderer.inversed = this.reverseOrder;\n    var series = this.series;\n    var minColor = this.minColor;\n    var maxColor = this.maxColor;\n\n    if (!$type.hasValue(minColor)) {\n      minColor = toColor(this.getMinFromRules(\"fill\"));\n    }\n\n    if (!$type.hasValue(maxColor)) {\n      maxColor = toColor(this.getMaxFromRules(\"fill\"));\n    }\n\n    if (series) {\n      var seriesFill = series.fill;\n\n      if (!$type.hasValue(minColor) && seriesFill instanceof Color) {\n        minColor = seriesFill;\n      }\n\n      if (!$type.hasValue(maxColor) && seriesFill instanceof Color) {\n        maxColor = seriesFill;\n      }\n    }\n\n    if (!$type.hasValue(maxColor)) {\n      maxColor = toColor(this.getMaxFromRules(\"fill\"));\n    }\n\n    var minOpacity = $type.toNumber(this.getMinFromRules(\"fillOpacity\"));\n\n    if (!$type.isNumber(minOpacity)) {\n      minOpacity = 1;\n    }\n\n    var maxOpacity = $type.toNumber(this.getMaxFromRules(\"fillOpacity\"));\n\n    if (!$type.isNumber(maxOpacity)) {\n      maxOpacity = 1;\n    }\n\n    var minStrokeOpacity = $type.toNumber(this.getMinFromRules(\"strokeOpacity\"));\n\n    if (!$type.isNumber(minStrokeOpacity)) {\n      minStrokeOpacity = 1;\n    }\n\n    var maxStrokeOpacity = $type.toNumber(this.getMaxFromRules(\"strokeOpacity\"));\n\n    if (!$type.isNumber(maxStrokeOpacity)) {\n      maxStrokeOpacity = 1;\n    }\n\n    var minStroke = toColor(this.getMinFromRules(\"stroke\"));\n    var maxStroke = toColor(this.getMaxFromRules(\"stroke\")); //if (series) {\n\n    for (var i = 0; i < this.markerCount; i++) {\n      var marker = this.markers.getIndex(i);\n\n      if (!marker) {\n        marker = this.markers.create();\n        marker.parent = this.markerContainer;\n        marker.height = percent(100);\n        marker.width = percent(100);\n      }\n\n      if (this.markerCount == 1) {\n        var gradient = new LinearGradient();\n\n        if (this.reverseOrder) {\n          gradient.addColor(maxColor, maxOpacity);\n          gradient.addColor(minColor, minOpacity);\n        } else {\n          gradient.addColor(minColor, minOpacity);\n          gradient.addColor(maxColor, maxOpacity);\n        }\n\n        if (this.orientation == \"vertical\") {\n          gradient.rotation = -90;\n        }\n\n        marker.fill = gradient;\n\n        if ($type.hasValue(minStroke) && $type.hasValue(maxStroke)) {\n          var strokeGradient = new LinearGradient();\n\n          if (this.reverseOrder) {\n            strokeGradient.addColor(maxStroke, maxStrokeOpacity);\n            strokeGradient.addColor(minStroke, minStrokeOpacity);\n          } else {\n            strokeGradient.addColor(minStroke, minStrokeOpacity);\n            strokeGradient.addColor(maxStroke, maxStrokeOpacity);\n          }\n\n          if (this.orientation == \"vertical\") {\n            strokeGradient.rotation = -90;\n          }\n\n          marker.stroke = strokeGradient;\n        }\n      } else {\n        var c = i;\n\n        if (this.reverseOrder) {\n          c = this.markerCount - i - 1;\n        }\n\n        var color = new Color($colors.interpolate(minColor.rgb, maxColor.rgb, c / this.markerCount));\n        marker.fill = color;\n        var opacity = minOpacity + (maxOpacity - minOpacity) * c / this.markerCount;\n        marker.fillOpacity = opacity;\n\n        if ($type.hasValue(minStroke) && $type.hasValue(maxStroke)) {\n          var color_1 = new Color($colors.interpolate(minStroke.rgb, maxStroke.rgb, c / this.markerCount));\n          marker.stroke = color_1;\n          var opacity_1 = minStrokeOpacity + (maxStrokeOpacity - minStrokeOpacity) * c / this.markerCount;\n          marker.strokeOpacity = opacity_1;\n        }\n      }\n    }\n\n    var renderer = this.valueAxis.renderer;\n\n    if (this.markerCount > 1) {\n      if (this.orientation == \"horizontal\") {\n        renderer.minGridDistance = this.measuredWidth / this.markerCount;\n      } else {\n        renderer.minGridDistance = this.measuredHeight / this.markerCount;\n      }\n    }\n\n    this.valueAxis.invalidate();\n\n    for (var i = this.markerCount, len = this.markers.length; i < len; i++) {\n      this.markers.getIndex(i).parent = undefined;\n    }\n  };\n\n  Object.defineProperty(HeatLegend.prototype, \"minColor\", {\n    /**\r\n     * Returns minColor value\r\n     * @return {Color}\r\n     */\n    get: function () {\n      return this.getPropertyValue(\"minColor\");\n    },\n\n    /**\r\n     * Min color of a heat legend. If a series is set for the legend, minColor is taken from series.\r\n     *\r\n     * @param {Color}\r\n     */\n    set: function (value) {\n      if (!(value instanceof Color)) {\n        value = toColor(value);\n      }\n\n      this.setColorProperty(\"minColor\", value, true);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(HeatLegend.prototype, \"maxColor\", {\n    /**\r\n     * Returns maxColor value\r\n     * @return {Color}\r\n     */\n    get: function () {\n      return this.getPropertyValue(\"maxColor\");\n    },\n\n    /**\r\n     * Max color of a heat legend. If a series is set for the legend, maxColor is taken from series.\r\n     *\r\n     * @param {Color}\r\n     */\n    set: function (value) {\n      if (!(value instanceof Color)) {\n        value = toColor(value);\n      }\n\n      this.setColorProperty(\"maxColor\", value, true);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(HeatLegend.prototype, \"markerCount\", {\n    /**\r\n     * Returns number of color squares (markers).\r\n     * @return {number}\r\n     */\n    get: function () {\n      return this.getPropertyValue(\"markerCount\");\n    },\n\n    /**\r\n     * Number of color squares (markers) in the heat legend. If only 1 marker is used, it will be filled with gradient.\r\n     *\r\n     * @param {number}\r\n     */\n    set: function (value) {\n      this.setPropertyValue(\"markerCount\", value, true);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(HeatLegend.prototype, \"minValue\", {\n    /**\r\n     * Returns minimum value of heat legend.\r\n     * @return {number}\r\n     */\n    get: function () {\n      return this.getPropertyValue(\"minValue\");\n    },\n\n    /**\r\n     * Minimum value of heat legend's value axis. If a series is set for the legend, min is taken from series.\r\n     *\r\n     * @param {number}\r\n     */\n    set: function (value) {\n      this.setPropertyValue(\"minValue\", value);\n      this.valueAxis.min = value;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(HeatLegend.prototype, \"maxValue\", {\n    /**\r\n     * Returns maximum value of heat legend.\r\n     * @return {number}\r\n     */\n    get: function () {\n      return this.getPropertyValue(\"maxValue\");\n    },\n\n    /**\r\n     * Maximum value of heat legend's value axis. If a series is set for the legend, max is taken from series.\r\n     *\r\n     * @param {number}\r\n     */\n    set: function (value) {\n      this.setPropertyValue(\"maxValue\", value);\n      this.valueAxis.max = value;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(HeatLegend.prototype, \"orientation\", {\n    /**\r\n     * Returns orientation value.\r\n     *\r\n     * @return {\"horizontal\" | \"vertical\"}\r\n     */\n    get: function () {\n      return this.getPropertyValue(\"orientation\");\n    },\n\n    /**\r\n    * Heat legend orientation. Note, if you change orientation of a heat legend, you must set value axis renderer properties after that, as with orientation renderer changes.\r\n    *\r\n    * @param {\"horizontal\" | \"vertical\"}\r\n    */\n    set: function (value) {\n      this.setPropertyValue(\"orientation\", value, true);\n      var markerContainer = this.markerContainer;\n      var valueAxis = this.valueAxis; // HORIZONTAL\n\n      if (value == \"horizontal\") {\n        if (!$type.hasValue(this.width)) {\n          this.width = 200;\n        }\n\n        this.height = undefined;\n        valueAxis.width = percent(100);\n        valueAxis.height = undefined;\n        valueAxis.tooltip.pointerOrientation = \"vertical\";\n        this.layout = \"vertical\";\n        markerContainer.width = percent(100);\n        markerContainer.height = undefined;\n\n        if (!(valueAxis.renderer instanceof AxisRendererX)) {\n          valueAxis.renderer = new AxisRendererX();\n        }\n      } // VERTICAL\n      else {\n        if (!$type.hasValue(this.height)) {\n          this.height = 200;\n        }\n\n        this.width = undefined;\n        this.layout = \"horizontal\";\n        markerContainer.width = undefined;\n        markerContainer.height = percent(100);\n        valueAxis.height = percent(100);\n        valueAxis.width = undefined;\n        valueAxis.tooltip.pointerOrientation = \"horizontal\";\n\n        if (!(valueAxis.renderer instanceof AxisRendererY)) {\n          valueAxis.renderer = new AxisRendererY();\n        }\n\n        valueAxis.renderer.inside = true;\n        valueAxis.renderer.labels.template.inside = true;\n        this.markerContainer.reverseOrder = true;\n      }\n\n      var renderer = valueAxis.renderer;\n      renderer.grid.template.disabled = true;\n      renderer.axisFills.template.disabled = true;\n      renderer.baseGrid.disabled = true;\n      renderer.labels.template.padding(2, 3, 2, 3);\n      renderer.minHeight = undefined;\n      renderer.minWidth = undefined;\n      this.markerContainer.layout = value;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(HeatLegend.prototype, \"valueAxis\", {\n    /**\r\n     * Returns valueAxis value.\r\n     * @return {ValueAxis}\r\n     */\n    get: function () {\n      if (!this._valueAxis) {\n        this.valueAxis = this.createChild(ValueAxis);\n        this.valueAxis.shouldClone = false;\n      }\n\n      return this._valueAxis;\n    },\n\n    /**\r\n     * Sets a value axis of heat legend. Value axis for heat legend is created automatically.\r\n     * @param {ValueAxis}\r\n     */\n    set: function (valueAxis) {\n      this._valueAxis = valueAxis;\n      valueAxis.parent = this;\n      valueAxis.strictMinMax = true;\n      this.orientation = this.orientation;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(HeatLegend.prototype, \"series\", {\n    /**\r\n     * Returns series value.\r\n     * @return {Series}\r\n     */\n    get: function () {\n      return this._series;\n    },\n\n    /**\r\n     * You can set series for heat legend. It will take min, max, minColor and maxColor values from this series.\r\n     * @param series\r\n     */\n    set: function (series) {\n      var _this = this;\n\n      this._series = series;\n      var dataField = \"value\";\n\n      try {\n        var dataFieldDefined = series.heatRules.getIndex(0).dataField;\n\n        if (dataFieldDefined) {\n          dataField = dataFieldDefined;\n        }\n      } catch (err) {}\n\n      this.updateMinMax(series.dataItem.values[dataField].low, series.dataItem.values[dataField].high);\n      series.dataItem.events.on(\"calculatedvaluechanged\", function (event) {\n        _this.updateMinMax(series.dataItem.values[dataField].low, series.dataItem.values[dataField].high);\n      }, undefined, false);\n      series.heatRules.events.on(\"inserted\", this.invalidate, this, false);\n      series.heatRules.events.on(\"removed\", this.invalidate, this, false);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\r\n   * Updates min/max of value axis.\r\n   * @ignore\r\n   */\n\n  HeatLegend.prototype.updateMinMax = function (min, max) {\n    var valueAxis = this.valueAxis;\n\n    if (!$type.isNumber(this.minValue)) {\n      valueAxis.min = min;\n      valueAxis.invalidate();\n    }\n\n    if (!$type.isNumber(this.maxValue)) {\n      valueAxis.max = max;\n      valueAxis.invalidate();\n    }\n  };\n  /**\r\n   * Processes JSON-based config before it is applied to the object.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param config  Config\r\n   */\n\n\n  HeatLegend.prototype.processConfig = function (config) {\n    if (config) {\n      // Set up series\n      if ($type.hasValue(config.series) && $type.isString(config.series)) {\n        if ($type.isString(config.series)) {\n          if (this.map.hasKey(config.series)) {\n            config.series = this.map.getKey(config.series);\n          } else {\n            var seriesId_1 = config.series;\n            var disposer_1 = this.map.events.on(\"insertKey\", function (ev) {\n              if (ev.key == seriesId_1) {\n                this.series = ev.newValue;\n                disposer_1.dispose();\n              }\n            }, this);\n\n            this._disposers.push(disposer_1);\n\n            delete config.series;\n          }\n        }\n      }\n    }\n\n    _super.prototype.processConfig.call(this, config);\n  };\n\n  return HeatLegend;\n}(Container);\n\nexport { HeatLegend };\n/**\r\n * Register class in system, so that it can be instantiated using its name from\r\n * anywhere.\r\n *\r\n * @ignore\r\n */\n\nregistry.registeredClasses[\"HeatLegend\"] = HeatLegend;","map":{"version":3,"names":["__extends","Container","LinearGradient","registry","toColor","Color","ListTemplate","ListDisposer","percent","ValueAxis","AxisRendererX","AxisRendererY","$iter","$type","$colors","RoundedRectangle","HeatLegend","_super","_this","call","className","markerContainer","createChild","shouldClone","markerCount","marker","minHeight","minWidth","interactionsEnabled","fillOpacity","cornerRadius","orientation","markers","_disposers","push","template","applyTheme","prototype","getMinFromRules","property","series","minValue_1","eachContinue","heatRules","iterator","heatRule","min","getMaxFromRules","maxValue_1","each","max","validate","valueAxis","renderer","inversed","reverseOrder","minColor","maxColor","hasValue","seriesFill","fill","minOpacity","toNumber","isNumber","maxOpacity","minStrokeOpacity","maxStrokeOpacity","minStroke","maxStroke","i","getIndex","create","parent","height","width","gradient","addColor","rotation","strokeGradient","stroke","c","color","interpolate","rgb","opacity","color_1","opacity_1","strokeOpacity","minGridDistance","measuredWidth","measuredHeight","invalidate","len","length","undefined","Object","defineProperty","get","getPropertyValue","set","value","setColorProperty","enumerable","configurable","setPropertyValue","tooltip","pointerOrientation","layout","inside","labels","grid","disabled","axisFills","baseGrid","padding","_valueAxis","strictMinMax","_series","dataField","dataFieldDefined","err","updateMinMax","dataItem","values","low","high","events","on","event","minValue","maxValue","processConfig","config","isString","map","hasKey","getKey","seriesId_1","disposer_1","ev","key","newValue","dispose","registeredClasses"],"sources":["D:/APPLICATION/UI/UPL/NEW/node_modules/@amcharts/amcharts4/.internal/charts/elements/HeatLegend.js"],"sourcesContent":["/**\r\n * HeatLegend module\r\n */\r\nimport { __extends } from \"tslib\";\r\n/**\r\n * ============================================================================\r\n * IMPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\r\nimport { Container } from \"../../core/Container\";\r\nimport { LinearGradient } from \"../../core/rendering/fills/LinearGradient\";\r\nimport { registry } from \"../../core/Registry\";\r\nimport { toColor, Color } from \"../../core/utils/Color\";\r\nimport { ListTemplate, ListDisposer } from \"../../core/utils/List\";\r\nimport { percent } from \"../../core/utils/Percent\";\r\nimport { ValueAxis } from \"../../charts/axes/ValueAxis\";\r\nimport { AxisRendererX } from \"../../charts/axes/AxisRendererX\";\r\nimport { AxisRendererY } from \"../../charts/axes/AxisRendererY\";\r\nimport * as $iter from \"../../core/utils/Iterator\";\r\nimport * as $type from \"../../core/utils/Type\";\r\nimport * as $colors from \"../../core/utils/Colors\";\r\nimport { RoundedRectangle } from \"../../core/elements/RoundedRectangle\";\r\n/**\r\n * ============================================================================\r\n * MAIN CLASS\r\n * ============================================================================\r\n * @hidden\r\n */\r\n/**\r\n * This class creates a link (waved color-filled line) between two nodes in a\r\n * Sankey Diagram.\r\n *\r\n * @see {@link IHeatLegendEvents} for a list of available events\r\n * @see {@link IHeatLegendAdapters} for a list of available Adapters\r\n * @important\r\n */\r\nvar HeatLegend = /** @class */ (function (_super) {\r\n    __extends(HeatLegend, _super);\r\n    /**\r\n     * Constructor\r\n     */\r\n    function HeatLegend() {\r\n        var _this = _super.call(this) || this;\r\n        _this.className = \"HeatLegend\";\r\n        _this.markerContainer = _this.createChild(Container);\r\n        _this.markerContainer.shouldClone = false;\r\n        _this.markerCount = 1;\r\n        // Create a template container and list for the a marker\r\n        var marker = new RoundedRectangle();\r\n        marker.minHeight = 20;\r\n        marker.minWidth = 20;\r\n        marker.interactionsEnabled = false;\r\n        marker.fillOpacity = 1;\r\n        marker.cornerRadius(0, 0, 0, 0);\r\n        _this.markerContainer.minHeight = 20;\r\n        _this.markerContainer.minWidth = 20;\r\n        _this.orientation = \"horizontal\";\r\n        _this.markers = new ListTemplate(marker);\r\n        _this._disposers.push(new ListDisposer(_this.markers));\r\n        _this._disposers.push(_this.markers.template);\r\n        _this.applyTheme();\r\n        return _this;\r\n    }\r\n    HeatLegend.prototype.getMinFromRules = function (property) {\r\n        var series = this.series;\r\n        if (series) {\r\n            var minValue_1;\r\n            $iter.eachContinue(series.heatRules.iterator(), function (heatRule) {\r\n                if (heatRule.property == property) {\r\n                    minValue_1 = heatRule.min;\r\n                    return false;\r\n                }\r\n                return true;\r\n            });\r\n            return minValue_1;\r\n        }\r\n    };\r\n    HeatLegend.prototype.getMaxFromRules = function (property) {\r\n        var series = this.series;\r\n        if (series) {\r\n            var maxValue_1;\r\n            $iter.each(series.heatRules.iterator(), function (heatRule) {\r\n                if (heatRule.property == property) {\r\n                    maxValue_1 = heatRule.max;\r\n                    return false;\r\n                }\r\n                return true;\r\n            });\r\n            return maxValue_1;\r\n        }\r\n    };\r\n    /**\r\n     *\r\n     * @ignore Exclude from docs\r\n     */\r\n    HeatLegend.prototype.validate = function () {\r\n        _super.prototype.validate.call(this);\r\n        this.valueAxis.renderer.inversed = this.reverseOrder;\r\n        var series = this.series;\r\n        var minColor = this.minColor;\r\n        var maxColor = this.maxColor;\r\n        if (!$type.hasValue(minColor)) {\r\n            minColor = toColor(this.getMinFromRules(\"fill\"));\r\n        }\r\n        if (!$type.hasValue(maxColor)) {\r\n            maxColor = toColor(this.getMaxFromRules(\"fill\"));\r\n        }\r\n        if (series) {\r\n            var seriesFill = series.fill;\r\n            if (!$type.hasValue(minColor) && seriesFill instanceof Color) {\r\n                minColor = seriesFill;\r\n            }\r\n            if (!$type.hasValue(maxColor) && seriesFill instanceof Color) {\r\n                maxColor = seriesFill;\r\n            }\r\n        }\r\n        if (!$type.hasValue(maxColor)) {\r\n            maxColor = toColor(this.getMaxFromRules(\"fill\"));\r\n        }\r\n        var minOpacity = $type.toNumber(this.getMinFromRules(\"fillOpacity\"));\r\n        if (!$type.isNumber(minOpacity)) {\r\n            minOpacity = 1;\r\n        }\r\n        var maxOpacity = $type.toNumber(this.getMaxFromRules(\"fillOpacity\"));\r\n        if (!$type.isNumber(maxOpacity)) {\r\n            maxOpacity = 1;\r\n        }\r\n        var minStrokeOpacity = $type.toNumber(this.getMinFromRules(\"strokeOpacity\"));\r\n        if (!$type.isNumber(minStrokeOpacity)) {\r\n            minStrokeOpacity = 1;\r\n        }\r\n        var maxStrokeOpacity = $type.toNumber(this.getMaxFromRules(\"strokeOpacity\"));\r\n        if (!$type.isNumber(maxStrokeOpacity)) {\r\n            maxStrokeOpacity = 1;\r\n        }\r\n        var minStroke = toColor(this.getMinFromRules(\"stroke\"));\r\n        var maxStroke = toColor(this.getMaxFromRules(\"stroke\"));\r\n        //if (series) {\r\n        for (var i = 0; i < this.markerCount; i++) {\r\n            var marker = this.markers.getIndex(i);\r\n            if (!marker) {\r\n                marker = this.markers.create();\r\n                marker.parent = this.markerContainer;\r\n                marker.height = percent(100);\r\n                marker.width = percent(100);\r\n            }\r\n            if (this.markerCount == 1) {\r\n                var gradient = new LinearGradient();\r\n                if (this.reverseOrder) {\r\n                    gradient.addColor(maxColor, maxOpacity);\r\n                    gradient.addColor(minColor, minOpacity);\r\n                }\r\n                else {\r\n                    gradient.addColor(minColor, minOpacity);\r\n                    gradient.addColor(maxColor, maxOpacity);\r\n                }\r\n                if (this.orientation == \"vertical\") {\r\n                    gradient.rotation = -90;\r\n                }\r\n                marker.fill = gradient;\r\n                if ($type.hasValue(minStroke) && $type.hasValue(maxStroke)) {\r\n                    var strokeGradient = new LinearGradient();\r\n                    if (this.reverseOrder) {\r\n                        strokeGradient.addColor(maxStroke, maxStrokeOpacity);\r\n                        strokeGradient.addColor(minStroke, minStrokeOpacity);\r\n                    }\r\n                    else {\r\n                        strokeGradient.addColor(minStroke, minStrokeOpacity);\r\n                        strokeGradient.addColor(maxStroke, maxStrokeOpacity);\r\n                    }\r\n                    if (this.orientation == \"vertical\") {\r\n                        strokeGradient.rotation = -90;\r\n                    }\r\n                    marker.stroke = strokeGradient;\r\n                }\r\n            }\r\n            else {\r\n                var c = i;\r\n                if (this.reverseOrder) {\r\n                    c = this.markerCount - i - 1;\r\n                }\r\n                var color = new Color($colors.interpolate(minColor.rgb, maxColor.rgb, c / this.markerCount));\r\n                marker.fill = color;\r\n                var opacity = minOpacity + (maxOpacity - minOpacity) * c / this.markerCount;\r\n                marker.fillOpacity = opacity;\r\n                if ($type.hasValue(minStroke) && $type.hasValue(maxStroke)) {\r\n                    var color_1 = new Color($colors.interpolate(minStroke.rgb, maxStroke.rgb, c / this.markerCount));\r\n                    marker.stroke = color_1;\r\n                    var opacity_1 = minStrokeOpacity + (maxStrokeOpacity - minStrokeOpacity) * c / this.markerCount;\r\n                    marker.strokeOpacity = opacity_1;\r\n                }\r\n            }\r\n        }\r\n        var renderer = this.valueAxis.renderer;\r\n        if (this.markerCount > 1) {\r\n            if (this.orientation == \"horizontal\") {\r\n                renderer.minGridDistance = this.measuredWidth / this.markerCount;\r\n            }\r\n            else {\r\n                renderer.minGridDistance = this.measuredHeight / this.markerCount;\r\n            }\r\n        }\r\n        this.valueAxis.invalidate();\r\n        for (var i = this.markerCount, len = this.markers.length; i < len; i++) {\r\n            this.markers.getIndex(i).parent = undefined;\r\n        }\r\n    };\r\n    Object.defineProperty(HeatLegend.prototype, \"minColor\", {\r\n        /**\r\n         * Returns minColor value\r\n         * @return {Color}\r\n         */\r\n        get: function () {\r\n            return this.getPropertyValue(\"minColor\");\r\n        },\r\n        /**\r\n         * Min color of a heat legend. If a series is set for the legend, minColor is taken from series.\r\n         *\r\n         * @param {Color}\r\n         */\r\n        set: function (value) {\r\n            if (!(value instanceof Color)) {\r\n                value = toColor(value);\r\n            }\r\n            this.setColorProperty(\"minColor\", value, true);\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(HeatLegend.prototype, \"maxColor\", {\r\n        /**\r\n         * Returns maxColor value\r\n         * @return {Color}\r\n         */\r\n        get: function () {\r\n            return this.getPropertyValue(\"maxColor\");\r\n        },\r\n        /**\r\n         * Max color of a heat legend. If a series is set for the legend, maxColor is taken from series.\r\n         *\r\n         * @param {Color}\r\n         */\r\n        set: function (value) {\r\n            if (!(value instanceof Color)) {\r\n                value = toColor(value);\r\n            }\r\n            this.setColorProperty(\"maxColor\", value, true);\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(HeatLegend.prototype, \"markerCount\", {\r\n        /**\r\n         * Returns number of color squares (markers).\r\n         * @return {number}\r\n         */\r\n        get: function () {\r\n            return this.getPropertyValue(\"markerCount\");\r\n        },\r\n        /**\r\n         * Number of color squares (markers) in the heat legend. If only 1 marker is used, it will be filled with gradient.\r\n         *\r\n         * @param {number}\r\n         */\r\n        set: function (value) {\r\n            this.setPropertyValue(\"markerCount\", value, true);\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(HeatLegend.prototype, \"minValue\", {\r\n        /**\r\n         * Returns minimum value of heat legend.\r\n         * @return {number}\r\n         */\r\n        get: function () {\r\n            return this.getPropertyValue(\"minValue\");\r\n        },\r\n        /**\r\n         * Minimum value of heat legend's value axis. If a series is set for the legend, min is taken from series.\r\n         *\r\n         * @param {number}\r\n         */\r\n        set: function (value) {\r\n            this.setPropertyValue(\"minValue\", value);\r\n            this.valueAxis.min = value;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(HeatLegend.prototype, \"maxValue\", {\r\n        /**\r\n         * Returns maximum value of heat legend.\r\n         * @return {number}\r\n         */\r\n        get: function () {\r\n            return this.getPropertyValue(\"maxValue\");\r\n        },\r\n        /**\r\n         * Maximum value of heat legend's value axis. If a series is set for the legend, max is taken from series.\r\n         *\r\n         * @param {number}\r\n         */\r\n        set: function (value) {\r\n            this.setPropertyValue(\"maxValue\", value);\r\n            this.valueAxis.max = value;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(HeatLegend.prototype, \"orientation\", {\r\n        /**\r\n         * Returns orientation value.\r\n         *\r\n         * @return {\"horizontal\" | \"vertical\"}\r\n         */\r\n        get: function () {\r\n            return this.getPropertyValue(\"orientation\");\r\n        },\r\n        /**\r\n        * Heat legend orientation. Note, if you change orientation of a heat legend, you must set value axis renderer properties after that, as with orientation renderer changes.\r\n        *\r\n        * @param {\"horizontal\" | \"vertical\"}\r\n        */\r\n        set: function (value) {\r\n            this.setPropertyValue(\"orientation\", value, true);\r\n            var markerContainer = this.markerContainer;\r\n            var valueAxis = this.valueAxis;\r\n            // HORIZONTAL\r\n            if (value == \"horizontal\") {\r\n                if (!$type.hasValue(this.width)) {\r\n                    this.width = 200;\r\n                }\r\n                this.height = undefined;\r\n                valueAxis.width = percent(100);\r\n                valueAxis.height = undefined;\r\n                valueAxis.tooltip.pointerOrientation = \"vertical\";\r\n                this.layout = \"vertical\";\r\n                markerContainer.width = percent(100);\r\n                markerContainer.height = undefined;\r\n                if (!(valueAxis.renderer instanceof AxisRendererX)) {\r\n                    valueAxis.renderer = new AxisRendererX();\r\n                }\r\n            }\r\n            // VERTICAL\r\n            else {\r\n                if (!$type.hasValue(this.height)) {\r\n                    this.height = 200;\r\n                }\r\n                this.width = undefined;\r\n                this.layout = \"horizontal\";\r\n                markerContainer.width = undefined;\r\n                markerContainer.height = percent(100);\r\n                valueAxis.height = percent(100);\r\n                valueAxis.width = undefined;\r\n                valueAxis.tooltip.pointerOrientation = \"horizontal\";\r\n                if (!(valueAxis.renderer instanceof AxisRendererY)) {\r\n                    valueAxis.renderer = new AxisRendererY();\r\n                }\r\n                valueAxis.renderer.inside = true;\r\n                valueAxis.renderer.labels.template.inside = true;\r\n                this.markerContainer.reverseOrder = true;\r\n            }\r\n            var renderer = valueAxis.renderer;\r\n            renderer.grid.template.disabled = true;\r\n            renderer.axisFills.template.disabled = true;\r\n            renderer.baseGrid.disabled = true;\r\n            renderer.labels.template.padding(2, 3, 2, 3);\r\n            renderer.minHeight = undefined;\r\n            renderer.minWidth = undefined;\r\n            this.markerContainer.layout = value;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(HeatLegend.prototype, \"valueAxis\", {\r\n        /**\r\n         * Returns valueAxis value.\r\n         * @return {ValueAxis}\r\n         */\r\n        get: function () {\r\n            if (!this._valueAxis) {\r\n                this.valueAxis = this.createChild(ValueAxis);\r\n                this.valueAxis.shouldClone = false;\r\n            }\r\n            return this._valueAxis;\r\n        },\r\n        /**\r\n         * Sets a value axis of heat legend. Value axis for heat legend is created automatically.\r\n         * @param {ValueAxis}\r\n         */\r\n        set: function (valueAxis) {\r\n            this._valueAxis = valueAxis;\r\n            valueAxis.parent = this;\r\n            valueAxis.strictMinMax = true;\r\n            this.orientation = this.orientation;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(HeatLegend.prototype, \"series\", {\r\n        /**\r\n         * Returns series value.\r\n         * @return {Series}\r\n         */\r\n        get: function () {\r\n            return this._series;\r\n        },\r\n        /**\r\n         * You can set series for heat legend. It will take min, max, minColor and maxColor values from this series.\r\n         * @param series\r\n         */\r\n        set: function (series) {\r\n            var _this = this;\r\n            this._series = series;\r\n            var dataField = \"value\";\r\n            try {\r\n                var dataFieldDefined = series.heatRules.getIndex(0).dataField;\r\n                if (dataFieldDefined) {\r\n                    dataField = dataFieldDefined;\r\n                }\r\n            }\r\n            catch (err) {\r\n            }\r\n            this.updateMinMax(series.dataItem.values[dataField].low, series.dataItem.values[dataField].high);\r\n            series.dataItem.events.on(\"calculatedvaluechanged\", function (event) {\r\n                _this.updateMinMax(series.dataItem.values[dataField].low, series.dataItem.values[dataField].high);\r\n            }, undefined, false);\r\n            series.heatRules.events.on(\"inserted\", this.invalidate, this, false);\r\n            series.heatRules.events.on(\"removed\", this.invalidate, this, false);\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    /**\r\n     * Updates min/max of value axis.\r\n     * @ignore\r\n     */\r\n    HeatLegend.prototype.updateMinMax = function (min, max) {\r\n        var valueAxis = this.valueAxis;\r\n        if (!$type.isNumber(this.minValue)) {\r\n            valueAxis.min = min;\r\n            valueAxis.invalidate();\r\n        }\r\n        if (!$type.isNumber(this.maxValue)) {\r\n            valueAxis.max = max;\r\n            valueAxis.invalidate();\r\n        }\r\n    };\r\n    /**\r\n     * Processes JSON-based config before it is applied to the object.\r\n     *\r\n     * @ignore Exclude from docs\r\n     * @param config  Config\r\n     */\r\n    HeatLegend.prototype.processConfig = function (config) {\r\n        if (config) {\r\n            // Set up series\r\n            if ($type.hasValue(config.series) && $type.isString(config.series)) {\r\n                if ($type.isString(config.series)) {\r\n                    if (this.map.hasKey(config.series)) {\r\n                        config.series = this.map.getKey(config.series);\r\n                    }\r\n                    else {\r\n                        var seriesId_1 = config.series;\r\n                        var disposer_1 = this.map.events.on(\"insertKey\", function (ev) {\r\n                            if (ev.key == seriesId_1) {\r\n                                this.series = ev.newValue;\r\n                                disposer_1.dispose();\r\n                            }\r\n                        }, this);\r\n                        this._disposers.push(disposer_1);\r\n                        delete config.series;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        _super.prototype.processConfig.call(this, config);\r\n    };\r\n    return HeatLegend;\r\n}(Container));\r\nexport { HeatLegend };\r\n/**\r\n * Register class in system, so that it can be instantiated using its name from\r\n * anywhere.\r\n *\r\n * @ignore\r\n */\r\nregistry.registeredClasses[\"HeatLegend\"] = HeatLegend;\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}