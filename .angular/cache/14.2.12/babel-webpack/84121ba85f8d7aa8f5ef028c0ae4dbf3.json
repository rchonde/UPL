{"ast":null,"code":"/**\r\n * Category axis module\r\n */\nimport { __extends } from \"tslib\";\n/**\r\n * ============================================================================\r\n * IMPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\n\nimport { Axis, AxisDataItem } from \"./Axis\";\nimport { AxisRendererX } from \"./AxisRendererX\";\nimport { AxisRendererY } from \"./AxisRendererY\";\nimport { registry } from \"../../core/Registry\";\nimport { Dictionary } from \"../../core/utils/Dictionary\";\nimport { CategoryAxisBreak } from \"./CategoryAxisBreak\";\nimport * as $math from \"../../core/utils/Math\";\nimport * as $type from \"../../core/utils/Type\";\nimport * as $iter from \"../../core/utils/Iterator\";\n/**\r\n * ============================================================================\r\n * DATA ITEM\r\n * ============================================================================\r\n * @hidden\r\n */\n\n/**\r\n * Defines a [[DataItem]] for [[CategoryAxis]].\r\n *\r\n * @see {@link DataItem}\r\n */\n\nvar CategoryAxisDataItem =\n/** @class */\nfunction (_super) {\n  __extends(CategoryAxisDataItem, _super);\n  /**\r\n   * Constructor\r\n   */\n\n\n  function CategoryAxisDataItem() {\n    var _this = _super.call(this) || this;\n\n    _this.seriesDataItems = {};\n    _this.className = \"CategoryAxisDataItem\";\n    _this.text = \"{category}\";\n    _this.locations.category = 0;\n    _this.locations.endCategory = 1;\n    _this.deltaPosition = 0;\n\n    _this.applyTheme();\n\n    return _this;\n  }\n\n  Object.defineProperty(CategoryAxisDataItem.prototype, \"category\", {\n    /**\r\n     * @return Category\r\n     */\n    get: function () {\n      if (this._adapterO) {\n        if (this._adapterO.isEnabled(\"category\")) {\n          return this._adapterO.apply(\"category\", this.properties.category);\n        }\n      }\n\n      return this.properties.category;\n    },\n\n    /**\r\n     * Category.\r\n     *\r\n     * @param value  Category\r\n     */\n    set: function (value) {\n      var oldCategory = this.properties.category;\n      this.setProperty(\"category\", value);\n\n      if ($type.hasValue(oldCategory) && oldCategory != value) {\n        if (this.component) {\n          this.component.validateDataElement(this);\n        }\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(CategoryAxisDataItem.prototype, \"endCategory\", {\n    /**\r\n     * @return End category\r\n     */\n    get: function () {\n      return this.properties.endCategory;\n    },\n\n    /**\r\n     * End category.\r\n     *\r\n     * Used for items that span several categories, like [[CategoryAxisBreak]].\r\n     *\r\n     * @param value  End category\r\n     */\n    set: function (value) {\n      this.setProperty(\"endCategory\", value);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(CategoryAxisDataItem.prototype, \"deltaPosition\", {\n    get: function () {\n      return this.properties.deltaCoordinate;\n    },\n    set: function (value) {\n      if (value != this.properties.deltaCoordinate) {\n        this.setProperty(\"deltaCoordinate\", value);\n\n        if (this.component) {\n          this.component.invalidateDataItems();\n          this.component.invalidateSeries();\n        }\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  return CategoryAxisDataItem;\n}(AxisDataItem);\n\nexport { CategoryAxisDataItem };\n/**\r\n * ============================================================================\r\n * MAIN CLASS\r\n * ============================================================================\r\n * @hidden\r\n */\n\n/**\r\n * Used to create a category-based axis for the chart.\r\n *\r\n * ```TypeScript\r\n * // Create the axis\r\n * let xAxis = chart.xAxes.push(new am4charts.CategoryAxis());\r\n *\r\n * // Set settings\r\n * xAxis.title.text = \"Clients\";\r\n * ```\r\n * ```JavaScript\r\n * // Create the axis\r\n * var valueAxis = chart.xAxes.push(new am4charts.CategoryAxis());\r\n *\r\n * // Set settings\r\n * valueAxis.title.text = \"Clients\";\r\n * ```\r\n * ```JSON\r\n * \"xAxes\": [{\r\n *   \"type\": \"CategoryAxis\",\r\n *   \"title\": {\r\n *     \"text\": \"Clients\"\r\n *   }\r\n * }]\r\n * ```\r\n *\r\n * @see {@link ICategoryAxisEvents} for a list of available Events\r\n * @see {@link ICategoryAxisAdapters} for a list of available Adapters\r\n * @important\r\n */\n\nvar CategoryAxis =\n/** @class */\nfunction (_super) {\n  __extends(CategoryAxis, _super);\n  /**\r\n   * Constructor\r\n   */\n\n\n  function CategoryAxis() {\n    var _this = // Init\n    _super.call(this) || this;\n    /**\r\n     * A collection that holds Axis' data items sorted by each category.\r\n     */\n\n\n    _this.dataItemsByCategory = new Dictionary();\n    _this.className = \"CategoryAxis\"; // Set field name\n\n    _this.axisFieldName = \"category\";\n    _this._lastDataItem = _this.createDataItem();\n    _this._lastDataItem.component = _this;\n\n    _this._disposers.push(_this._lastDataItem); // Apply theme\n\n\n    _this.applyTheme();\n\n    var dataItemsByCategory = _this.dataItemsByCategory;\n\n    _this.addDisposer(_this.mainDataSet.events.on(\"removed\", function (event) {\n      dataItemsByCategory.removeKey(event.oldValue.category);\n    }));\n\n    return _this;\n  }\n  /**\r\n   * Returns a new/empty [[DataItem]] of the type appropriate for this object.\r\n   *\r\n   * @see {@link DataItem}\r\n   * @return Data Item\r\n   */\n\n\n  CategoryAxis.prototype.createDataItem = function () {\n    return new CategoryAxisDataItem();\n  };\n  /**\r\n   * Returns a new/empty [[AxisBreak]] of the appropriate type.\r\n   *\r\n   * @return Axis break\r\n   */\n\n\n  CategoryAxis.prototype.createAxisBreak = function () {\n    return new CategoryAxisBreak();\n  };\n  /**\r\n   * Processes a related series' data item.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @todo Description\r\n   * @param dataItem  Data item\r\n   */\n\n\n  CategoryAxis.prototype.processSeriesDataItem = function (dataItem, axisLetter) {\n    _super.prototype.processSeriesDataItem.call(this, dataItem, axisLetter);\n\n    var category = dataItem[\"category\" + this.axisLetter];\n\n    if ($type.hasValue(category)) {\n      var categoryAxisDataItem = this.dataItemsByCategory.getKey(category);\n\n      if (categoryAxisDataItem) {\n        var seriesId = dataItem.component.uid;\n        var seriesDataItems = categoryAxisDataItem.seriesDataItems[seriesId];\n\n        if (!seriesDataItems) {\n          seriesDataItems = [];\n          categoryAxisDataItem.seriesDataItems[seriesId] = seriesDataItems;\n        }\n\n        seriesDataItems.push(dataItem);\n      }\n    } else {\n      dataItem.component.dataItems.remove(dataItem);\n    }\n  };\n  /**\r\n   * Validates the data range.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @todo Description (review)\r\n   */\n\n\n  CategoryAxis.prototype.validateDataRange = function () {\n    var _this = this;\n\n    _super.prototype.validateDataRange.call(this);\n\n    $iter.each(this._series.iterator(), function (series) {\n      if (series.xAxis instanceof CategoryAxis && series.yAxis instanceof CategoryAxis) {\n        series.invalidateDataRange();\n      } else {\n        var startIndex = _this.positionToIndex(_this.start);\n\n        var endIndex = _this.positionToIndex(_this.end);\n\n        if (endIndex >= _this.dataItems.length) {\n          endIndex--;\n        }\n\n        var seriesId = series.uid;\n        var minIndex = void 0;\n        var maxIndex = void 0;\n\n        for (var i = startIndex; i <= endIndex; i++) {\n          var axisDataItem = _this.dataItems.getIndex(i);\n\n          if (axisDataItem) {\n            var seriesDataItems = axisDataItem.seriesDataItems[seriesId];\n\n            if (seriesDataItems) {\n              for (var i_1 = 0; i_1 < seriesDataItems.length; i_1++) {\n                var seriesDataItem = seriesDataItems[i_1];\n\n                if (seriesDataItem) {\n                  var index = seriesDataItem.index;\n\n                  if (!$type.isNumber(minIndex) || index < minIndex) {\n                    minIndex = index;\n                  }\n\n                  if (!$type.isNumber(maxIndex) || index > maxIndex) {\n                    maxIndex = index;\n                  }\n                }\n              }\n            }\n          }\n        }\n\n        if ($type.isNumber(minIndex)) {\n          series.startIndex = minIndex;\n        } else {\n          series.start = _this.start;\n        }\n\n        if ($type.isNumber(maxIndex)) {\n          series.endIndex = maxIndex + 1;\n        } else {\n          series.end = _this.end;\n        } // range might not change, but axis breaks might.\n\n\n        if (_this._axisBreaks && _this._axisBreaks.length > 0) {\n          series.invalidateDataRange();\n        }\n      }\n    });\n  };\n  /**\r\n   * Validates the whole axis. Causes it to redraw.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @todo Description (review)\r\n   */\n\n\n  CategoryAxis.prototype.validate = function () {\n    var _this = this;\n\n    _super.prototype.validate.call(this);\n\n    var dataCount = this.dataItems.length;\n    var startIndex = $math.fitToRange(Math.floor(this.start * dataCount - 1), 0, dataCount);\n    var endIndex = $math.fitToRange(Math.ceil(this.end * dataCount), 0, dataCount);\n\n    if (this.renderer.invalid) {\n      this.renderer.validate();\n    } // find frequency at which we'll show items\n\n\n    var maxCount = this.renderer.axisLength / Math.max(this.renderer.minGridDistance, 1 / Number.MAX_SAFE_INTEGER);\n    var frequency = Math.min(this.dataItems.length, Math.ceil((endIndex - startIndex) / maxCount));\n    this._startIndex = Math.floor(startIndex / frequency) * frequency;\n    this._endIndex = Math.ceil(this.end * dataCount);\n    this.fixAxisBreaks();\n\n    if (this._startIndex == this._endIndex) {\n      this._endIndex++;\n    }\n\n    this._frequency = frequency;\n\n    if (this.axisLength <= 0) {\n      return;\n    }\n\n    this.maxZoomFactor = this.dataItems.length;\n\n    if (this.dataItems.length <= 0) {\n      this.maxZoomFactor = 1;\n    }\n\n    this.resetIterators(); // it's important to use protected variables here, as getters will return 0 - length\n    // TODO use iterator instead\n    // @ todo: not solved cat axis item fading\n\n    startIndex = $math.max(0, this._startIndex - this._frequency);\n    endIndex = $math.min(this.dataItems.length, this._endIndex + this._frequency);\n    var itemIndex = 0;\n\n    for (var i = 0; i < startIndex; i++) {\n      var dataItem = this.dataItems.getIndex(i);\n      dataItem.__disabled = true;\n    }\n\n    for (var i = endIndex, len = this.dataItems.length; i < len; i++) {\n      var dataItem = this.dataItems.getIndex(i);\n      dataItem.__disabled = true;\n    }\n\n    for (var i = startIndex; i < endIndex; i++) {\n      if (i < this.dataItems.length) {\n        var dataItem = this.dataItems.getIndex(i);\n\n        if (i / this._frequency == Math.round(i / this._frequency)) {\n          var axisBreak = this.isInBreak(i);\n\n          if (!axisBreak) {\n            this.appendDataItem(dataItem);\n            this.validateDataElement(dataItem, itemIndex);\n          }\n\n          itemIndex++;\n        } else {\n          //previously we disabled all before, but this is better for cpu\n          //this.validateDataElement(dataItem, itemIndex); // helps to solve shrinking // not good - creates all items\n          dataItem.__disabled = true;\n        }\n      }\n    }\n\n    this.appendDataItem(this._lastDataItem);\n    this.validateDataElement(this._lastDataItem, itemIndex + 1, this.dataItems.length);\n\n    if (this._axisBreaks) {\n      var axisBreaks = this._axisBreaks;\n      axisBreaks.each(function (axisBreak) {\n        var adjustedStartValue = axisBreak.adjustedStartValue;\n        var adjustedEndValue = axisBreak.adjustedEndValue;\n\n        if ($math.intersect({\n          start: adjustedStartValue,\n          end: adjustedEndValue\n        }, {\n          start: _this._startIndex,\n          end: _this._endIndex\n        })) {\n          for (var b = adjustedStartValue; b <= adjustedEndValue; b++) {\n            var dataItem = _this.dataItems.getIndex(b);\n\n            dataItem.__disabled = true;\n          }\n\n          var frequency_1 = $math.fitToRange(Math.ceil(_this._frequency / axisBreak.breakSize), 1, adjustedEndValue - adjustedStartValue);\n          var itemIndex_1 = 0;\n\n          if (axisBreak.breakSize > 0) {\n            // TODO use iterator instead\n            for (var b = adjustedStartValue; b <= adjustedEndValue; b = b + frequency_1) {\n              var dataItem = _this.dataItems.getIndex(b);\n\n              dataItem.__disabled = false;\n\n              _this.appendDataItem(dataItem);\n\n              _this.validateDataElement(dataItem, itemIndex_1);\n\n              itemIndex_1++;\n            }\n          }\n        }\n      });\n    }\n\n    this.validateBreaks();\n    this.validateAxisRanges();\n    this.ghostLabel.invalidate(); // solves font issue\n\n    this.renderer.invalidateLayout();\n  };\n  /**\r\n   * [validateDataElement description]\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @todo Description\r\n   * @param dataItem   [description]\r\n   * @param itemIndex  [description]\r\n   */\n\n\n  CategoryAxis.prototype.validateDataElement = function (dataItem, itemIndex, index) {\n    _super.prototype.validateDataElement.call(this, dataItem);\n\n    dataItem.itemIndex = this._axisItemCount;\n    this._axisItemCount++; //dataItem.__disabled = false;\n\n    var renderer = this.renderer;\n\n    if (!$type.isNumber(index)) {\n      index = this.categoryToIndex(dataItem.category);\n    }\n\n    var endIndex = this.categoryToIndex(dataItem.endCategory);\n\n    if (!$type.isNumber(endIndex)) {\n      endIndex = index;\n    }\n\n    var position = this.indexToPosition(index, dataItem.locations.category);\n    var endPosition = this.indexToPosition(endIndex, dataItem.locations.endCategory);\n    dataItem.position = position;\n    var fillEndIndex;\n    var fillPosition;\n    var fillEndPosition;\n\n    if (dataItem.isRange) {\n      fillEndIndex = endIndex;\n      fillPosition = this.indexToPosition(index, dataItem.locations.category);\n      fillEndPosition = this.indexToPosition(fillEndIndex, dataItem.locations.endCategory);\n    }\n\n    dataItem.point = renderer.positionToPoint(position);\n    var tick = dataItem.tick;\n\n    if (tick && !tick.disabled) {\n      renderer.updateTickElement(tick, position, endPosition);\n    }\n\n    var grid = dataItem.grid;\n\n    if (grid && !grid.disabled) {\n      renderer.updateGridElement(grid, position, endPosition);\n    }\n\n    var label = dataItem.label;\n\n    if (label && !label.disabled) {\n      // theorethically this might result problems if category text changes, the range text won't change. But otherwise range.label.text = \"custom text\" won't work, which is not intuitive.\n      if (!dataItem.isRange || label.text == undefined) {\n        dataItem.text = dataItem.text;\n      }\n\n      renderer.updateLabelElement(label, position, endPosition);\n\n      if (renderer instanceof AxisRendererY && dataItem.label.measuredWidth > this.ghostLabel.measuredWidth || renderer instanceof AxisRendererX && dataItem.label.measuredHeight > this.ghostLabel.measuredHeight) {\n        if (dataItem.label.html) {\n          this.ghostLabel.html = dataItem.label.currentText;\n        } else {\n          this.ghostLabel.text = dataItem.label.currentText;\n        }\n      }\n    }\n\n    var fill = dataItem.axisFill;\n\n    if (fill && !fill.disabled) {\n      if (!dataItem.isRange) {\n        fillEndIndex = index + this._frequency;\n        fillPosition = this.indexToPosition(index, fill.location);\n        fillEndPosition = this.indexToPosition(fillEndIndex, fill.location);\n      }\n\n      renderer.updateFillElement(fill, fillPosition, fillEndPosition);\n\n      if (!dataItem.isRange) {\n        this.fillRule(dataItem, itemIndex);\n      }\n    }\n\n    if (dataItem.bullet) {\n      renderer.updateBullet(dataItem.bullet, position, endPosition);\n    }\n\n    var mask = dataItem.mask;\n\n    if (mask) {\n      renderer.updateFillElement(mask, fillPosition, fillEndPosition);\n    }\n  };\n  /**\r\n   * @ignore\r\n   */\n\n\n  CategoryAxis.prototype.disposeData = function () {\n    this.dataItemsByCategory.clear();\n\n    _super.prototype.disposeData.call(this);\n  };\n  /**\r\n   * Processes the axis data item.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param dataItem     Data item\r\n   * @param dataContext  The raw data that corresponds to this data item\r\n   */\n\n\n  CategoryAxis.prototype.processDataItem = function (dataItem, dataContext) {\n    if (dataItem) {\n      // creat a collection for fast access\n      _super.prototype.processDataItem.call(this, dataItem, dataContext); // check if such category already exists\n      //let existingDataItem: CategoryAxisDataItem = this.dataItemsByCategory.getKey(dataItem.category);\n      //if (existingDataItem && existingDataItem != dataItem) {\n      //\tthis.dataItems.remove(existingDataItem);\n      //}\n\n\n      if ($type.hasValue(dataItem.category)) {\n        this.dataItemsByCategory.setKey(dataItem.category, dataItem);\n      }\n    }\n  };\n\n  CategoryAxis.prototype.getDataItem = function (dataContext) {\n    var category = dataContext[this.dataFields.category];\n\n    if ($type.hasValue(category)) {\n      var dataItem = this.dataItemsByCategory.getKey(category);\n\n      if (dataItem) {\n        return dataItem;\n      } else {\n        return this.dataItems.create();\n      }\n    }\n  };\n  /**\r\n   * Converts a category index to an actual screen coordinate on the axis.\r\n   *\r\n   * `location` identifies relative location within category. 0 - beginning,\r\n   * 0.5 - middle, 1 - end, and anything inbetween.\r\n   *\r\n   * @param index     Index\r\n   * @param location  Location (0-1)\r\n   * @return Position (px)\r\n   */\n\n\n  CategoryAxis.prototype.indexToPosition = function (index, location) {\n    if (!$type.isNumber(location)) {\n      location = 0.5;\n    }\n\n    var startIndex = this.startIndex;\n    var endIndex = this.endIndex;\n    var difference = this.adjustDifference(startIndex, endIndex);\n    var startLocation = this.startLocation;\n    var endLocation = this.endLocation;\n    difference -= startLocation;\n    difference -= 1 - endLocation;\n\n    if (this._axisBreaks) {\n      var axisBreaks = this._axisBreaks;\n      $iter.eachContinue(axisBreaks.iterator(), function (axisBreak) {\n        var breakStartIndex = axisBreak.adjustedStartValue;\n        var breakEndIndex = axisBreak.adjustedEndValue;\n\n        if (index < startIndex || !$type.isNumber(breakStartIndex) || !$type.isNumber(breakEndIndex)) {\n          return false;\n        }\n\n        if ($math.intersect({\n          start: breakStartIndex,\n          end: breakEndIndex\n        }, {\n          start: startIndex,\n          end: endIndex\n        })) {\n          breakStartIndex = Math.max(startIndex, breakStartIndex);\n          breakEndIndex = Math.min(endIndex, breakEndIndex);\n          var breakSize = axisBreak.breakSize; // value to the right of break end\n\n          if (index > breakEndIndex) {\n            startIndex += (breakEndIndex - breakStartIndex) * (1 - breakSize);\n          } // value to the left of break start\n          else if (index < breakStartIndex) {} // value within break\n          else {\n            index = breakStartIndex + (index - breakStartIndex) * breakSize;\n          }\n        }\n\n        return true;\n      });\n    }\n\n    var deltaPosition = 0;\n    var dataItem = this.dataItems.getIndex(index);\n\n    if (dataItem) {\n      deltaPosition = dataItem.deltaPosition;\n    }\n\n    return $math.round(deltaPosition + (index + location - startLocation - startIndex) / difference, 5);\n  };\n  /**\r\n   * Converts a string category name to relative position on axis.\r\n   *\r\n   * `location` identifies relative location within category. 0 - beginning,\r\n   * 0.5 - middle, 1 - end, and anything inbetween.\r\n   *\r\n   * @param category  Category name\r\n   * @param location  Location (0-1)\r\n   * @return Position\r\n   */\n\n\n  CategoryAxis.prototype.categoryToPosition = function (category, location) {\n    var index = this.categoryToIndex(category);\n    return this.indexToPosition(index, location);\n  };\n  /**\r\n   * Converts a string category name to a orientation point (x, y, angle) on axis\r\n   *\r\n   * `location` identifies relative location within category. 0 - beginning,\r\n   * 0.5 - middle, 1 - end, and anything inbetween.\r\n   * @param category  Category name\r\n   * @param location  Location (0-1)\r\n   * @return Orientation point\r\n   */\n\n\n  CategoryAxis.prototype.categoryToPoint = function (category, location) {\n    var position = this.categoryToPosition(category, location);\n    var point = this.renderer.positionToPoint(position);\n    var angle = this.renderer.positionToAngle(position);\n    return {\n      x: point.x,\n      y: point.y,\n      angle: angle\n    };\n  };\n  /**\r\n   * Converts a string category name to a orientation point (x, y, angle) on axis\r\n   *\r\n   * `location` identifies relative location within category. 0 - beginning,\r\n   * 0.5 - middle, 1 - end, and anything inbetween.\r\n   * @param category  Category name\r\n   * @param location  Location (0-1)\r\n   * @return Orientation point\r\n   */\n\n\n  CategoryAxis.prototype.anyToPoint = function (category, location) {\n    return this.categoryToPoint(category, location);\n  };\n  /**\r\n   * Converts a string category name to relative position on axis.\r\n   *\r\n   * An alias to `categoryToPosition()`.\r\n   *\r\n   * @param category  Category name\r\n   * @param location  Location (0-1)\r\n   * @return Relative position\r\n   */\n\n\n  CategoryAxis.prototype.anyToPosition = function (category, location) {\n    return this.categoryToPosition(category, location);\n  };\n  /**\r\n   * Converts named category to an index of data item it corresponds to.\r\n   *\r\n   * @param category  Category\r\n   * @return Data item index\r\n   */\n\n\n  CategoryAxis.prototype.categoryToIndex = function (category) {\n    if ($type.hasValue(category)) {\n      var dataItem = this.dataItemsByCategory.getKey(category);\n\n      if (dataItem) {\n        return dataItem.index;\n      }\n    }\n  };\n  /**\r\n   * Zooms the axis to specific named ctaegories.\r\n   *\r\n   * @param startCategory  Start category\r\n   * @param endCategory    End category\r\n   */\n\n\n  CategoryAxis.prototype.zoomToCategories = function (startCategory, endCategory) {\n    this.zoomToIndexes(this.categoryToIndex(startCategory), this.categoryToIndex(endCategory) + 1);\n  };\n  /**\r\n   * [getAnyRangePath description]\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @todo Description\r\n   * @param start         [description]\r\n   * @param end           [description]\r\n   * @param startLocation [description]\r\n   * @param endLocation   [description]\r\n   * @return [description]\r\n   */\n\n\n  CategoryAxis.prototype.getAnyRangePath = function (start, end, startLocation, endLocation) {\n    var startPos = this.categoryToPosition(start, startLocation);\n    var endPos = this.categoryToPosition(end, endLocation);\n    return this.getPositionRangePath(startPos, endPos); // Base class (Axis) gets range shape from AxisRenderer\n  };\n  /**\r\n   * Takes an absolute position (px) within axis and adjust it to a specific\r\n   * `location` within category it corresponds to.\r\n   *\r\n   * @param position  Source position (px)\r\n   * @param location  Location within category (0-1)\r\n   * @return Adjusted position (px)\r\n   */\n\n\n  CategoryAxis.prototype.roundPosition = function (position, location) {\n    var index = this.positionToIndex(position);\n    return this.indexToPosition(index, location);\n  };\n  /**\r\n   * Finds and returns first series data item with specific category\r\n   * @param series    Target series\r\n   * @param category  Category\r\n   * @return XYSeriesDataItem data item\r\n   */\n\n\n  CategoryAxis.prototype.getFirstSeriesDataItem = function (series, category) {\n    for (var i = 0; i < series.dataItems.length; i++) {\n      var dataItem = series.dataItems.getIndex(i);\n\n      if (series.xAxis == this) {\n        if (dataItem.categoryX == category) {\n          return dataItem;\n        }\n      }\n\n      if (series.yAxis == this) {\n        if (dataItem.categoryY == category) {\n          return dataItem;\n        }\n      }\n    }\n  };\n  /**\r\n   * Finds and returns last series data item with specific category.\r\n   * @param series    Target series\r\n   * @param category  Category\r\n   * @return XYSeriesDataItem data item\r\n   */\n\n\n  CategoryAxis.prototype.getLastSeriesDataItem = function (series, category) {\n    for (var i = series.dataItems.length - 1; i >= 0; i--) {\n      var dataItem = series.dataItems.getIndex(i);\n\n      if (series.xAxis == this) {\n        if (dataItem.categoryX == category) {\n          return dataItem;\n        }\n      }\n\n      if (series.yAxis == this) {\n        if (dataItem.categoryY == category) {\n          return dataItem;\n        }\n      }\n    }\n  }; // todo: optimize\n\n\n  CategoryAxis.prototype.getSeriesDataItemByCategory = function (category, series) {\n    var _this = this;\n\n    var seriesDataItem;\n    series.dataItems.each(function (dataItem) {\n      if (series.xAxis == _this) {\n        if (dataItem.categoryX == category) {\n          seriesDataItem = dataItem;\n        }\n      } else if (series.yAxis == _this) {\n        if (dataItem.categoryY == category) {\n          seriesDataItem = dataItem;\n        }\n      }\n    });\n    return seriesDataItem;\n  };\n  /**\r\n   * Returns a data item from Series that corresponds to a specific absolute\r\n   * position on the Axis.\r\n   *\r\n   * @param series    Target series\r\n   * @param position  Position (px)\r\n   * @return XYSeriesDataItem data item\r\n   */\n\n\n  CategoryAxis.prototype.getSeriesDataItem = function (series, position, findNearest) {\n    var _this = this;\n\n    if ($type.isNumber(position)) {\n      var index_1 = this.positionToIndex(position);\n\n      if (index_1 >= this.dataItems.length) {\n        index_1--;\n      }\n\n      var dataItem = this.dataItems.getIndex(index_1);\n\n      if (dataItem) {\n        var category_1 = dataItem.category;\n        var sdi_1;\n        var seriesDataItem = series.dataItems.getIndex(index_1);\n\n        if (seriesDataItem) {\n          if (series.xAxis == this) {\n            if (seriesDataItem.categoryX == category_1) {\n              return seriesDataItem;\n            }\n          }\n\n          if (series.yAxis == this) {\n            if (seriesDataItem.categoryY == category_1) {\n              return seriesDataItem;\n            }\n          }\n        }\n\n        series.dataItems.each(function (dataItem) {\n          if (series.xAxis == _this) {\n            if (dataItem.categoryX == category_1) {\n              if (!sdi_1) {\n                sdi_1 = dataItem;\n              }\n\n              if (Math.abs(index_1 - sdi_1.index) > Math.abs(index_1 - dataItem.index)) {\n                sdi_1 = dataItem;\n              }\n            }\n          }\n\n          if (series.yAxis == _this) {\n            if (dataItem.categoryY == category_1) {\n              if (!sdi_1) {\n                sdi_1 = dataItem;\n              }\n\n              if (Math.abs(index_1 - sdi_1.index) > Math.abs(index_1 - dataItem.index)) {\n                sdi_1 = dataItem;\n              }\n            }\n          }\n        }); //@todo\n\n        if (findNearest) {}\n\n        return sdi_1;\n      }\n    }\n  };\n  /**\r\n   * Returns the X coordinate for series' data item.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @todo Description (review)\r\n   * @param dataItem  Data item\r\n   * @param key       Category\r\n   * @param location  Location (0-1)\r\n   * @return X coordinate (px)\r\n   */\n\n\n  CategoryAxis.prototype.getX = function (dataItem, key, location, stackKey, range) {\n    var position = this.getPositionX(dataItem, key, location, stackKey, range);\n\n    if ($type.isNaN(position)) {\n      return this.basePoint.x;\n    } else {\n      return this.renderer.positionToPoint(position).x;\n    }\n  };\n  /**\r\n   * Returns relative position on axis for series' data item.\r\n   *\r\n   * @since 4.5.14\r\n   * @param  dataItem  Data item\r\n   * @param  key       Category\r\n   * @param  location  Location (0-1)\r\n   * @return           Relative position\r\n   */\n\n\n  CategoryAxis.prototype.getPositionX = function (dataItem, key, location, stackKey, range) {\n    var position;\n\n    if ($type.hasValue(key)) {\n      position = this.categoryToPosition(dataItem.categories[key], location);\n    }\n\n    if (range) {\n      position = $math.fitToRange(position, range.start, range.end);\n    }\n\n    return position;\n  };\n  /**\r\n   * Returns the Y coordinate for series' data item.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @todo Description (review)\r\n   * @param dataItem  Data item\r\n   * @param key       Category\r\n   * @param location  Location (0-1)\r\n   * @return Y coordinate (px)\r\n   */\n\n\n  CategoryAxis.prototype.getY = function (dataItem, key, location, stackKey, range) {\n    var position = this.getPositionY(dataItem, key, location, stackKey, range);\n\n    if ($type.isNaN(position)) {\n      return this.basePoint.y;\n    } else {\n      return this.renderer.positionToPoint(position).y;\n    }\n  };\n  /**\r\n   * Returns relative position on axis for series' data item.\r\n   *\r\n   * @since 4.5.14\r\n   * @param  dataItem  Data item\r\n   * @param  key       Category\r\n   * @param  location  Location (0-1)\r\n   * @return           Relative position\r\n   */\n\n\n  CategoryAxis.prototype.getPositionY = function (dataItem, key, location, stackKey, range) {\n    var position;\n\n    if ($type.hasValue(key)) {\n      position = this.categoryToPosition(dataItem.categories[key], location);\n    }\n\n    if (range) {\n      position = $math.fitToRange(position, range.start, range.end);\n    }\n\n    return position;\n  };\n  /**\r\n   * Returns an angle for series data item.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @todo Description (review)\r\n   * @param dataItem  Data item\r\n   * @param key       Category\r\n   * @param location  Location (0-1)\r\n   * @param stackKey  Stack key (?)\r\n   * @param range Range to fit in\r\n   * @return Angle\r\n   */\n\n\n  CategoryAxis.prototype.getAngle = function (dataItem, key, location, stackKey, range) {\n    var position = this.categoryToPosition(dataItem.categories[key], location);\n\n    if (range) {\n      position = $math.fitToRange(position, range.start, range.end);\n    }\n\n    return this.positionToAngle(position);\n  };\n  /**\r\n   * Returns an absolute pixel coordinate of the start of the cell (category),\r\n   * that specific position value falls into.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @todo Description (review)\r\n   * @param position  Position (px)\r\n   * @return Cell start position (px)\r\n   */\n\n\n  CategoryAxis.prototype.getCellStartPosition = function (position) {\n    return this.roundPosition(position, 0);\n  };\n  /**\r\n   * Returns an absolute pixel coordinate of the end of the cell (category),\r\n   * that specific position value falls into.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @todo Description (review)\r\n   * @param position  Position (px)\r\n   * @return Cell end position (px)\r\n   */\n\n\n  CategoryAxis.prototype.getCellEndPosition = function (position) {\n    return this.roundPosition(position, 1);\n  };\n  /**\r\n   * Returns text to show in a category tooltip, based on specific position\r\n   * within axis.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param position  Position (px)\r\n   * @return Label (category)\r\n   */\n\n\n  CategoryAxis.prototype.getTooltipText = function (position) {\n    var dataItem = this.dataItems.getIndex(this.positionToIndex(position));\n\n    if (dataItem) {\n      this.tooltipDataItem = dataItem;\n      this.tooltip.dataItem = dataItem;\n\n      if (this.tooltipText) {\n        return this.tooltipText;\n      }\n\n      if (!this._adapterO) {\n        return dataItem.category;\n      } else {\n        return this._adapterO.apply(\"getTooltipText\", dataItem.category);\n      }\n    }\n  };\n  /**\r\n   * Returns an index of the category that corresponds to specific pixel\r\n   * position within axis.\r\n   *\r\n   * @param position  Position (px)\r\n   * @return Category index\r\n   */\n\n\n  CategoryAxis.prototype.positionToIndex = function (position) {\n    position = $math.round(position, 10);\n\n    if (position < 0) {\n      position = 0;\n    }\n\n    if (position > 1) {\n      position = 1;\n    }\n\n    var startIndex = this.startIndex;\n    var endIndex = this.endIndex;\n    var difference = endIndex - startIndex - this.startLocation - (1 - this.endLocation);\n    position += 1 / difference * this.startLocation;\n    var index = null;\n\n    if (this._axisBreaks) {\n      var axisBreaks = this._axisBreaks; // in case we have some axis breaks\n\n      $iter.eachContinue(axisBreaks.iterator(), function (axisBreak) {\n        var breakStartPosition = axisBreak.startPosition;\n        var breakEndPosition = axisBreak.endPosition;\n        var breakStartIndex = axisBreak.adjustedStartValue;\n        var breakEndIndex = axisBreak.adjustedEndValue;\n        breakStartIndex = $math.max(breakStartIndex, startIndex);\n        breakEndIndex = $math.min(breakEndIndex, endIndex);\n        var breakSize = axisBreak.breakSize;\n        difference -= (breakEndIndex - breakStartIndex) * (1 - breakSize); // position to the right of break end\n\n        if (position > breakEndPosition) {\n          startIndex += (breakEndIndex - breakStartIndex) * (1 - breakSize);\n        } // position to the left of break start\n        else if (position < breakStartPosition) {} // value within break\n        else {\n          var breakPosition = (position - breakStartPosition) / (breakEndPosition - breakStartPosition);\n          index = breakStartIndex + Math.round(breakPosition * (breakEndIndex - breakStartIndex));\n          return false;\n        }\n\n        return true;\n      });\n    }\n\n    if (!$type.isNumber(index)) {\n      index = Math.floor(position * difference + startIndex);\n    }\n\n    if (index >= this.dataItems.length) {\n      index = this.dataItems.length - 1;\n    } // not good, when panning out of bounds, each time one less item gets selected\n    //if (index >= endIndex) {\n    //\tindex--;\n    //}\n\n\n    return index;\n  };\n  /**\r\n   * Returns category based on position.\r\n   *\r\n   * Please note that `position` represents position within axis which may be\r\n   * zoomed and not correspond to Cursor's `position`.\r\n   *\r\n   * To convert Cursor's `position` to Axis' `position` use `toAxisPosition()` method.\r\n   *\r\n   * This is a synonim of `getPositionLabel()` implemented here for consistentcy.\r\n   *\r\n   * @since 4.3.8\r\n   * @see {@link https://www.amcharts.com/docs/v4/tutorials/tracking-cursors-position-via-api/#Tracking_Cursor_s_position} For more information about cursor tracking.\r\n   * @param position  Relative position on axis (0-1)\r\n   * @return Position label\r\n   */\n\n\n  CategoryAxis.prototype.positionToCategory = function (position) {\n    return this.getPositionLabel(position);\n  };\n  /**\r\n   * Returns category based on position.\r\n   *\r\n   * Please note that `position` represents position within axis which may be\r\n   * zoomed and not correspond to Cursor's `position`.\r\n   *\r\n   * To convert Cursor's `position` to Axis' `position` use `toAxisPosition()` method.\r\n   *\r\n   * @see {@link https://www.amcharts.com/docs/v4/tutorials/tracking-cursors-position-via-api/#Tracking_Cursor_s_position} For more information about cursor tracking.\r\n   * @param position  Relative position on axis (0-1)\r\n   * @return Position label\r\n   */\n\n\n  CategoryAxis.prototype.getPositionLabel = function (position) {\n    var dataItem = this.dataItems.getIndex(this.positionToIndex(position));\n\n    if (dataItem) {\n      return dataItem.category;\n    }\n  };\n\n  Object.defineProperty(CategoryAxis.prototype, \"basePoint\", {\n    /**\r\n     * Coordinates of the actual axis start.\r\n     *\r\n     * @ignore Exclude from docs\r\n     * @return Base point\r\n     */\n    get: function () {\n      // This makes base grid to be drawn at the end of the axis and adds extra\n      // grid which we need to nicely close the chart.\n      return this.renderer.positionToPoint(1);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\r\n   * Initializes Axis' renderer.\r\n   *\r\n   * @ignore Exclude from docs\r\n   */\n\n  CategoryAxis.prototype.initRenderer = function () {\n    _super.prototype.initRenderer.call(this);\n\n    var renderer = this.renderer;\n    renderer.baseGrid.disabled = true;\n  };\n\n  Object.defineProperty(CategoryAxis.prototype, \"frequency\", {\n    /**\r\n     * Current frequency of labels of the axis.\r\n     *\r\n     * Normally it would be 1, but when labels start to be hidden due\r\n     * to `minGridDistance` this read-only property will increase.\r\n     *\r\n     * @readonly\r\n     * @since 4.2.0\r\n     * @return Label frequency\r\n     */\n    get: function () {\n      return this._frequency;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(CategoryAxis.prototype, \"sortBySeries\", {\n    /**\r\n     * @return Sort categories?\r\n     */\n    get: function () {\n      return this.getPropertyValue(\"sortBySeries\");\n    },\n\n    /**\r\n     * If set to a reference of [[ColumnSeries]] the categories will be sorted\r\n     * by actual values.\r\n     *\r\n     * The categories are ordered in descending order (from highest values to\r\n     * lowest). To reverse the order, use axis renderer's `inversed` setting.\r\n     * E.g.:\r\n     *\r\n     * ```TypeScript\r\n     * categoryAxis.sortBySeries = series;\r\n     * categoryAxis.renderer.inversed = true;\r\n     * ```\r\n     * ```JavaScript\r\n     * categoryAxis.sortBySeries = series;\r\n     * categoryAxis.renderer.inversed = true;\r\n     * ```\r\n     * ```JSON\r\n     * {\r\n     *   // ...\r\n     *   \"xAxes\": [{\r\n     *     // ...\r\n     *     \"sortBySeries\": \"s1\",\r\n     *     \"renderer\": {\r\n     *       // ...\r\n     *       \"inversed\": true\r\n     *     }\r\n     *   }]\r\n     * }\r\n     * ```\r\n     *\r\n     * @since 4.8.7\r\n     * @param  value  Sort categories?\r\n     */\n    set: function (value) {\n      this.setPropertyValue(\"sortBySeries\", value, true);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\r\n   * Processes JSON-based config before it is applied to the object.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param config  Config\r\n   */\n\n  CategoryAxis.prototype.processConfig = function (config) {\n    if (config) {\n      if ($type.hasValue(config.sortBySeries) && $type.isString(config.sortBySeries)) {\n        if (this.map.hasKey(config.sortBySeries)) {\n          config.sortBySeries = this.map.getKey(config.sortBySeries);\n        } else {\n          this.addDelayedMap(\"sortBySeries\", config.sortBySeries);\n          delete config.sortBySeries;\n        }\n      }\n    }\n\n    _super.prototype.processConfig.call(this, config);\n  };\n\n  return CategoryAxis;\n}(Axis);\n\nexport { CategoryAxis };\n/**\r\n * Register class, so that it can be instantiated using its name from\r\n * anywhere.\r\n *\r\n * @ignore\r\n */\n\nregistry.registeredClasses[\"CategoryAxis\"] = CategoryAxis;\nregistry.registeredClasses[\"CategoryAxisDataItem\"] = CategoryAxisDataItem;","map":{"version":3,"names":["__extends","Axis","AxisDataItem","AxisRendererX","AxisRendererY","registry","Dictionary","CategoryAxisBreak","$math","$type","$iter","CategoryAxisDataItem","_super","_this","call","seriesDataItems","className","text","locations","category","endCategory","deltaPosition","applyTheme","Object","defineProperty","prototype","get","_adapterO","isEnabled","apply","properties","set","value","oldCategory","setProperty","hasValue","component","validateDataElement","enumerable","configurable","deltaCoordinate","invalidateDataItems","invalidateSeries","CategoryAxis","dataItemsByCategory","axisFieldName","_lastDataItem","createDataItem","_disposers","push","addDisposer","mainDataSet","events","on","event","removeKey","oldValue","createAxisBreak","processSeriesDataItem","dataItem","axisLetter","categoryAxisDataItem","getKey","seriesId","uid","dataItems","remove","validateDataRange","each","_series","iterator","series","xAxis","yAxis","invalidateDataRange","startIndex","positionToIndex","start","endIndex","end","length","minIndex","maxIndex","i","axisDataItem","getIndex","i_1","seriesDataItem","index","isNumber","_axisBreaks","validate","dataCount","fitToRange","Math","floor","ceil","renderer","invalid","maxCount","axisLength","max","minGridDistance","Number","MAX_SAFE_INTEGER","frequency","min","_startIndex","_endIndex","fixAxisBreaks","_frequency","maxZoomFactor","resetIterators","itemIndex","__disabled","len","round","axisBreak","isInBreak","appendDataItem","axisBreaks","adjustedStartValue","adjustedEndValue","intersect","b","frequency_1","breakSize","itemIndex_1","validateBreaks","validateAxisRanges","ghostLabel","invalidate","invalidateLayout","_axisItemCount","categoryToIndex","position","indexToPosition","endPosition","fillEndIndex","fillPosition","fillEndPosition","isRange","point","positionToPoint","tick","disabled","updateTickElement","grid","updateGridElement","label","undefined","updateLabelElement","measuredWidth","measuredHeight","html","currentText","fill","axisFill","location","updateFillElement","fillRule","bullet","updateBullet","mask","disposeData","clear","processDataItem","dataContext","setKey","getDataItem","dataFields","create","difference","adjustDifference","startLocation","endLocation","eachContinue","breakStartIndex","breakEndIndex","categoryToPosition","categoryToPoint","angle","positionToAngle","x","y","anyToPoint","anyToPosition","zoomToCategories","startCategory","zoomToIndexes","getAnyRangePath","startPos","endPos","getPositionRangePath","roundPosition","getFirstSeriesDataItem","categoryX","categoryY","getLastSeriesDataItem","getSeriesDataItemByCategory","getSeriesDataItem","findNearest","index_1","category_1","sdi_1","abs","getX","key","stackKey","range","getPositionX","isNaN","basePoint","categories","getY","getPositionY","getAngle","getCellStartPosition","getCellEndPosition","getTooltipText","tooltipDataItem","tooltip","tooltipText","breakStartPosition","startPosition","breakEndPosition","breakPosition","positionToCategory","getPositionLabel","initRenderer","baseGrid","getPropertyValue","setPropertyValue","processConfig","config","sortBySeries","isString","map","hasKey","addDelayedMap","registeredClasses"],"sources":["D:/APPLICATION/UI/UPL/NEW/node_modules/@amcharts/amcharts4/.internal/charts/axes/CategoryAxis.js"],"sourcesContent":["/**\r\n * Category axis module\r\n */\r\nimport { __extends } from \"tslib\";\r\n/**\r\n * ============================================================================\r\n * IMPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\r\nimport { Axis, AxisDataItem } from \"./Axis\";\r\nimport { AxisRendererX } from \"./AxisRendererX\";\r\nimport { AxisRendererY } from \"./AxisRendererY\";\r\nimport { registry } from \"../../core/Registry\";\r\nimport { Dictionary } from \"../../core/utils/Dictionary\";\r\nimport { CategoryAxisBreak } from \"./CategoryAxisBreak\";\r\nimport * as $math from \"../../core/utils/Math\";\r\nimport * as $type from \"../../core/utils/Type\";\r\nimport * as $iter from \"../../core/utils/Iterator\";\r\n/**\r\n * ============================================================================\r\n * DATA ITEM\r\n * ============================================================================\r\n * @hidden\r\n */\r\n/**\r\n * Defines a [[DataItem]] for [[CategoryAxis]].\r\n *\r\n * @see {@link DataItem}\r\n */\r\nvar CategoryAxisDataItem = /** @class */ (function (_super) {\r\n    __extends(CategoryAxisDataItem, _super);\r\n    /**\r\n     * Constructor\r\n     */\r\n    function CategoryAxisDataItem() {\r\n        var _this = _super.call(this) || this;\r\n        _this.seriesDataItems = {};\r\n        _this.className = \"CategoryAxisDataItem\";\r\n        _this.text = \"{category}\";\r\n        _this.locations.category = 0;\r\n        _this.locations.endCategory = 1;\r\n        _this.deltaPosition = 0;\r\n        _this.applyTheme();\r\n        return _this;\r\n    }\r\n    Object.defineProperty(CategoryAxisDataItem.prototype, \"category\", {\r\n        /**\r\n         * @return Category\r\n         */\r\n        get: function () {\r\n            if (this._adapterO) {\r\n                if (this._adapterO.isEnabled(\"category\")) {\r\n                    return this._adapterO.apply(\"category\", this.properties.category);\r\n                }\r\n            }\r\n            return this.properties.category;\r\n        },\r\n        /**\r\n         * Category.\r\n         *\r\n         * @param value  Category\r\n         */\r\n        set: function (value) {\r\n            var oldCategory = this.properties.category;\r\n            this.setProperty(\"category\", value);\r\n            if ($type.hasValue(oldCategory) && oldCategory != value) {\r\n                if (this.component) {\r\n                    this.component.validateDataElement(this);\r\n                }\r\n            }\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(CategoryAxisDataItem.prototype, \"endCategory\", {\r\n        /**\r\n         * @return End category\r\n         */\r\n        get: function () {\r\n            return this.properties.endCategory;\r\n        },\r\n        /**\r\n         * End category.\r\n         *\r\n         * Used for items that span several categories, like [[CategoryAxisBreak]].\r\n         *\r\n         * @param value  End category\r\n         */\r\n        set: function (value) {\r\n            this.setProperty(\"endCategory\", value);\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(CategoryAxisDataItem.prototype, \"deltaPosition\", {\r\n        get: function () {\r\n            return this.properties.deltaCoordinate;\r\n        },\r\n        set: function (value) {\r\n            if (value != this.properties.deltaCoordinate) {\r\n                this.setProperty(\"deltaCoordinate\", value);\r\n                if (this.component) {\r\n                    this.component.invalidateDataItems();\r\n                    this.component.invalidateSeries();\r\n                }\r\n            }\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    return CategoryAxisDataItem;\r\n}(AxisDataItem));\r\nexport { CategoryAxisDataItem };\r\n/**\r\n * ============================================================================\r\n * MAIN CLASS\r\n * ============================================================================\r\n * @hidden\r\n */\r\n/**\r\n * Used to create a category-based axis for the chart.\r\n *\r\n * ```TypeScript\r\n * // Create the axis\r\n * let xAxis = chart.xAxes.push(new am4charts.CategoryAxis());\r\n *\r\n * // Set settings\r\n * xAxis.title.text = \"Clients\";\r\n * ```\r\n * ```JavaScript\r\n * // Create the axis\r\n * var valueAxis = chart.xAxes.push(new am4charts.CategoryAxis());\r\n *\r\n * // Set settings\r\n * valueAxis.title.text = \"Clients\";\r\n * ```\r\n * ```JSON\r\n * \"xAxes\": [{\r\n *   \"type\": \"CategoryAxis\",\r\n *   \"title\": {\r\n *     \"text\": \"Clients\"\r\n *   }\r\n * }]\r\n * ```\r\n *\r\n * @see {@link ICategoryAxisEvents} for a list of available Events\r\n * @see {@link ICategoryAxisAdapters} for a list of available Adapters\r\n * @important\r\n */\r\nvar CategoryAxis = /** @class */ (function (_super) {\r\n    __extends(CategoryAxis, _super);\r\n    /**\r\n     * Constructor\r\n     */\r\n    function CategoryAxis() {\r\n        var _this = \r\n        // Init\r\n        _super.call(this) || this;\r\n        /**\r\n         * A collection that holds Axis' data items sorted by each category.\r\n         */\r\n        _this.dataItemsByCategory = new Dictionary();\r\n        _this.className = \"CategoryAxis\";\r\n        // Set field name\r\n        _this.axisFieldName = \"category\";\r\n        _this._lastDataItem = _this.createDataItem();\r\n        _this._lastDataItem.component = _this;\r\n        _this._disposers.push(_this._lastDataItem);\r\n        // Apply theme\r\n        _this.applyTheme();\r\n        var dataItemsByCategory = _this.dataItemsByCategory;\r\n        _this.addDisposer(_this.mainDataSet.events.on(\"removed\", function (event) {\r\n            dataItemsByCategory.removeKey(event.oldValue.category);\r\n        }));\r\n        return _this;\r\n    }\r\n    /**\r\n     * Returns a new/empty [[DataItem]] of the type appropriate for this object.\r\n     *\r\n     * @see {@link DataItem}\r\n     * @return Data Item\r\n     */\r\n    CategoryAxis.prototype.createDataItem = function () {\r\n        return new CategoryAxisDataItem();\r\n    };\r\n    /**\r\n     * Returns a new/empty [[AxisBreak]] of the appropriate type.\r\n     *\r\n     * @return Axis break\r\n     */\r\n    CategoryAxis.prototype.createAxisBreak = function () {\r\n        return new CategoryAxisBreak();\r\n    };\r\n    /**\r\n     * Processes a related series' data item.\r\n     *\r\n     * @ignore Exclude from docs\r\n     * @todo Description\r\n     * @param dataItem  Data item\r\n     */\r\n    CategoryAxis.prototype.processSeriesDataItem = function (dataItem, axisLetter) {\r\n        _super.prototype.processSeriesDataItem.call(this, dataItem, axisLetter);\r\n        var category = dataItem[\"category\" + this.axisLetter];\r\n        if ($type.hasValue(category)) {\r\n            var categoryAxisDataItem = this.dataItemsByCategory.getKey(category);\r\n            if (categoryAxisDataItem) {\r\n                var seriesId = dataItem.component.uid;\r\n                var seriesDataItems = categoryAxisDataItem.seriesDataItems[seriesId];\r\n                if (!seriesDataItems) {\r\n                    seriesDataItems = [];\r\n                    categoryAxisDataItem.seriesDataItems[seriesId] = seriesDataItems;\r\n                }\r\n                seriesDataItems.push(dataItem);\r\n            }\r\n        }\r\n        else {\r\n            dataItem.component.dataItems.remove(dataItem);\r\n        }\r\n    };\r\n    /**\r\n     * Validates the data range.\r\n     *\r\n     * @ignore Exclude from docs\r\n     * @todo Description (review)\r\n     */\r\n    CategoryAxis.prototype.validateDataRange = function () {\r\n        var _this = this;\r\n        _super.prototype.validateDataRange.call(this);\r\n        $iter.each(this._series.iterator(), function (series) {\r\n            if ((series.xAxis instanceof CategoryAxis) && (series.yAxis instanceof CategoryAxis)) {\r\n                series.invalidateDataRange();\r\n            }\r\n            else {\r\n                var startIndex = _this.positionToIndex(_this.start);\r\n                var endIndex = _this.positionToIndex(_this.end);\r\n                if (endIndex >= _this.dataItems.length) {\r\n                    endIndex--;\r\n                }\r\n                var seriesId = series.uid;\r\n                var minIndex = void 0;\r\n                var maxIndex = void 0;\r\n                for (var i = startIndex; i <= endIndex; i++) {\r\n                    var axisDataItem = _this.dataItems.getIndex(i);\r\n                    if (axisDataItem) {\r\n                        var seriesDataItems = axisDataItem.seriesDataItems[seriesId];\r\n                        if (seriesDataItems) {\r\n                            for (var i_1 = 0; i_1 < seriesDataItems.length; i_1++) {\r\n                                var seriesDataItem = seriesDataItems[i_1];\r\n                                if (seriesDataItem) {\r\n                                    var index = seriesDataItem.index;\r\n                                    if (!$type.isNumber(minIndex) || index < minIndex) {\r\n                                        minIndex = index;\r\n                                    }\r\n                                    if (!$type.isNumber(maxIndex) || index > maxIndex) {\r\n                                        maxIndex = index;\r\n                                    }\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n                if ($type.isNumber(minIndex)) {\r\n                    series.startIndex = minIndex;\r\n                }\r\n                else {\r\n                    series.start = _this.start;\r\n                }\r\n                if ($type.isNumber(maxIndex)) {\r\n                    series.endIndex = maxIndex + 1;\r\n                }\r\n                else {\r\n                    series.end = _this.end;\r\n                }\r\n                // range might not change, but axis breaks might.\r\n                if (_this._axisBreaks && _this._axisBreaks.length > 0) {\r\n                    series.invalidateDataRange();\r\n                }\r\n            }\r\n        });\r\n    };\r\n    /**\r\n     * Validates the whole axis. Causes it to redraw.\r\n     *\r\n     * @ignore Exclude from docs\r\n     * @todo Description (review)\r\n     */\r\n    CategoryAxis.prototype.validate = function () {\r\n        var _this = this;\r\n        _super.prototype.validate.call(this);\r\n        var dataCount = this.dataItems.length;\r\n        var startIndex = $math.fitToRange(Math.floor(this.start * dataCount - 1), 0, dataCount);\r\n        var endIndex = $math.fitToRange(Math.ceil(this.end * dataCount), 0, dataCount);\r\n        if (this.renderer.invalid) {\r\n            this.renderer.validate();\r\n        }\r\n        // find frequency at which we'll show items\r\n        var maxCount = this.renderer.axisLength / Math.max(this.renderer.minGridDistance, 1 / Number.MAX_SAFE_INTEGER);\r\n        var frequency = Math.min(this.dataItems.length, Math.ceil((endIndex - startIndex) / maxCount));\r\n        this._startIndex = Math.floor(startIndex / frequency) * frequency;\r\n        this._endIndex = Math.ceil(this.end * dataCount);\r\n        this.fixAxisBreaks();\r\n        if (this._startIndex == this._endIndex) {\r\n            this._endIndex++;\r\n        }\r\n        this._frequency = frequency;\r\n        if (this.axisLength <= 0) {\r\n            return;\r\n        }\r\n        this.maxZoomFactor = this.dataItems.length;\r\n        if (this.dataItems.length <= 0) {\r\n            this.maxZoomFactor = 1;\r\n        }\r\n        this.resetIterators();\r\n        // it's important to use protected variables here, as getters will return 0 - length\r\n        // TODO use iterator instead\r\n        // @ todo: not solved cat axis item fading\r\n        startIndex = $math.max(0, this._startIndex - this._frequency);\r\n        endIndex = $math.min(this.dataItems.length, this._endIndex + this._frequency);\r\n        var itemIndex = 0;\r\n        for (var i = 0; i < startIndex; i++) {\r\n            var dataItem = this.dataItems.getIndex(i);\r\n            dataItem.__disabled = true;\r\n        }\r\n        for (var i = endIndex, len = this.dataItems.length; i < len; i++) {\r\n            var dataItem = this.dataItems.getIndex(i);\r\n            dataItem.__disabled = true;\r\n        }\r\n        for (var i = startIndex; i < endIndex; i++) {\r\n            if (i < this.dataItems.length) {\r\n                var dataItem = this.dataItems.getIndex(i);\r\n                if (i / this._frequency == Math.round(i / this._frequency)) {\r\n                    var axisBreak = this.isInBreak(i);\r\n                    if (!axisBreak) {\r\n                        this.appendDataItem(dataItem);\r\n                        this.validateDataElement(dataItem, itemIndex);\r\n                    }\r\n                    itemIndex++;\r\n                }\r\n                else {\r\n                    //previously we disabled all before, but this is better for cpu\r\n                    //this.validateDataElement(dataItem, itemIndex); // helps to solve shrinking // not good - creates all items\r\n                    dataItem.__disabled = true;\r\n                }\r\n            }\r\n        }\r\n        this.appendDataItem(this._lastDataItem);\r\n        this.validateDataElement(this._lastDataItem, itemIndex + 1, this.dataItems.length);\r\n        if (this._axisBreaks) {\r\n            var axisBreaks = this._axisBreaks;\r\n            axisBreaks.each(function (axisBreak) {\r\n                var adjustedStartValue = axisBreak.adjustedStartValue;\r\n                var adjustedEndValue = axisBreak.adjustedEndValue;\r\n                if ($math.intersect({ start: adjustedStartValue, end: adjustedEndValue }, { start: _this._startIndex, end: _this._endIndex })) {\r\n                    for (var b = adjustedStartValue; b <= adjustedEndValue; b++) {\r\n                        var dataItem = _this.dataItems.getIndex(b);\r\n                        dataItem.__disabled = true;\r\n                    }\r\n                    var frequency_1 = $math.fitToRange(Math.ceil(_this._frequency / axisBreak.breakSize), 1, adjustedEndValue - adjustedStartValue);\r\n                    var itemIndex_1 = 0;\r\n                    if (axisBreak.breakSize > 0) {\r\n                        // TODO use iterator instead\r\n                        for (var b = adjustedStartValue; b <= adjustedEndValue; b = b + frequency_1) {\r\n                            var dataItem = _this.dataItems.getIndex(b);\r\n                            dataItem.__disabled = false;\r\n                            _this.appendDataItem(dataItem);\r\n                            _this.validateDataElement(dataItem, itemIndex_1);\r\n                            itemIndex_1++;\r\n                        }\r\n                    }\r\n                }\r\n            });\r\n        }\r\n        this.validateBreaks();\r\n        this.validateAxisRanges();\r\n        this.ghostLabel.invalidate(); // solves font issue\r\n        this.renderer.invalidateLayout();\r\n    };\r\n    /**\r\n     * [validateDataElement description]\r\n     *\r\n     * @ignore Exclude from docs\r\n     * @todo Description\r\n     * @param dataItem   [description]\r\n     * @param itemIndex  [description]\r\n     */\r\n    CategoryAxis.prototype.validateDataElement = function (dataItem, itemIndex, index) {\r\n        _super.prototype.validateDataElement.call(this, dataItem);\r\n        dataItem.itemIndex = this._axisItemCount;\r\n        this._axisItemCount++;\r\n        //dataItem.__disabled = false;\r\n        var renderer = this.renderer;\r\n        if (!$type.isNumber(index)) {\r\n            index = this.categoryToIndex(dataItem.category);\r\n        }\r\n        var endIndex = this.categoryToIndex(dataItem.endCategory);\r\n        if (!$type.isNumber(endIndex)) {\r\n            endIndex = index;\r\n        }\r\n        var position = this.indexToPosition(index, dataItem.locations.category);\r\n        var endPosition = this.indexToPosition(endIndex, dataItem.locations.endCategory);\r\n        dataItem.position = position;\r\n        var fillEndIndex;\r\n        var fillPosition;\r\n        var fillEndPosition;\r\n        if (dataItem.isRange) {\r\n            fillEndIndex = endIndex;\r\n            fillPosition = this.indexToPosition(index, dataItem.locations.category);\r\n            fillEndPosition = this.indexToPosition(fillEndIndex, dataItem.locations.endCategory);\r\n        }\r\n        dataItem.point = renderer.positionToPoint(position);\r\n        var tick = dataItem.tick;\r\n        if (tick && !tick.disabled) {\r\n            renderer.updateTickElement(tick, position, endPosition);\r\n        }\r\n        var grid = dataItem.grid;\r\n        if (grid && !grid.disabled) {\r\n            renderer.updateGridElement(grid, position, endPosition);\r\n        }\r\n        var label = dataItem.label;\r\n        if (label && !label.disabled) {\r\n            // theorethically this might result problems if category text changes, the range text won't change. But otherwise range.label.text = \"custom text\" won't work, which is not intuitive.\r\n            if (!dataItem.isRange || label.text == undefined) {\r\n                dataItem.text = dataItem.text;\r\n            }\r\n            renderer.updateLabelElement(label, position, endPosition);\r\n            if ((renderer instanceof AxisRendererY && dataItem.label.measuredWidth > this.ghostLabel.measuredWidth) || (renderer instanceof AxisRendererX && dataItem.label.measuredHeight > this.ghostLabel.measuredHeight)) {\r\n                if (dataItem.label.html) {\r\n                    this.ghostLabel.html = dataItem.label.currentText;\r\n                }\r\n                else {\r\n                    this.ghostLabel.text = dataItem.label.currentText;\r\n                }\r\n            }\r\n        }\r\n        var fill = dataItem.axisFill;\r\n        if (fill && !fill.disabled) {\r\n            if (!dataItem.isRange) {\r\n                fillEndIndex = index + this._frequency;\r\n                fillPosition = this.indexToPosition(index, fill.location);\r\n                fillEndPosition = this.indexToPosition(fillEndIndex, fill.location);\r\n            }\r\n            renderer.updateFillElement(fill, fillPosition, fillEndPosition);\r\n            if (!dataItem.isRange) {\r\n                this.fillRule(dataItem, itemIndex);\r\n            }\r\n        }\r\n        if (dataItem.bullet) {\r\n            renderer.updateBullet(dataItem.bullet, position, endPosition);\r\n        }\r\n        var mask = dataItem.mask;\r\n        if (mask) {\r\n            renderer.updateFillElement(mask, fillPosition, fillEndPosition);\r\n        }\r\n    };\r\n    /**\r\n     * @ignore\r\n     */\r\n    CategoryAxis.prototype.disposeData = function () {\r\n        this.dataItemsByCategory.clear();\r\n        _super.prototype.disposeData.call(this);\r\n    };\r\n    /**\r\n     * Processes the axis data item.\r\n     *\r\n     * @ignore Exclude from docs\r\n     * @param dataItem     Data item\r\n     * @param dataContext  The raw data that corresponds to this data item\r\n     */\r\n    CategoryAxis.prototype.processDataItem = function (dataItem, dataContext) {\r\n        if (dataItem) {\r\n            // creat a collection for fast access\r\n            _super.prototype.processDataItem.call(this, dataItem, dataContext);\r\n            // check if such category already exists\r\n            //let existingDataItem: CategoryAxisDataItem = this.dataItemsByCategory.getKey(dataItem.category);\r\n            //if (existingDataItem && existingDataItem != dataItem) {\r\n            //\tthis.dataItems.remove(existingDataItem);\r\n            //}\r\n            if ($type.hasValue(dataItem.category)) {\r\n                this.dataItemsByCategory.setKey(dataItem.category, dataItem);\r\n            }\r\n        }\r\n    };\r\n    CategoryAxis.prototype.getDataItem = function (dataContext) {\r\n        var category = (dataContext[this.dataFields.category]);\r\n        if ($type.hasValue(category)) {\r\n            var dataItem = this.dataItemsByCategory.getKey(category);\r\n            if (dataItem) {\r\n                return dataItem;\r\n            }\r\n            else {\r\n                return this.dataItems.create();\r\n            }\r\n        }\r\n    };\r\n    /**\r\n     * Converts a category index to an actual screen coordinate on the axis.\r\n     *\r\n     * `location` identifies relative location within category. 0 - beginning,\r\n     * 0.5 - middle, 1 - end, and anything inbetween.\r\n     *\r\n     * @param index     Index\r\n     * @param location  Location (0-1)\r\n     * @return Position (px)\r\n     */\r\n    CategoryAxis.prototype.indexToPosition = function (index, location) {\r\n        if (!$type.isNumber(location)) {\r\n            location = 0.5;\r\n        }\r\n        var startIndex = this.startIndex;\r\n        var endIndex = this.endIndex;\r\n        var difference = this.adjustDifference(startIndex, endIndex);\r\n        var startLocation = this.startLocation;\r\n        var endLocation = this.endLocation;\r\n        difference -= startLocation;\r\n        difference -= (1 - endLocation);\r\n        if (this._axisBreaks) {\r\n            var axisBreaks = this._axisBreaks;\r\n            $iter.eachContinue(axisBreaks.iterator(), function (axisBreak) {\r\n                var breakStartIndex = axisBreak.adjustedStartValue;\r\n                var breakEndIndex = axisBreak.adjustedEndValue;\r\n                if (index < startIndex || !$type.isNumber(breakStartIndex) || !$type.isNumber(breakEndIndex)) {\r\n                    return false;\r\n                }\r\n                if ($math.intersect({ start: breakStartIndex, end: breakEndIndex }, { start: startIndex, end: endIndex })) {\r\n                    breakStartIndex = Math.max(startIndex, breakStartIndex);\r\n                    breakEndIndex = Math.min(endIndex, breakEndIndex);\r\n                    var breakSize = axisBreak.breakSize;\r\n                    // value to the right of break end\r\n                    if (index > breakEndIndex) {\r\n                        startIndex += (breakEndIndex - breakStartIndex) * (1 - breakSize);\r\n                    }\r\n                    // value to the left of break start\r\n                    else if (index < breakStartIndex) {\r\n                    }\r\n                    // value within break\r\n                    else {\r\n                        index = breakStartIndex + (index - breakStartIndex) * breakSize;\r\n                    }\r\n                }\r\n                return true;\r\n            });\r\n        }\r\n        var deltaPosition = 0;\r\n        var dataItem = this.dataItems.getIndex(index);\r\n        if (dataItem) {\r\n            deltaPosition = dataItem.deltaPosition;\r\n        }\r\n        return $math.round(deltaPosition + (index + location - startLocation - startIndex) / difference, 5);\r\n    };\r\n    /**\r\n     * Converts a string category name to relative position on axis.\r\n     *\r\n     * `location` identifies relative location within category. 0 - beginning,\r\n     * 0.5 - middle, 1 - end, and anything inbetween.\r\n     *\r\n     * @param category  Category name\r\n     * @param location  Location (0-1)\r\n     * @return Position\r\n     */\r\n    CategoryAxis.prototype.categoryToPosition = function (category, location) {\r\n        var index = this.categoryToIndex(category);\r\n        return this.indexToPosition(index, location);\r\n    };\r\n    /**\r\n     * Converts a string category name to a orientation point (x, y, angle) on axis\r\n     *\r\n     * `location` identifies relative location within category. 0 - beginning,\r\n     * 0.5 - middle, 1 - end, and anything inbetween.\r\n     * @param category  Category name\r\n     * @param location  Location (0-1)\r\n     * @return Orientation point\r\n     */\r\n    CategoryAxis.prototype.categoryToPoint = function (category, location) {\r\n        var position = this.categoryToPosition(category, location);\r\n        var point = this.renderer.positionToPoint(position);\r\n        var angle = this.renderer.positionToAngle(position);\r\n        return { x: point.x, y: point.y, angle: angle };\r\n    };\r\n    /**\r\n     * Converts a string category name to a orientation point (x, y, angle) on axis\r\n     *\r\n     * `location` identifies relative location within category. 0 - beginning,\r\n     * 0.5 - middle, 1 - end, and anything inbetween.\r\n     * @param category  Category name\r\n     * @param location  Location (0-1)\r\n     * @return Orientation point\r\n     */\r\n    CategoryAxis.prototype.anyToPoint = function (category, location) {\r\n        return this.categoryToPoint(category, location);\r\n    };\r\n    /**\r\n     * Converts a string category name to relative position on axis.\r\n     *\r\n     * An alias to `categoryToPosition()`.\r\n     *\r\n     * @param category  Category name\r\n     * @param location  Location (0-1)\r\n     * @return Relative position\r\n     */\r\n    CategoryAxis.prototype.anyToPosition = function (category, location) {\r\n        return this.categoryToPosition(category, location);\r\n    };\r\n    /**\r\n     * Converts named category to an index of data item it corresponds to.\r\n     *\r\n     * @param category  Category\r\n     * @return Data item index\r\n     */\r\n    CategoryAxis.prototype.categoryToIndex = function (category) {\r\n        if ($type.hasValue(category)) {\r\n            var dataItem = this.dataItemsByCategory.getKey(category);\r\n            if (dataItem) {\r\n                return dataItem.index;\r\n            }\r\n        }\r\n    };\r\n    /**\r\n     * Zooms the axis to specific named ctaegories.\r\n     *\r\n     * @param startCategory  Start category\r\n     * @param endCategory    End category\r\n     */\r\n    CategoryAxis.prototype.zoomToCategories = function (startCategory, endCategory) {\r\n        this.zoomToIndexes(this.categoryToIndex(startCategory), this.categoryToIndex(endCategory) + 1);\r\n    };\r\n    /**\r\n     * [getAnyRangePath description]\r\n     *\r\n     * @ignore Exclude from docs\r\n     * @todo Description\r\n     * @param start         [description]\r\n     * @param end           [description]\r\n     * @param startLocation [description]\r\n     * @param endLocation   [description]\r\n     * @return [description]\r\n     */\r\n    CategoryAxis.prototype.getAnyRangePath = function (start, end, startLocation, endLocation) {\r\n        var startPos = this.categoryToPosition(start, startLocation);\r\n        var endPos = this.categoryToPosition(end, endLocation);\r\n        return this.getPositionRangePath(startPos, endPos); // Base class (Axis) gets range shape from AxisRenderer\r\n    };\r\n    /**\r\n     * Takes an absolute position (px) within axis and adjust it to a specific\r\n     * `location` within category it corresponds to.\r\n     *\r\n     * @param position  Source position (px)\r\n     * @param location  Location within category (0-1)\r\n     * @return Adjusted position (px)\r\n     */\r\n    CategoryAxis.prototype.roundPosition = function (position, location) {\r\n        var index = this.positionToIndex(position);\r\n        return this.indexToPosition(index, location);\r\n    };\r\n    /**\r\n     * Finds and returns first series data item with specific category\r\n     * @param series    Target series\r\n     * @param category  Category\r\n     * @return XYSeriesDataItem data item\r\n     */\r\n    CategoryAxis.prototype.getFirstSeriesDataItem = function (series, category) {\r\n        for (var i = 0; i < series.dataItems.length; i++) {\r\n            var dataItem = series.dataItems.getIndex(i);\r\n            if (series.xAxis == this) {\r\n                if (dataItem.categoryX == category) {\r\n                    return dataItem;\r\n                }\r\n            }\r\n            if (series.yAxis == this) {\r\n                if (dataItem.categoryY == category) {\r\n                    return dataItem;\r\n                }\r\n            }\r\n        }\r\n    };\r\n    /**\r\n     * Finds and returns last series data item with specific category.\r\n     * @param series    Target series\r\n     * @param category  Category\r\n     * @return XYSeriesDataItem data item\r\n     */\r\n    CategoryAxis.prototype.getLastSeriesDataItem = function (series, category) {\r\n        for (var i = series.dataItems.length - 1; i >= 0; i--) {\r\n            var dataItem = series.dataItems.getIndex(i);\r\n            if (series.xAxis == this) {\r\n                if (dataItem.categoryX == category) {\r\n                    return dataItem;\r\n                }\r\n            }\r\n            if (series.yAxis == this) {\r\n                if (dataItem.categoryY == category) {\r\n                    return dataItem;\r\n                }\r\n            }\r\n        }\r\n    };\r\n    // todo: optimize\r\n    CategoryAxis.prototype.getSeriesDataItemByCategory = function (category, series) {\r\n        var _this = this;\r\n        var seriesDataItem;\r\n        series.dataItems.each(function (dataItem) {\r\n            if (series.xAxis == _this) {\r\n                if (dataItem.categoryX == category) {\r\n                    seriesDataItem = dataItem;\r\n                }\r\n            }\r\n            else if (series.yAxis == _this) {\r\n                if (dataItem.categoryY == category) {\r\n                    seriesDataItem = dataItem;\r\n                }\r\n            }\r\n        });\r\n        return seriesDataItem;\r\n    };\r\n    /**\r\n     * Returns a data item from Series that corresponds to a specific absolute\r\n     * position on the Axis.\r\n     *\r\n     * @param series    Target series\r\n     * @param position  Position (px)\r\n     * @return XYSeriesDataItem data item\r\n     */\r\n    CategoryAxis.prototype.getSeriesDataItem = function (series, position, findNearest) {\r\n        var _this = this;\r\n        if ($type.isNumber(position)) {\r\n            var index_1 = this.positionToIndex(position);\r\n            if (index_1 >= this.dataItems.length) {\r\n                index_1--;\r\n            }\r\n            var dataItem = this.dataItems.getIndex(index_1);\r\n            if (dataItem) {\r\n                var category_1 = dataItem.category;\r\n                var sdi_1;\r\n                var seriesDataItem = series.dataItems.getIndex(index_1);\r\n                if (seriesDataItem) {\r\n                    if (series.xAxis == this) {\r\n                        if (seriesDataItem.categoryX == category_1) {\r\n                            return seriesDataItem;\r\n                        }\r\n                    }\r\n                    if (series.yAxis == this) {\r\n                        if (seriesDataItem.categoryY == category_1) {\r\n                            return seriesDataItem;\r\n                        }\r\n                    }\r\n                }\r\n                series.dataItems.each(function (dataItem) {\r\n                    if (series.xAxis == _this) {\r\n                        if (dataItem.categoryX == category_1) {\r\n                            if (!sdi_1) {\r\n                                sdi_1 = dataItem;\r\n                            }\r\n                            if (Math.abs(index_1 - sdi_1.index) > Math.abs(index_1 - dataItem.index)) {\r\n                                sdi_1 = dataItem;\r\n                            }\r\n                        }\r\n                    }\r\n                    if (series.yAxis == _this) {\r\n                        if (dataItem.categoryY == category_1) {\r\n                            if (!sdi_1) {\r\n                                sdi_1 = dataItem;\r\n                            }\r\n                            if (Math.abs(index_1 - sdi_1.index) > Math.abs(index_1 - dataItem.index)) {\r\n                                sdi_1 = dataItem;\r\n                            }\r\n                        }\r\n                    }\r\n                });\r\n                //@todo\r\n                if (findNearest) {\r\n                }\r\n                return sdi_1;\r\n            }\r\n        }\r\n    };\r\n    /**\r\n     * Returns the X coordinate for series' data item.\r\n     *\r\n     * @ignore Exclude from docs\r\n     * @todo Description (review)\r\n     * @param dataItem  Data item\r\n     * @param key       Category\r\n     * @param location  Location (0-1)\r\n     * @return X coordinate (px)\r\n     */\r\n    CategoryAxis.prototype.getX = function (dataItem, key, location, stackKey, range) {\r\n        var position = this.getPositionX(dataItem, key, location, stackKey, range);\r\n        if ($type.isNaN(position)) {\r\n            return this.basePoint.x;\r\n        }\r\n        else {\r\n            return this.renderer.positionToPoint(position).x;\r\n        }\r\n    };\r\n    /**\r\n     * Returns relative position on axis for series' data item.\r\n     *\r\n     * @since 4.5.14\r\n     * @param  dataItem  Data item\r\n     * @param  key       Category\r\n     * @param  location  Location (0-1)\r\n     * @return           Relative position\r\n     */\r\n    CategoryAxis.prototype.getPositionX = function (dataItem, key, location, stackKey, range) {\r\n        var position;\r\n        if ($type.hasValue(key)) {\r\n            position = this.categoryToPosition(dataItem.categories[key], location);\r\n        }\r\n        if (range) {\r\n            position = $math.fitToRange(position, range.start, range.end);\r\n        }\r\n        return position;\r\n    };\r\n    /**\r\n     * Returns the Y coordinate for series' data item.\r\n     *\r\n     * @ignore Exclude from docs\r\n     * @todo Description (review)\r\n     * @param dataItem  Data item\r\n     * @param key       Category\r\n     * @param location  Location (0-1)\r\n     * @return Y coordinate (px)\r\n     */\r\n    CategoryAxis.prototype.getY = function (dataItem, key, location, stackKey, range) {\r\n        var position = this.getPositionY(dataItem, key, location, stackKey, range);\r\n        if ($type.isNaN(position)) {\r\n            return this.basePoint.y;\r\n        }\r\n        else {\r\n            return this.renderer.positionToPoint(position).y;\r\n        }\r\n    };\r\n    /**\r\n     * Returns relative position on axis for series' data item.\r\n     *\r\n     * @since 4.5.14\r\n     * @param  dataItem  Data item\r\n     * @param  key       Category\r\n     * @param  location  Location (0-1)\r\n     * @return           Relative position\r\n     */\r\n    CategoryAxis.prototype.getPositionY = function (dataItem, key, location, stackKey, range) {\r\n        var position;\r\n        if ($type.hasValue(key)) {\r\n            position = this.categoryToPosition(dataItem.categories[key], location);\r\n        }\r\n        if (range) {\r\n            position = $math.fitToRange(position, range.start, range.end);\r\n        }\r\n        return position;\r\n    };\r\n    /**\r\n     * Returns an angle for series data item.\r\n     *\r\n     * @ignore Exclude from docs\r\n     * @todo Description (review)\r\n     * @param dataItem  Data item\r\n     * @param key       Category\r\n     * @param location  Location (0-1)\r\n     * @param stackKey  Stack key (?)\r\n     * @param range Range to fit in\r\n     * @return Angle\r\n     */\r\n    CategoryAxis.prototype.getAngle = function (dataItem, key, location, stackKey, range) {\r\n        var position = this.categoryToPosition(dataItem.categories[key], location);\r\n        if (range) {\r\n            position = $math.fitToRange(position, range.start, range.end);\r\n        }\r\n        return this.positionToAngle(position);\r\n    };\r\n    /**\r\n     * Returns an absolute pixel coordinate of the start of the cell (category),\r\n     * that specific position value falls into.\r\n     *\r\n     * @ignore Exclude from docs\r\n     * @todo Description (review)\r\n     * @param position  Position (px)\r\n     * @return Cell start position (px)\r\n     */\r\n    CategoryAxis.prototype.getCellStartPosition = function (position) {\r\n        return this.roundPosition(position, 0);\r\n    };\r\n    /**\r\n     * Returns an absolute pixel coordinate of the end of the cell (category),\r\n     * that specific position value falls into.\r\n     *\r\n     * @ignore Exclude from docs\r\n     * @todo Description (review)\r\n     * @param position  Position (px)\r\n     * @return Cell end position (px)\r\n     */\r\n    CategoryAxis.prototype.getCellEndPosition = function (position) {\r\n        return this.roundPosition(position, 1);\r\n    };\r\n    /**\r\n     * Returns text to show in a category tooltip, based on specific position\r\n     * within axis.\r\n     *\r\n     * @ignore Exclude from docs\r\n     * @param position  Position (px)\r\n     * @return Label (category)\r\n     */\r\n    CategoryAxis.prototype.getTooltipText = function (position) {\r\n        var dataItem = this.dataItems.getIndex(this.positionToIndex(position));\r\n        if (dataItem) {\r\n            this.tooltipDataItem = dataItem;\r\n            this.tooltip.dataItem = dataItem;\r\n            if (this.tooltipText) {\r\n                return this.tooltipText;\r\n            }\r\n            if (!this._adapterO) {\r\n                return dataItem.category;\r\n            }\r\n            else {\r\n                return this._adapterO.apply(\"getTooltipText\", dataItem.category);\r\n            }\r\n        }\r\n    };\r\n    /**\r\n     * Returns an index of the category that corresponds to specific pixel\r\n     * position within axis.\r\n     *\r\n     * @param position  Position (px)\r\n     * @return Category index\r\n     */\r\n    CategoryAxis.prototype.positionToIndex = function (position) {\r\n        position = $math.round(position, 10);\r\n        if (position < 0) {\r\n            position = 0;\r\n        }\r\n        if (position > 1) {\r\n            position = 1;\r\n        }\r\n        var startIndex = this.startIndex;\r\n        var endIndex = this.endIndex;\r\n        var difference = endIndex - startIndex - this.startLocation - (1 - this.endLocation);\r\n        position += 1 / difference * this.startLocation;\r\n        var index = null;\r\n        if (this._axisBreaks) {\r\n            var axisBreaks = this._axisBreaks;\r\n            // in case we have some axis breaks\r\n            $iter.eachContinue(axisBreaks.iterator(), function (axisBreak) {\r\n                var breakStartPosition = axisBreak.startPosition;\r\n                var breakEndPosition = axisBreak.endPosition;\r\n                var breakStartIndex = axisBreak.adjustedStartValue;\r\n                var breakEndIndex = axisBreak.adjustedEndValue;\r\n                breakStartIndex = $math.max(breakStartIndex, startIndex);\r\n                breakEndIndex = $math.min(breakEndIndex, endIndex);\r\n                var breakSize = axisBreak.breakSize;\r\n                difference -= (breakEndIndex - breakStartIndex) * (1 - breakSize);\r\n                // position to the right of break end\r\n                if (position > breakEndPosition) {\r\n                    startIndex += (breakEndIndex - breakStartIndex) * (1 - breakSize);\r\n                }\r\n                // position to the left of break start\r\n                else if (position < breakStartPosition) {\r\n                }\r\n                // value within break\r\n                else {\r\n                    var breakPosition = (position - breakStartPosition) / (breakEndPosition - breakStartPosition);\r\n                    index = breakStartIndex + Math.round(breakPosition * (breakEndIndex - breakStartIndex));\r\n                    return false;\r\n                }\r\n                return true;\r\n            });\r\n        }\r\n        if (!$type.isNumber(index)) {\r\n            index = Math.floor(position * difference + startIndex);\r\n        }\r\n        if (index >= this.dataItems.length) {\r\n            index = this.dataItems.length - 1;\r\n        }\r\n        // not good, when panning out of bounds, each time one less item gets selected\r\n        //if (index >= endIndex) {\r\n        //\tindex--;\r\n        //}\r\n        return index;\r\n    };\r\n    /**\r\n     * Returns category based on position.\r\n     *\r\n     * Please note that `position` represents position within axis which may be\r\n     * zoomed and not correspond to Cursor's `position`.\r\n     *\r\n     * To convert Cursor's `position` to Axis' `position` use `toAxisPosition()` method.\r\n     *\r\n     * This is a synonim of `getPositionLabel()` implemented here for consistentcy.\r\n     *\r\n     * @since 4.3.8\r\n     * @see {@link https://www.amcharts.com/docs/v4/tutorials/tracking-cursors-position-via-api/#Tracking_Cursor_s_position} For more information about cursor tracking.\r\n     * @param position  Relative position on axis (0-1)\r\n     * @return Position label\r\n     */\r\n    CategoryAxis.prototype.positionToCategory = function (position) {\r\n        return this.getPositionLabel(position);\r\n    };\r\n    /**\r\n     * Returns category based on position.\r\n     *\r\n     * Please note that `position` represents position within axis which may be\r\n     * zoomed and not correspond to Cursor's `position`.\r\n     *\r\n     * To convert Cursor's `position` to Axis' `position` use `toAxisPosition()` method.\r\n     *\r\n     * @see {@link https://www.amcharts.com/docs/v4/tutorials/tracking-cursors-position-via-api/#Tracking_Cursor_s_position} For more information about cursor tracking.\r\n     * @param position  Relative position on axis (0-1)\r\n     * @return Position label\r\n     */\r\n    CategoryAxis.prototype.getPositionLabel = function (position) {\r\n        var dataItem = this.dataItems.getIndex(this.positionToIndex(position));\r\n        if (dataItem) {\r\n            return dataItem.category;\r\n        }\r\n    };\r\n    Object.defineProperty(CategoryAxis.prototype, \"basePoint\", {\r\n        /**\r\n         * Coordinates of the actual axis start.\r\n         *\r\n         * @ignore Exclude from docs\r\n         * @return Base point\r\n         */\r\n        get: function () {\r\n            // This makes base grid to be drawn at the end of the axis and adds extra\r\n            // grid which we need to nicely close the chart.\r\n            return this.renderer.positionToPoint(1);\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    /**\r\n     * Initializes Axis' renderer.\r\n     *\r\n     * @ignore Exclude from docs\r\n     */\r\n    CategoryAxis.prototype.initRenderer = function () {\r\n        _super.prototype.initRenderer.call(this);\r\n        var renderer = this.renderer;\r\n        renderer.baseGrid.disabled = true;\r\n    };\r\n    Object.defineProperty(CategoryAxis.prototype, \"frequency\", {\r\n        /**\r\n         * Current frequency of labels of the axis.\r\n         *\r\n         * Normally it would be 1, but when labels start to be hidden due\r\n         * to `minGridDistance` this read-only property will increase.\r\n         *\r\n         * @readonly\r\n         * @since 4.2.0\r\n         * @return Label frequency\r\n         */\r\n        get: function () {\r\n            return this._frequency;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(CategoryAxis.prototype, \"sortBySeries\", {\r\n        /**\r\n         * @return Sort categories?\r\n         */\r\n        get: function () {\r\n            return this.getPropertyValue(\"sortBySeries\");\r\n        },\r\n        /**\r\n         * If set to a reference of [[ColumnSeries]] the categories will be sorted\r\n         * by actual values.\r\n         *\r\n         * The categories are ordered in descending order (from highest values to\r\n         * lowest). To reverse the order, use axis renderer's `inversed` setting.\r\n         * E.g.:\r\n         *\r\n         * ```TypeScript\r\n         * categoryAxis.sortBySeries = series;\r\n         * categoryAxis.renderer.inversed = true;\r\n         * ```\r\n         * ```JavaScript\r\n         * categoryAxis.sortBySeries = series;\r\n         * categoryAxis.renderer.inversed = true;\r\n         * ```\r\n         * ```JSON\r\n         * {\r\n         *   // ...\r\n         *   \"xAxes\": [{\r\n         *     // ...\r\n         *     \"sortBySeries\": \"s1\",\r\n         *     \"renderer\": {\r\n         *       // ...\r\n         *       \"inversed\": true\r\n         *     }\r\n         *   }]\r\n         * }\r\n         * ```\r\n         *\r\n         * @since 4.8.7\r\n         * @param  value  Sort categories?\r\n         */\r\n        set: function (value) {\r\n            this.setPropertyValue(\"sortBySeries\", value, true);\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    /**\r\n     * Processes JSON-based config before it is applied to the object.\r\n     *\r\n     * @ignore Exclude from docs\r\n     * @param config  Config\r\n     */\r\n    CategoryAxis.prototype.processConfig = function (config) {\r\n        if (config) {\r\n            if ($type.hasValue(config.sortBySeries) && $type.isString(config.sortBySeries)) {\r\n                if (this.map.hasKey(config.sortBySeries)) {\r\n                    config.sortBySeries = this.map.getKey(config.sortBySeries);\r\n                }\r\n                else {\r\n                    this.addDelayedMap(\"sortBySeries\", config.sortBySeries);\r\n                    delete config.sortBySeries;\r\n                }\r\n            }\r\n        }\r\n        _super.prototype.processConfig.call(this, config);\r\n    };\r\n    return CategoryAxis;\r\n}(Axis));\r\nexport { CategoryAxis };\r\n/**\r\n * Register class, so that it can be instantiated using its name from\r\n * anywhere.\r\n *\r\n * @ignore\r\n */\r\nregistry.registeredClasses[\"CategoryAxis\"] = CategoryAxis;\r\nregistry.registeredClasses[\"CategoryAxisDataItem\"] = CategoryAxisDataItem;\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}