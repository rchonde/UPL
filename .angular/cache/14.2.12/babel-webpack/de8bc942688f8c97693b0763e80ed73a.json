{"ast":null,"code":"/**\r\n * DateAxis module\r\n */\nimport { __assign, __extends } from \"tslib\";\n/**\r\n * ============================================================================\r\n * IMPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\n\nimport { ValueAxis, ValueAxisDataItem } from \"./ValueAxis\";\nimport { List } from \"../../core/utils/List\";\nimport { Dictionary } from \"../../core/utils/Dictionary\";\nimport { DateAxisBreak } from \"./DateAxisBreak\";\nimport { registry } from \"../../core/Registry\";\nimport * as $time from \"../../core/utils/Time\";\nimport * as $type from \"../../core/utils/Type\";\nimport * as $iter from \"../../core/utils/Iterator\";\nimport * as $math from \"../../core/utils/Math\";\nimport * as $array from \"../../core/utils/Array\";\nimport * as $object from \"../../core/utils/Object\";\nimport * as $utils from \"../../core/utils/Utils\";\nimport { OrderedListTemplate } from \"../../core/utils/SortedList\";\n/**\r\n * ============================================================================\r\n * DATA ITEM\r\n * ============================================================================\r\n * @hidden\r\n */\n\n/**\r\n * Defines data item for [[DateAxis]].\r\n *\r\n * @see {@link DataItem}\r\n */\n\nvar DateAxisDataItem =\n/** @class */\nfunction (_super) {\n  __extends(DateAxisDataItem, _super);\n  /**\r\n   * Constructor\r\n   */\n\n\n  function DateAxisDataItem() {\n    var _this = _super.call(this) || this;\n\n    _this.className = \"DateAxisDataItem\";\n\n    _this.applyTheme();\n\n    _this.values.date = {};\n    _this.values.endDate = {};\n    return _this;\n  }\n\n  Object.defineProperty(DateAxisDataItem.prototype, \"date\", {\n    /**\r\n     * @return Date\r\n     */\n    get: function () {\n      return this.dates[\"date\"];\n    },\n\n    /**\r\n     * Date position of the data item.\r\n     *\r\n     * @param date  Date\r\n     */\n    set: function (date) {\n      this.setDate(\"date\", date);\n      this.value = date.getTime();\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(DateAxisDataItem.prototype, \"endDate\", {\n    /**\r\n     * @return End date\r\n     */\n    get: function () {\n      return this.dates[\"endDate\"];\n    },\n\n    /**\r\n     * End date for data item.\r\n     *\r\n     * @param date End date\r\n     */\n    set: function (date) {\n      this.setDate(\"endDate\", date);\n      this.endValue = date.getTime();\n    },\n    enumerable: true,\n    configurable: true\n  });\n  return DateAxisDataItem;\n}(ValueAxisDataItem);\n\nexport { DateAxisDataItem };\n/**\r\n * ============================================================================\r\n * MAIN CLASS\r\n * ============================================================================\r\n * @hidden\r\n */\n\n/**\r\n * Used to create a date/time-based axis for the chart.\r\n *\r\n * ```TypeScript\r\n * // Create the axis\r\n * let xAxis = chart.xAxes.push(new am4charts.DateAxis());\r\n *\r\n * // Set settings\r\n * xAxis.title.text = \"Time\";\r\n * ```\r\n * ```JavaScript\r\n * // Create the axis\r\n * var valueAxis = chart.xAxes.push(new am4charts.DateAxis());\r\n *\r\n * // Set settings\r\n * valueAxis.title.text = \"Time\";\r\n * ```\r\n * ```JSON\r\n * \"xAxes\": [{\r\n *   \"type\": \"DateAxis\",\r\n *   \"title\": {\r\n *     \"text\": \"Time\"\r\n *   }\r\n * }]\r\n * ```\r\n *\r\n * @see {@link IDateAxisEvents} for a list of available Events\r\n * @see {@link IDateAxisAdapters} for a list of available Adapters\r\n * @see {@link https://www.amcharts.com/docs/v4/concepts/axes/date-axis/} got `DateAxis` documention\r\n * @important\r\n */\n\nvar DateAxis =\n/** @class */\nfunction (_super) {\n  __extends(DateAxis, _super);\n  /**\r\n   * Constructor\r\n   */\n\n\n  function DateAxis() {\n    var _this = // Init\n    _super.call(this) || this;\n\n    _this._gapBreaks = false;\n    /**\r\n     * A list of date/time intervals for Date axis.\r\n     *\r\n     * This define various granularities available for the axis. For example\r\n     * if you have an axis spanning an hour, and space for 6 grid lines / labels\r\n     * the axis will choose the granularity of 10 minutes, displaying a label\r\n     * every 10 minutes.\r\n     *\r\n     * Default intervals:\r\n     *\r\n     * ```JSON\r\n     * [\r\n     *  { timeUnit: \"millisecond\", count: 1 },\r\n     *  { timeUnit: \"millisecond\", count: 5 },\r\n     *  { timeUnit: \"millisecond\", count: 10 },\r\n     *  { timeUnit: \"millisecond\", count: 50 },\r\n     *  { timeUnit: \"millisecond\", count: 100 },\r\n     *  { timeUnit: \"millisecond\", count: 500 },\r\n     *  { timeUnit: \"second\", count: 1 },\r\n     *  { timeUnit: \"second\", count: 5 },\r\n     *  { timeUnit: \"second\", count: 10 },\r\n     *  { timeUnit: \"second\", count: 30 },\r\n     *  { timeUnit: \"minute\", count: 1 },\r\n     *  { timeUnit: \"minute\", count: 5 },\r\n     *  { timeUnit: \"minute\", count: 10 },\r\n     *  { timeUnit: \"minute\", count: 30 },\r\n     *  { timeUnit: \"hour\", count: 1 },\r\n     *  { timeUnit: \"hour\", count: 3 },\r\n     *  { timeUnit: \"hour\", count: 6 },\r\n     *  { timeUnit: \"hour\", count: 12 },\r\n     *  { timeUnit: \"day\", count: 1 },\r\n     *  { timeUnit: \"day\", count: 2 },\r\n     *  { timeUnit: \"day\", count: 3 },\r\n     *  { timeUnit: \"day\", count: 4 },\r\n     *  { timeUnit: \"day\", count: 5 },\r\n     *  { timeUnit: \"week\", count: 1 },\r\n     *  { timeUnit: \"month\", count: 1 },\r\n     *  { timeUnit: \"month\", count: 2 },\r\n     *  { timeUnit: \"month\", count: 3 },\r\n     *  { timeUnit: \"month\", count: 6 },\r\n     *  { timeUnit: \"year\", count: 1 },\r\n     *  { timeUnit: \"year\", count: 2 },\r\n     *  { timeUnit: \"year\", count: 5 },\r\n     *  { timeUnit: \"year\", count: 10 },\r\n     *  { timeUnit: \"year\", count: 50 },\r\n     *  { timeUnit: \"year\", count: 100 }\r\n     * ]\r\n     * ```\r\n     */\n\n    _this.gridIntervals = new List();\n    /**\r\n     * If data aggregation is enabled by setting Axis' `groupData = true`, the\r\n     * chart will try to aggregate data items into grouped data items.\r\n     *\r\n     * If there are more data items in selected period than `groupCount`, it will\r\n     * group data items into bigger period.\r\n     *\r\n     * For example seconds might be grouped into 10-second aggregate data items.\r\n     *\r\n     * This setting indicates what group intervals can the chart group to.\r\n     *\r\n     * Default intervals:\r\n     *\r\n     * ```JSON\r\n     * [\r\n     *   { timeUnit: \"millisecond\", count: 1},\r\n     *   { timeUnit: \"millisecond\", count: 10 },\r\n     *   { timeUnit: \"millisecond\", count: 100 },\r\n     *   { timeUnit: \"second\", count: 1 },\r\n     *   { timeUnit: \"second\", count: 10 },\r\n     *   { timeUnit: \"minute\", count: 1 },\r\n     *   { timeUnit: \"minute\", count: 10 },\r\n     *   { timeUnit: \"hour\", count: 1 },\r\n     *   { timeUnit: \"day\", count: 1 },\r\n     *   { timeUnit: \"week\", count: 1 },\r\n     *   { timeUnit: \"month\", count: 1 },\r\n     *   { timeUnit: \"year\", count: 1 }\r\n     * ]\r\n     * ```\r\n     * `groupData = true` does not work in combination with `skipEmptyPeriods = true`.\r\n     *\r\n     * @since 4.7.0\r\n     * @see {@link https://www.amcharts.com/docs/v4/concepts/axes/date-axis/#Dynamic_data_item_grouping} for more information about dynamic data item grouping.\r\n     */\n\n    _this.groupIntervals = new List();\n    /**\r\n     * A collection of date formats to use when formatting different time units\r\n     * on Date/time axis.\r\n     *\r\n     * Actual defaults will depend on the language locale set for the chart.\r\n     *\r\n     * To override format for a specific time unit, say days, you need to set\r\n     * the appropriate key to a format string. E.g.:\r\n     *\r\n     * ```TypeScript\r\n     * axis.dateFormats.setKey(\"day\", \"MMMM d, yyyy\");\r\n     * ```\r\n     * ```JavaScript\r\n     * axis.dateFormats.setKey(\"day\", \"MMMM d, yyyy\");\r\n     * ```\r\n     * ```JSON\r\n     * \"xAxes\": [{\r\n     *   \"type\": \"DateAxis\",\r\n     *   \"dateFormats\": {\r\n     *     \"day\": \"MMMM d, yyyy\"\r\n     *   }\r\n     * }]\r\n     * ```\r\n     *\r\n     * @see {@link DateFormatter}\r\n     */\n\n    _this.dateFormats = new Dictionary();\n    /**\r\n     * These formats are applied to labels that are first in a larger unit.\r\n     *\r\n     * For example, if we have a DateAxis with days on it, the first day of month\r\n     * indicates a break in month - a start of the bigger period.\r\n     *\r\n     * For those labels, `periodChangeDateFormats` are applied instead of\r\n     * `dateFormats`.\r\n     *\r\n     * This allows us implement convenient structures, like instead of:\r\n     *\r\n     * `Jan 1 - Jan 2 - Jan 3 - ...`\r\n     *\r\n     * We can have:\r\n     *\r\n     * `Jan - 1 - 2 - 3 - ...`\r\n     *\r\n     * This can be disabled by setting `markUnitChange = false`.\r\n     */\n\n    _this.periodChangeDateFormats = new Dictionary();\n    /**\r\n     * Actual interval (granularity) derived from the actual data.\r\n     */\n\n    _this._baseIntervalReal = {\n      timeUnit: \"day\",\n      count: 1\n    };\n    /**\r\n     */\n\n    _this._prevSeriesTime = {};\n    /**\r\n     * [_minDifference description]\r\n     *\r\n     * @todo Description\r\n     */\n\n    _this._minDifference = {};\n    /**\r\n     * @ignore\r\n     */\n\n    _this._firstWeekDay = 1;\n    /**\r\n     * A collection of start timestamps to use as axis' min timestamp for\r\n     * particular data item item periods.\r\n     *\r\n     * @since 4.7.0\r\n     * @readonly\r\n     */\n\n    _this.groupMin = {};\n    /**\r\n     * A collection of start timestamps to use as axis' max timestamp for\r\n     * particular data item item periods.\r\n     *\r\n     * @since 4.7.0\r\n     * @readonly\r\n     */\n\n    _this.groupMax = {};\n    _this._intervalMax = {};\n    _this._intervalMin = {};\n    _this.className = \"DateAxis\";\n\n    _this.setPropertyValue(\"markUnitChange\", true);\n\n    _this.snapTooltip = true;\n    _this.tooltipPosition = \"pointer\";\n\n    _this.setPropertyValue(\"groupData\", false);\n\n    _this.groupCount = 200;\n\n    _this.events.on(\"parentset\", _this.getDFFormatter, _this, false); // Translatable defaults are applied in `applyInternalDefaults()`\n    // ...\n    // Define default intervals\n\n\n    _this.gridIntervals.pushAll([{\n      timeUnit: \"millisecond\",\n      count: 1\n    }, {\n      timeUnit: \"millisecond\",\n      count: 5\n    }, {\n      timeUnit: \"millisecond\",\n      count: 10\n    }, {\n      timeUnit: \"millisecond\",\n      count: 50\n    }, {\n      timeUnit: \"millisecond\",\n      count: 100\n    }, {\n      timeUnit: \"millisecond\",\n      count: 500\n    }, {\n      timeUnit: \"second\",\n      count: 1\n    }, {\n      timeUnit: \"second\",\n      count: 5\n    }, {\n      timeUnit: \"second\",\n      count: 10\n    }, {\n      timeUnit: \"second\",\n      count: 30\n    }, {\n      timeUnit: \"minute\",\n      count: 1\n    }, {\n      timeUnit: \"minute\",\n      count: 5\n    }, {\n      timeUnit: \"minute\",\n      count: 10\n    }, {\n      timeUnit: \"minute\",\n      count: 15\n    }, {\n      timeUnit: \"minute\",\n      count: 30\n    }, {\n      timeUnit: \"hour\",\n      count: 1\n    }, {\n      timeUnit: \"hour\",\n      count: 3\n    }, {\n      timeUnit: \"hour\",\n      count: 6\n    }, {\n      timeUnit: \"hour\",\n      count: 12\n    }, {\n      timeUnit: \"day\",\n      count: 1\n    }, {\n      timeUnit: \"day\",\n      count: 2\n    }, {\n      timeUnit: \"day\",\n      count: 3\n    }, {\n      timeUnit: \"day\",\n      count: 4\n    }, {\n      timeUnit: \"day\",\n      count: 5\n    }, {\n      timeUnit: \"week\",\n      count: 1\n    }, {\n      timeUnit: \"month\",\n      count: 1\n    }, {\n      timeUnit: \"month\",\n      count: 2\n    }, {\n      timeUnit: \"month\",\n      count: 3\n    }, {\n      timeUnit: \"month\",\n      count: 6\n    }, {\n      timeUnit: \"year\",\n      count: 1\n    }, {\n      timeUnit: \"year\",\n      count: 2\n    }, {\n      timeUnit: \"year\",\n      count: 5\n    }, {\n      timeUnit: \"year\",\n      count: 10\n    }, {\n      timeUnit: \"year\",\n      count: 50\n    }, {\n      timeUnit: \"year\",\n      count: 100\n    }, {\n      timeUnit: \"year\",\n      count: 200\n    }, {\n      timeUnit: \"year\",\n      count: 500\n    }, {\n      timeUnit: \"year\",\n      count: 1000\n    }, {\n      timeUnit: \"year\",\n      count: 2000\n    }, {\n      timeUnit: \"year\",\n      count: 5000\n    }, {\n      timeUnit: \"year\",\n      count: 10000\n    }, {\n      timeUnit: \"year\",\n      count: 100000\n    }]);\n\n    _this.groupIntervals.pushAll([{\n      timeUnit: \"millisecond\",\n      count: 1\n    }, {\n      timeUnit: \"millisecond\",\n      count: 10\n    }, {\n      timeUnit: \"millisecond\",\n      count: 100\n    }, {\n      timeUnit: \"second\",\n      count: 1\n    }, {\n      timeUnit: \"second\",\n      count: 10\n    }, {\n      timeUnit: \"minute\",\n      count: 1\n    }, {\n      timeUnit: \"minute\",\n      count: 10\n    }, {\n      timeUnit: \"hour\",\n      count: 1\n    }, {\n      timeUnit: \"day\",\n      count: 1\n    }, {\n      timeUnit: \"week\",\n      count: 1\n    }, {\n      timeUnit: \"month\",\n      count: 1\n    }, {\n      timeUnit: \"year\",\n      count: 1\n    }]); // Set field name\n\n\n    _this.axisFieldName = \"date\"; // Apply theme\n\n    _this.applyTheme();\n\n    return _this;\n  }\n  /**\r\n   * A function which applies fills to axis cells.\r\n   *\r\n   * Default function fills every second fill. You can set this to a function\r\n   * that follows some other logic.\r\n   *\r\n   * Function should accept a [[DateAxisDataItem]] and modify its `axisFill`\r\n   * property accordingly.\r\n   */\n\n\n  DateAxis.prototype.fillRule = function (dataItem) {\n    var value = dataItem.value;\n    var axis = dataItem.component;\n    var gridInterval = axis._gridInterval;\n    var gridDuration = $time.getDuration(gridInterval.timeUnit, gridInterval.count);\n\n    if (Math.round((value - axis.min) / gridDuration) / 2 == Math.round(Math.round((value - axis.min) / gridDuration) / 2)) {\n      dataItem.axisFill.__disabled = true;\n    } else {\n      dataItem.axisFill.__disabled = false;\n    }\n  };\n  /**\r\n   * Sets defaults that instantiate some objects that rely on parent, so they\r\n   * cannot be set in constructor.\r\n   */\n\n\n  DateAxis.prototype.applyInternalDefaults = function () {\n    _super.prototype.applyInternalDefaults.call(this); // Set default date formats\n\n\n    if (!this.dateFormats.hasKey(\"millisecond\")) {\n      this.dateFormats.setKey(\"millisecond\", this.language.translate(\"_date_millisecond\"));\n    }\n\n    if (!this.dateFormats.hasKey(\"second\")) {\n      this.dateFormats.setKey(\"second\", this.language.translate(\"_date_second\"));\n    }\n\n    if (!this.dateFormats.hasKey(\"minute\")) {\n      this.dateFormats.setKey(\"minute\", this.language.translate(\"_date_minute\"));\n    }\n\n    if (!this.dateFormats.hasKey(\"hour\")) {\n      this.dateFormats.setKey(\"hour\", this.language.translate(\"_date_hour\"));\n    }\n\n    if (!this.dateFormats.hasKey(\"day\")) {\n      this.dateFormats.setKey(\"day\", this.language.translate(\"_date_day\"));\n    }\n\n    if (!this.dateFormats.hasKey(\"week\")) {\n      this.dateFormats.setKey(\"week\", this.language.translate(\"_date_day\")); // not a mistake\n    }\n\n    if (!this.dateFormats.hasKey(\"month\")) {\n      this.dateFormats.setKey(\"month\", this.language.translate(\"_date_month\"));\n    }\n\n    if (!this.dateFormats.hasKey(\"year\")) {\n      this.dateFormats.setKey(\"year\", this.language.translate(\"_date_year\"));\n    }\n\n    if (!this.periodChangeDateFormats.hasKey(\"millisecond\")) {\n      this.periodChangeDateFormats.setKey(\"millisecond\", this.language.translate(\"_date_millisecond\"));\n    }\n\n    if (!this.periodChangeDateFormats.hasKey(\"second\")) {\n      this.periodChangeDateFormats.setKey(\"second\", this.language.translate(\"_date_second\"));\n    }\n\n    if (!this.periodChangeDateFormats.hasKey(\"minute\")) {\n      this.periodChangeDateFormats.setKey(\"minute\", this.language.translate(\"_date_minute\"));\n    }\n\n    if (!this.periodChangeDateFormats.hasKey(\"hour\")) {\n      this.periodChangeDateFormats.setKey(\"hour\", this.language.translate(\"_date_day\"));\n    }\n\n    if (!this.periodChangeDateFormats.hasKey(\"day\")) {\n      this.periodChangeDateFormats.setKey(\"day\", this.language.translate(\"_date_day\"));\n    }\n\n    if (!this.periodChangeDateFormats.hasKey(\"week\")) {\n      this.periodChangeDateFormats.setKey(\"week\", this.language.translate(\"_date_day\"));\n    }\n\n    if (!this.periodChangeDateFormats.hasKey(\"month\")) {\n      this.periodChangeDateFormats.setKey(\"month\", this.language.translate(\"_date_month\") + \" \" + this.language.translate(\"_date_year\"));\n    }\n  };\n  /**\r\n   * Returns a new/empty [[DataItem]] of the type appropriate for this object.\r\n   *\r\n   * @see {@link DataItem}\r\n   * @return Data Item\r\n   */\n\n\n  DateAxis.prototype.createDataItem = function () {\n    return new DateAxisDataItem();\n  };\n  /**\r\n   * Returns a new/empty [[AxisBreak]] of the appropriate type.\r\n   *\r\n   * @return Axis break\r\n   */\n\n\n  DateAxis.prototype.createAxisBreak = function () {\n    return new DateAxisBreak();\n  };\n  /**\r\n   * Validates Axis' data items.\r\n   *\r\n   * @ignore Exclude from docs\r\n   */\n\n\n  DateAxis.prototype.validateDataItems = function () {\n    // allows to keep selection of the same size\n    var start = this.start;\n    var end = this.end;\n    var baseDuration = this.baseDuration;\n    var periodCount = (this.max - this.min) / baseDuration;\n    this._firstWeekDay = this.getFirstWeekDay();\n    this.getDFFormatter();\n\n    _super.prototype.validateDataItems.call(this);\n\n    var mainBaseDuration = $time.getDuration(this.mainBaseInterval.timeUnit, this.mainBaseInterval.count);\n    this.maxZoomFactor = Math.max(1, (this.max - this.min) / mainBaseDuration);\n    this._deltaMinMax = this.baseDuration / 2; // allows to keep selection of the same size\n\n    var newPeriodCount = (this.max - this.min) / baseDuration;\n    start = start + (end - start) * (1 - periodCount / newPeriodCount);\n    this.zoom({\n      start: start,\n      end: end\n    }, false, true); // added instantlyto solve zoomout problem when we have axes gaps. @todo: check how this affects maxZoomFactor\n  };\n  /**\r\n   * Handles process after zoom.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @todo Does nothing?\r\n   */\n\n\n  DateAxis.prototype.handleSelectionExtremesChange = function () {};\n  /**\r\n   * @ignore\r\n   */\n\n\n  DateAxis.prototype.getIntervalMax = function (interval) {\n    return this._intervalMax[interval.timeUnit + interval.count];\n  };\n  /**\r\n   * @ignore\r\n   */\n\n\n  DateAxis.prototype.getIntervalMin = function (interval) {\n    return this._intervalMin[interval.timeUnit + interval.count];\n  };\n  /**\r\n   * Calculates all positions, related to axis as per current zoom.\r\n   *\r\n   * @ignore Exclude from docs\r\n   */\n\n\n  DateAxis.prototype.calculateZoom = function () {\n    var _this = this;\n\n    _super.prototype.calculateZoom.call(this);\n\n    var difference = this.adjustDifference(this._minZoomed, this._maxZoomed);\n    var dataSetChanged = false; // if data has to be grouped, choose interval and set dataset\n\n    if (this.groupData && $type.hasValue(difference)) {\n      var mainBaseInterval = this.mainBaseInterval;\n      var min = this.getIntervalMin(mainBaseInterval);\n      var max = this.getIntervalMax(mainBaseInterval);\n      var selectionMin = min + (max - min) * this.start;\n      var selectionMax = min + (max - min) * this.end;\n      var diff = this.adjustDifference(selectionMin, selectionMax);\n      var modifiedDifference = diff + (this.startLocation + (1 - this.endLocation)) * this.baseDuration;\n      var groupInterval = void 0;\n\n      if (this.groupInterval) {\n        groupInterval = __assign({}, this.groupInterval);\n      } else {\n        groupInterval = this.chooseInterval(0, modifiedDifference, this.groupCount, this.groupIntervals);\n\n        if ($time.getDuration(groupInterval.timeUnit, groupInterval.count) < $time.getDuration(mainBaseInterval.timeUnit, mainBaseInterval.count)) {\n          groupInterval = __assign({}, mainBaseInterval);\n        }\n      }\n\n      this._groupInterval = groupInterval;\n      var newId = groupInterval.timeUnit + groupInterval.count;\n\n      if (this._currentDataSetId != newId) {\n        this._currentDataSetId = newId;\n        this.dispatch(\"groupperiodchanged\");\n      }\n\n      this.series.each(function (series) {\n        if (series.baseAxis == _this) {\n          if (series.setDataSet(_this._currentDataSetId)) {\n            dataSetChanged = true;\n          }\n        }\n      });\n    }\n\n    var gridInterval = this.chooseInterval(0, difference, this._gridCount);\n\n    if ($time.getDuration(gridInterval.timeUnit, gridInterval.count) < this.baseDuration) {\n      gridInterval = __assign({}, this.baseInterval);\n    }\n\n    this._gridInterval = gridInterval;\n    this._nextGridUnit = $time.getNextUnit(gridInterval.timeUnit); // the following is needed to avoid grid flickering while scrolling\n\n    this._intervalDuration = $time.getDuration(gridInterval.timeUnit, gridInterval.count);\n    this._gridDate = $time.round(new Date(this.minZoomed - $time.getDuration(gridInterval.timeUnit, gridInterval.count)), gridInterval.timeUnit, gridInterval.count, this._firstWeekDay, this._df.utc, new Date(this.min), this._df.timezoneMinutes, this._df.timezone); // tell series start/end\n\n    $iter.each(this.series.iterator(), function (series) {\n      if (series.baseAxis == _this) {\n        var field_1 = series.getAxisField(_this);\n        var minZoomed = $time.round(new Date(_this._minZoomed + _this.baseDuration * 0.05), _this.baseInterval.timeUnit, _this.baseInterval.count, _this._firstWeekDay, _this._df.utc, undefined, _this._df.timezoneMinutes, _this._df.timezone).getTime();\n        var minZoomedStr = minZoomed.toString();\n        var startDataItem = series.dataItemsByAxis.getKey(_this.uid).getKey(minZoomedStr + series.currentDataSetId);\n        var startIndex = 0;\n\n        if (_this.start != 0) {\n          if (startDataItem) {\n            startDataItem = _this.findFirst(startDataItem, minZoomed, field_1);\n            startIndex = startDataItem.index;\n          } else {\n            startIndex = series.dataItems.findClosestIndex(_this._minZoomed, function (x) {\n              return x[field_1];\n            }, \"left\");\n          }\n        } // 1 millisecond is removed so that if only first item is selected, it would not count in the second.\n\n\n        var baseInterval = _this.baseInterval;\n        var maxZoomed = $time.add($time.round(new Date(_this._maxZoomed), baseInterval.timeUnit, baseInterval.count, _this._firstWeekDay, _this._df.utc, undefined, _this._df.timezoneMinutes, _this._df.timezone), baseInterval.timeUnit, baseInterval.count, _this._df.utc).getTime();\n        var maxZoomedStr = maxZoomed.toString();\n        var endDataItem = series.dataItemsByAxis.getKey(_this.uid).getKey(maxZoomedStr + series.currentDataSetId);\n        var endIndex = series.dataItems.length;\n\n        if (_this.end != 1) {\n          if (endDataItem) {\n            endIndex = endDataItem.index;\n          } else {\n            maxZoomed -= 1;\n            endIndex = series.dataItems.findClosestIndex(maxZoomed, function (x) {\n              return x[field_1];\n            }, \"right\"); // not good - if end is in the gap, indexes go like 5,4,3,4,2,1\n            //if (endIndex < series.dataItems.length) {\n\n            endIndex++; //}\n          }\n        }\n\n        if (series.max(_this) < minZoomed) {\n          series.startIndex = series.dataItems.length;\n          series.endIndex = series.dataItems.length;\n          series.outOfRange = true;\n        } else if (series.min(_this) > maxZoomed) {\n          series.startIndex = 0;\n          series.endIndex = 0;\n          series.outOfRange = true;\n        } else {\n          series.outOfRange = false;\n          series.startIndex = startIndex;\n          series.endIndex = endIndex;\n        } //\tconsole.log(series.name, startIndex, endIndex);\n\n\n        if (!dataSetChanged && series.dataRangeInvalid) {\n          series.validateDataRange();\n        }\n      }\n    });\n  };\n\n  DateAxis.prototype.findFirst = function (dataItem, time, key) {\n    var index = dataItem.index;\n\n    if (index > 0) {\n      var series = dataItem.component;\n      var previousDataItem = series.dataItems.getIndex(index - 1);\n      var previousDate = previousDataItem[key];\n\n      if (!previousDate || previousDate.getTime() < time) {\n        return dataItem;\n      } else {\n        return this.findFirst(previousDataItem, time, key);\n      }\n    } else {\n      return dataItem;\n    }\n  };\n  /**\r\n   * (Re)validates data.\r\n   *\r\n   * @ignore Exclude from docs\r\n   */\n\n\n  DateAxis.prototype.validateData = function () {\n    _super.prototype.validateData.call(this);\n\n    if (!$type.isNumber(this.baseInterval.count)) {\n      this.baseInterval.count = 1;\n    }\n  };\n\n  Object.defineProperty(DateAxis.prototype, \"minDifference\", {\n    /**\r\n     * @ignore\r\n     */\n    get: function () {\n      var _this = this;\n\n      var minDifference = Number.MAX_VALUE;\n      this.series.each(function (series) {\n        if (minDifference > _this._minDifference[series.uid]) {\n          minDifference = _this._minDifference[series.uid];\n        }\n      });\n\n      if (minDifference == Number.MAX_VALUE || minDifference == 0) {\n        minDifference = $time.getDuration(\"day\");\n      }\n\n      return minDifference;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\r\n   * [dataChangeUpdate description]\r\n   *\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @todo Description\r\n   */\n\n  DateAxis.prototype.seriesDataChangeUpdate = function (series) {\n    this._minDifference[series.uid] = Number.MAX_VALUE;\n  };\n  /**\r\n   * [postProcessSeriesDataItems description]\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @todo Description\r\n   */\n\n\n  DateAxis.prototype.postProcessSeriesDataItems = function (series) {\n    var _this = this;\n\n    this._firstWeekDay = this.getFirstWeekDay();\n\n    if (series) {\n      this.seriesGroupUpdate(series);\n    } else {\n      this.series.each(function (series) {\n        _this.seriesGroupUpdate(series);\n      });\n    }\n\n    this.addEmptyUnitsBreaks();\n  };\n\n  DateAxis.prototype.seriesGroupUpdate = function (series) {\n    var _this = this;\n\n    if (JSON.stringify(series._baseInterval[this.uid]) != JSON.stringify(this.mainBaseInterval)) {\n      series._baseInterval[this.uid] = this.mainBaseInterval;\n      series.mainDataSet.each(function (dataItem) {\n        _this.postProcessSeriesDataItem(dataItem);\n      });\n\n      if (this.groupData) {\n        this.groupSeriesData(series);\n      }\n    }\n  };\n  /**\r\n   * Calculates series group data.\r\n   *\r\n   * @param  series  Series\r\n   * @ignore\r\n   */\n\n\n  DateAxis.prototype.groupSeriesData = function (series) {\n    var _this = this;\n\n    if (series.baseAxis == this && series.dataItems.length > 0 && !series.dataGrouped) {\n      series.bulletsContainer.removeChildren(); // make array of intervals which will be used;\n\n      var intervals_1 = [];\n      var mainBaseInterval = this.mainBaseInterval;\n      var mainIntervalDuration_1 = $time.getDuration(mainBaseInterval.timeUnit, mainBaseInterval.count);\n      this.groupIntervals.each(function (interval) {\n        var intervalDuration = $time.getDuration(interval.timeUnit, interval.count);\n\n        if (intervalDuration > mainIntervalDuration_1 && intervalDuration < _this.max - _this.min || _this.groupInterval) {\n          intervals_1.push(interval);\n        }\n      });\n\n      if (series._dataSets) {\n        series._dataSets.each(function (key, dataItems) {\n          dataItems.each(function (dataItem) {\n            dataItem.dispose();\n          });\n          dataItems.clear();\n        });\n\n        series._dataSets.clear();\n      }\n\n      series.dataGrouped = true;\n      $array.each(intervals_1, function (interval) {\n        //let mainBaseInterval = this._mainBaseInterval;\n        var key = \"date\" + _this.axisLetter; // create data set\n\n        var dataSetId = interval.timeUnit + interval.count; // todo: check where this clone goes\n\n        var dataSet = new OrderedListTemplate(series.mainDataSet.template.clone());\n        series.dataSets.setKey(dataSetId, dataSet);\n        var dataItems = series.mainDataSet;\n        var previousTime = Number.NEGATIVE_INFINITY;\n        var i = 0;\n        var newDataItem;\n        var dataFields = [];\n        $object.each(series.dataFields, function (dfkey, df) {\n          var dfk = dfkey;\n\n          if (dfk != key && dfk.indexOf(\"Show\") == -1) {\n            dataFields.push(dfk);\n          }\n        });\n        var roundedDate;\n        dataItems.each(function (dataItem) {\n          var date = dataItem.getDate(key);\n\n          if (date) {\n            var time = date.getTime();\n            roundedDate = $time.round(new Date(time), interval.timeUnit, interval.count, _this._df.firstDayOfWeek, _this._df.utc, undefined, _this._df.timezoneMinutes, _this._df.timezone);\n            var currentTime = roundedDate.getTime(); // changed period\t\t\t\t\t\t\t\t\n\n            if (previousTime < currentTime) {\n              if (newDataItem && series._adapterO) {\n                $array.each(dataFields, function (vkey) {\n                  newDataItem.values[vkey].value = series._adapterO.apply(\"groupDataItem\", {\n                    dataItem: newDataItem,\n                    interval: interval,\n                    dataField: vkey,\n                    date: roundedDate,\n                    value: newDataItem.values[vkey].value\n                  }).value;\n                  newDataItem.values[vkey].workingValue = newDataItem.values[vkey].value;\n                });\n              }\n\n              newDataItem = dataSet.create();\n              newDataItem.dataContext = {};\n              newDataItem.setWorkingLocation(\"dateX\", series.dataItems.template.locations.dateX, 0);\n              newDataItem.setWorkingLocation(\"openDateX\", series.dataItems.template.locations.openDateX, 0);\n              newDataItem.setWorkingLocation(\"dateY\", series.dataItems.template.locations.dateY, 0);\n              newDataItem.setWorkingLocation(\"openDateY\", series.dataItems.template.locations.openDateY, 0);\n              newDataItem.component = series; // other Dates?\n\n              newDataItem.setDate(key, roundedDate);\n              newDataItem._index = i;\n              i++;\n              $array.each(dataFields, function (vkey) {\n                //let groupFieldName = vkey + \"Group\";\n                var dvalues = dataItem.values[vkey];\n\n                if (dvalues) {\n                  var value = dvalues.value;\n\n                  if (series._adapterO) {\n                    value = series._adapterO.apply(\"groupValue\", {\n                      dataItem: dataItem,\n                      interval: interval,\n                      dataField: vkey,\n                      date: roundedDate,\n                      value: value\n                    }).value;\n                  }\n\n                  var values = newDataItem.values[vkey];\n\n                  if ($type.isNumber(value)) {\n                    values.value = value;\n                    values.workingValue = value;\n                    values.open = value;\n                    values.close = value;\n                    values.low = value;\n                    values.high = value;\n                    values.sum = value;\n                    values.average = value;\n                    values.count = 1;\n                  } else {\n                    values.count = 0;\n                  }\n                }\n              });\n\n              _this.postProcessSeriesDataItem(newDataItem, interval);\n\n              $object.each(series.propertyFields, function (key, fieldValue) {\n                var f = key;\n                var value = dataItem.properties[key];\n\n                if ($type.hasValue(value)) {\n                  newDataItem.hasProperties = true;\n                  newDataItem.setProperty(f, value);\n                }\n              });\n              newDataItem.groupDataItems = [dataItem];\n              previousTime = currentTime;\n            } else {\n              if (newDataItem) {\n                $array.each(dataFields, function (vkey) {\n                  var groupFieldName = series.groupFields[vkey];\n                  var dvalues = dataItem.values[vkey];\n\n                  if (dvalues) {\n                    var value = dvalues.value;\n\n                    if (series._adapterO) {\n                      value = series._adapterO.apply(\"groupValue\", {\n                        dataItem: dataItem,\n                        interval: interval,\n                        dataField: vkey,\n                        date: roundedDate,\n                        value: value\n                      }).value;\n                    }\n\n                    if ($type.isNumber(value)) {\n                      var values = newDataItem.values[vkey];\n\n                      if (!$type.isNumber(values.open)) {\n                        values.open = value;\n                      }\n\n                      values.close = value;\n\n                      if (values.low > value || !$type.isNumber(values.low)) {\n                        values.low = value;\n                      }\n\n                      if (values.high < value || !$type.isNumber(values.high)) {\n                        values.high = value;\n                      }\n\n                      if ($type.isNumber(values.sum)) {\n                        values.sum += value;\n                      } else {\n                        values.sum = value;\n                      }\n\n                      values.count++;\n                      values.average = values.sum / values.count;\n\n                      if ($type.isNumber(values[groupFieldName])) {\n                        values.value = values[groupFieldName];\n                        values.workingValue = values.value;\n                      }\n                    }\n                  }\n                });\n                $utils.copyProperties(dataItem.properties, newDataItem.properties);\n                $object.each(series.propertyFields, function (key, fieldValue) {\n                  var f = key;\n                  var value = dataItem.properties[key];\n\n                  if ($type.hasValue(value)) {\n                    newDataItem.hasProperties = true;\n                    newDataItem.setProperty(f, value);\n                  }\n                });\n                newDataItem.groupDataItems.push(dataItem);\n              }\n            }\n          }\n\n          if (newDataItem) {\n            $utils.copyProperties(dataItem.dataContext, newDataItem.dataContext);\n          }\n        });\n\n        if (newDataItem && series._adapterO) {\n          $array.each(dataFields, function (vkey) {\n            newDataItem.values[vkey].value = series._adapterO.apply(\"groupDataItem\", {\n              dataItem: newDataItem,\n              interval: interval,\n              dataField: vkey,\n              date: roundedDate,\n              value: newDataItem.values[vkey].value\n            }).value;\n            newDataItem.values[vkey].workingValue = newDataItem.values[vkey].value;\n          });\n        }\n      });\n      this.calculateZoom();\n    }\n  };\n  /**\r\n   * @ignore\r\n   */\n\n\n  DateAxis.prototype.getDFFormatter = function () {\n    this._df = this.dateFormatter;\n  };\n  /**\r\n   * [postProcessSeriesDataItem description]\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @todo Description\r\n   * @param dataItem Data item\r\n   */\n\n\n  DateAxis.prototype.postProcessSeriesDataItem = function (dataItem, interval) {\n    var _this = this; // we need to do this for all series data items not only added recently, as baseInterval might change\n\n\n    var intervalID = \"\";\n\n    if (interval) {\n      intervalID = interval.timeUnit + interval.count;\n    } else {\n      interval = this.mainBaseInterval;\n    }\n\n    var series = dataItem.component;\n    var dataItemsByAxis = series.dataItemsByAxis.getKey(this.uid);\n    $object.each(dataItem.dates, function (key) {\n      var date = dataItem.getDate(key);\n      var time = date.getTime();\n      var startDate = $time.round(new Date(time), interval.timeUnit, interval.count, _this._firstWeekDay, _this._df.utc, undefined, _this._df.timezoneMinutes, _this._df.timezone);\n      var startTime = startDate.getTime();\n      var endDate = $time.add(new Date(startTime), interval.timeUnit, interval.count, _this._df.utc);\n      dataItem.setCalculatedValue(key, startTime, \"open\");\n      dataItem.setCalculatedValue(key, endDate.getTime(), \"close\");\n      dataItemsByAxis.setKey(startTime + intervalID, dataItem);\n    });\n  };\n  /**\r\n   * Collapses empty stretches of date/time scale by creating [[AxisBreak]]\r\n   * elements for them.\r\n   *\r\n   * Can be used to automatically remove strethes without data, like weekends.\r\n   *\r\n   * No, need to call this manually. It will automatically be done if\r\n   * `skipEmptyPeriods = true`.\r\n   *\r\n   * @ignore Exclude from docs\r\n   */\n\n\n  DateAxis.prototype.addEmptyUnitsBreaks = function () {\n    var _this = this;\n\n    if (this.skipEmptyPeriods && $type.isNumber(this.min) && $type.isNumber(this.max)) {\n      var timeUnit = this.baseInterval.timeUnit;\n      var count = this.baseInterval.count;\n\n      if (this._axisBreaks) {\n        this._axisBreaks.clear(); // TODO: what about breaks added by user?\n\n      }\n\n      var date = $time.round(new Date(this.min), timeUnit, count, this._firstWeekDay, this._df.utc, undefined, this._df.timezoneMinutes, this._df.timezone);\n      var axisBreak = void 0;\n\n      var _loop_1 = function () {\n        $time.add(date, timeUnit, count, this_1._df.utc);\n        var startTime = date.getTime();\n        var startTimeStr = startTime.toString();\n        var hasData = $iter.contains(this_1.series.iterator(), function (series) {\n          return !!series.dataItemsByAxis.getKey(_this.uid).getKey(startTimeStr + series.currentDataSetId);\n        }); // open break if not yet opened\n\n        if (!hasData) {\n          if (!axisBreak) {\n            axisBreak = this_1.axisBreaks.create();\n            axisBreak.startDate = new Date(startTime);\n            this_1._gapBreaks = true;\n          }\n        } else {\n          // close if already opened\n          if (axisBreak) {\n            // close at end time minus one millisecond\n            axisBreak.endDate = new Date(startTime - 1);\n            axisBreak = undefined;\n          }\n        }\n      };\n\n      var this_1 = this;\n\n      while (date.getTime() < this.max - this.baseDuration) {\n        _loop_1();\n      }\n    }\n  };\n  /**\r\n   * Updates positioning of Axis breaks after something changes.\r\n   *\r\n   * @ignore Exclude from docs\r\n   */\n\n\n  DateAxis.prototype.fixAxisBreaks = function () {\n    var _this = this;\n\n    _super.prototype.fixAxisBreaks.call(this);\n\n    var axisBreaks = this._axisBreaks;\n\n    if (axisBreaks) {\n      if (axisBreaks.length > 0) {\n        // process breaks\n        axisBreaks.each(function (axisBreak) {\n          var breakGridCount = Math.ceil(_this._gridCount * (Math.min(_this.end, axisBreak.endPosition) - Math.max(_this.start, axisBreak.startPosition)) / (_this.end - _this.start));\n          axisBreak.gridInterval = _this.chooseInterval(0, axisBreak.adjustedEndValue - axisBreak.adjustedStartValue, breakGridCount);\n          var gridDate = $time.round(new Date(axisBreak.adjustedStartValue), axisBreak.gridInterval.timeUnit, axisBreak.gridInterval.count, _this._firstWeekDay, _this._df.utc, undefined, _this._df.timezoneMinutes, _this._df.timezone);\n\n          if (gridDate.getTime() > axisBreak.startDate.getTime()) {\n            $time.add(gridDate, axisBreak.gridInterval.timeUnit, axisBreak.gridInterval.count, _this._df.utc);\n          }\n\n          axisBreak.gridDate = gridDate;\n        });\n      }\n    }\n  };\n  /**\r\n   * @ignore\r\n   */\n\n\n  DateAxis.prototype.getFirstWeekDay = function () {\n    if (this._df) {\n      return this._df.firstDayOfWeek;\n    }\n\n    return 1;\n  };\n  /**\r\n   * [getGridDate description]\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @todo Description\r\n   * @param date           [description]\r\n   * @param intervalCount  [description]\r\n   * @return [description]\r\n   */\n\n\n  DateAxis.prototype.getGridDate = function (date, intervalCount) {\n    var timeUnit = this._gridInterval.timeUnit;\n    var realIntervalCount = this._gridInterval.count; // round date\n\n    $time.round(date, timeUnit, 1, this._firstWeekDay, this._df.utc, undefined, this._df.timezoneMinutes, this._df.timezone);\n    var prevTimestamp = date.getTime();\n    var newDate = $time.copy(date); // modify date by adding intervalcount\n\n    var timestamp = $time.add(newDate, timeUnit, intervalCount, this._df.utc).getTime(); // if it's axis break, get first rounded date which is not in a break\n\n    var axisBreak = this.isInBreak(timestamp);\n\n    if (axisBreak && axisBreak.endDate) {\n      newDate = new Date(axisBreak.endDate.getTime());\n      $time.round(newDate, timeUnit, realIntervalCount, this._firstWeekDay, this._df.utc, undefined, this._df.timezoneMinutes, this._df.timezone);\n\n      if (newDate.getTime() < axisBreak.endDate.getTime()) {\n        $time.add(newDate, timeUnit, realIntervalCount, this._df.utc);\n      }\n\n      timestamp = newDate.getTime();\n    } // get duration between grid lines with break duration removed\n\n\n    var durationBreaksRemoved = this.adjustDifference(prevTimestamp, timestamp); // calculate how many time units fit to this duration\n\n    var countBreaksRemoved = Math.round(durationBreaksRemoved / $time.getDuration(timeUnit)); // if less units fit, add one and repeat\n\n    if (countBreaksRemoved < realIntervalCount) {\n      return this.getGridDate(date, intervalCount + realIntervalCount);\n    }\n\n    return newDate;\n  };\n  /**\r\n   * [getBreaklessDate description]\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @todo Description\r\n   * @param axisBreak  [description]\r\n   * @param timeUnit   [description]\r\n   * @param count      [description]\r\n   * @return [description]\r\n   */\n\n\n  DateAxis.prototype.getBreaklessDate = function (axisBreak, timeUnit, count) {\n    var date = new Date(axisBreak.endValue);\n    $time.round(date, timeUnit, count, this._firstWeekDay, this._df.utc, undefined, this._df.timezoneMinutes, this._df.timezone);\n    $time.add(date, timeUnit, count, this._df.utc);\n    var timestamp = date.getTime();\n    axisBreak = this.isInBreak(timestamp);\n\n    if (axisBreak) {\n      return this.getBreaklessDate(axisBreak, timeUnit, count);\n    }\n\n    return date;\n  };\n  /**\r\n   * (Re)validates all Axis elements.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @todo Description (review)\r\n   */\n\n\n  DateAxis.prototype.validateAxisElements = function () {\n    var _this = this;\n\n    if ($type.isNumber(this.max) && $type.isNumber(this.min)) {\n      this.calculateZoom(); // first regular items\n\n      var timestamp = this._gridDate.getTime();\n\n      var timeUnit = this._gridInterval.timeUnit;\n      var intervalCount = this._gridInterval.count;\n      var prevGridDate = $time.copy(this._gridDate);\n      var dataItemsIterator_1 = this._dataItemsIterator;\n      this.resetIterators();\n\n      var _loop_2 = function () {\n        var date = this_2.getGridDate($time.copy(prevGridDate), intervalCount);\n        timestamp = date.getTime();\n        var endDate = $time.copy(date); // you might think it's easier to add intervalduration to timestamp, however it won't work for months or years which are not of the same length\n\n        endDate = $time.add(endDate, timeUnit, intervalCount, this_2._df.utc);\n        var format = this_2.dateFormats.getKey(timeUnit);\n\n        if (this_2.markUnitChange && prevGridDate) {\n          if ($time.checkChange(date, prevGridDate, this_2._nextGridUnit, this_2._df.utc)) {\n            if (timeUnit !== \"year\") {\n              format = this_2.periodChangeDateFormats.getKey(timeUnit);\n            }\n          }\n        }\n\n        var text = this_2._df.format(date, format);\n\n        var dataItem = dataItemsIterator_1.find(function (x) {\n          return x.text === text;\n        });\n\n        if (dataItem.__disabled) {\n          dataItem.__disabled = false;\n        }\n\n        this_2.appendDataItem(dataItem);\n        dataItem.axisBreak = undefined;\n        dataItem.date = date;\n        dataItem.endDate = endDate;\n        dataItem.text = text;\n        this_2.validateDataElement(dataItem);\n        prevGridDate = date;\n      };\n\n      var this_2 = this;\n\n      while (timestamp <= this._maxZoomed) {\n        _loop_2();\n      } // breaks later\n\n\n      var renderer_1 = this.renderer;\n\n      if (this._axisBreaks) {\n        $iter.each(this._axisBreaks.iterator(), function (axisBreak) {\n          if (axisBreak.breakSize > 0) {\n            var timeUnit_1 = axisBreak.gridInterval.timeUnit;\n            var intervalCount_1 = axisBreak.gridInterval.count; // only add grid if gap is bigger then minGridDistance\n\n            if ($math.getDistance(axisBreak.startPoint, axisBreak.endPoint) > renderer_1.minGridDistance * 4) {\n              var timestamp_1 = axisBreak.gridDate.getTime();\n              var prevGridDate_1;\n              var count = 0;\n\n              var _loop_3 = function () {\n                var date = $time.copy(axisBreak.gridDate);\n                timestamp_1 = $time.add(date, timeUnit_1, intervalCount_1 * count, _this._df.utc).getTime();\n                count++;\n\n                if (timestamp_1 > axisBreak.adjustedStartValue && timestamp_1 < axisBreak.adjustedEndValue) {\n                  var endDate = $time.copy(date); // you might think it's easier to add intervalduration to timestamp, however it won't work for months or years which are not of the same length\n\n                  endDate = $time.add(endDate, timeUnit_1, intervalCount_1, _this._df.utc);\n\n                  var format = _this.dateFormats.getKey(timeUnit_1);\n\n                  if (_this.markUnitChange && prevGridDate_1) {\n                    if ($time.checkChange(date, prevGridDate_1, _this._nextGridUnit, _this._df.utc)) {\n                      if (timeUnit_1 !== \"year\") {\n                        format = _this.periodChangeDateFormats.getKey(timeUnit_1);\n                      }\n                    }\n                  }\n\n                  var text_1 = _this._df.format(date, format);\n\n                  var dataItem = dataItemsIterator_1.find(function (x) {\n                    return x.text === text_1;\n                  });\n\n                  if (dataItem.__disabled) {\n                    dataItem.__disabled = false;\n                  } //this.processDataItem(dataItem);\n\n\n                  _this.appendDataItem(dataItem);\n\n                  dataItem.axisBreak = axisBreak;\n                  axisBreak.dataItems.moveValue(dataItem);\n                  dataItem.date = date;\n                  dataItem.endDate = endDate;\n                  dataItem.text = text_1;\n                  prevGridDate_1 = date;\n\n                  _this.validateDataElement(dataItem);\n                }\n              };\n\n              while (timestamp_1 <= axisBreak.adjustedMax) {\n                _loop_3();\n              }\n            }\n          }\n        });\n      }\n    }\n  };\n  /**\r\n   * Validates Axis data item.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param dataItem Data item\r\n   */\n\n\n  DateAxis.prototype.validateDataElement = function (dataItem) {\n    dataItem.itemIndex = this._axisItemCount;\n    this._axisItemCount++;\n\n    if ($type.isNumber(this.max) && $type.isNumber(this.min)) {\n      var renderer = this.renderer;\n      var timestamp = dataItem.value;\n      var endTimestamp = dataItem.endValue;\n\n      if (!$type.isNumber(endTimestamp)) {\n        endTimestamp = timestamp;\n      }\n\n      var position = this.valueToPosition(timestamp);\n      var endPosition = this.valueToPosition(endTimestamp);\n      var fillEndPosition = endPosition;\n\n      if (!dataItem.isRange && this._gridInterval.count > this.baseInterval.count) {\n        endPosition = position + (endPosition - position) / (this._gridInterval.count / this.baseInterval.count);\n      }\n\n      dataItem.position = position;\n      var tick = dataItem.tick;\n\n      if (tick && !tick.disabled) {\n        renderer.updateTickElement(tick, position, endPosition);\n      }\n\n      var grid = dataItem.grid;\n\n      if (grid && !grid.disabled) {\n        renderer.updateGridElement(grid, position, endPosition);\n      }\n\n      var fill = dataItem.axisFill;\n\n      if (fill && !fill.disabled) {\n        renderer.updateFillElement(fill, position, fillEndPosition);\n\n        if (!dataItem.isRange) {\n          this.fillRule(dataItem);\n        }\n      }\n\n      var mask = dataItem.mask;\n\n      if (mask) {\n        renderer.updateFillElement(mask, position, endPosition);\n      }\n\n      if (dataItem.bullet) {\n        renderer.updateBullet(dataItem.bullet, position, endPosition);\n      }\n\n      var label = dataItem.label;\n\n      if (label && !label.disabled) {\n        var location_1 = label.location;\n\n        if (location_1 == 0) {\n          if (this._gridInterval.count == 1 && this._gridInterval.timeUnit != \"week\" && !dataItem.isRange) {\n            location_1 = 0.5;\n          } else {\n            location_1 = 0;\n          }\n        }\n\n        renderer.updateLabelElement(label, position, endPosition, location_1);\n      }\n    }\n  };\n\n  Object.defineProperty(DateAxis.prototype, \"baseDuration\", {\n    /**\r\n     * A duration in milliseconds of the `baseInterval`.\r\n     *\r\n     * @return Duration (ms)\r\n     */\n    get: function () {\n      return $time.getDuration(this.baseInterval.timeUnit, this.baseInterval.count);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\r\n   * Adjusts min/max values.\r\n   *\r\n   * @ignore Exclude from docs.\r\n   * @todo Description (review)\r\n   * @param min  Min timestamp\r\n   * @param max  Max timestamp\r\n   * @return Adjusted min/max step\r\n   */\n\n  DateAxis.prototype.adjustMinMax = function (min, max) {\n    return {\n      min: min,\n      max: max,\n      step: this.baseDuration\n    };\n  };\n  /**\r\n   * Adjusts the minimum timestamp as per cell start location.\r\n   *\r\n   * @param value  Value\r\n   * @return Adjusted value\r\n   */\n\n\n  DateAxis.prototype.fixMin = function (value) {\n    // like this because months are not equal\n    var interval = this.baseInterval;\n    var startTime = $time.round(new Date(value), interval.timeUnit, interval.count, this._firstWeekDay, this._df.utc, undefined, this._df.timezoneMinutes, this._df.timezone).getTime();\n    var endTime = $time.add(new Date(startTime), interval.timeUnit, interval.count, this._df.utc).getTime();\n    return startTime + (endTime - startTime) * this.startLocation;\n  };\n  /**\r\n   * Adjusts the maximum timestamp as per cell start location.\r\n   *\r\n   * @param value  Value\r\n   * @return Adjusted value\r\n   */\n\n\n  DateAxis.prototype.fixMax = function (value) {\n    // like this because months are not equal\n    var interval = this.baseInterval;\n    var startTime = $time.round(new Date(value), interval.timeUnit, interval.count, this._firstWeekDay, this._df.utc, undefined, this._df.timezoneMinutes, this._df.timezone).getTime();\n    var endTime = $time.add(new Date(startTime), interval.timeUnit, interval.count, this._df.utc).getTime();\n    return startTime + (endTime - startTime) * this.endLocation;\n  };\n  /**\r\n   * [chooseInterval description]\r\n   *\r\n   * @ignore Exclude from docs.\r\n   * @todo Description\r\n   * @param index      [description]\r\n   * @param duration   [description]\r\n   * @param gridCount  [description]\r\n   * @return [description]\r\n   */\n\n\n  DateAxis.prototype.chooseInterval = function (index, duration, gridCount, intervals) {\n    if (!intervals) {\n      intervals = this.gridIntervals;\n    }\n\n    var gridInterval = intervals.getIndex(index);\n    var intervalDuration = $time.getDuration(gridInterval.timeUnit, gridInterval.count);\n    var lastIndex = intervals.length - 1;\n\n    if (index >= lastIndex) {\n      return __assign({}, intervals.getIndex(lastIndex));\n    }\n\n    var count = Math.ceil(duration / intervalDuration);\n\n    if (duration < intervalDuration && index > 0) {\n      return __assign({}, intervals.getIndex(index - 1));\n    }\n\n    if (count <= gridCount) {\n      return __assign({}, intervals.getIndex(index));\n    } else {\n      if (index + 1 < intervals.length) {\n        return this.chooseInterval(index + 1, duration, gridCount, intervals);\n      } else {\n        return __assign({}, intervals.getIndex(index));\n      }\n    }\n  };\n  /**\r\n   * Formats the value according to axis' own [[DateFormatter]].\r\n   *\r\n   * @param value  Source value\r\n   * @return Formatted value\r\n   */\n\n\n  DateAxis.prototype.formatLabel = function (value) {\n    return this._df.format(value);\n  };\n  /**\r\n   * Converts a Date to an asbolute pixel position within Axis.\r\n   *\r\n   * @param date  Date\r\n   * @return Position (px)\r\n   */\n\n\n  DateAxis.prototype.dateToPosition = function (date) {\n    return this.valueToPosition(date.getTime());\n  };\n  /**\r\n   * Converts a numeric timestamp or a `Date` to a relative position on axis.\r\n   *\r\n   * @param date  Date or a timestamp\r\n   * @return Relative position\r\n   */\n\n\n  DateAxis.prototype.anyToPosition = function (date) {\n    if (date instanceof Date) {\n      return this.dateToPosition(date);\n    } else {\n      return this.valueToPosition(date);\n    }\n  };\n  /**\r\n   * Converts date to orientation point (x, y, angle) on axis\r\n   *\r\n   * @param date Date\r\n   * @return IOrientationPoint\r\n   */\n\n\n  DateAxis.prototype.dateToPoint = function (date) {\n    var position = this.dateToPosition(date);\n    var point = this.renderer.positionToPoint(position);\n    var angle = this.renderer.positionToAngle(position);\n    return {\n      x: point.x,\n      y: point.y,\n      angle: angle\n    };\n  };\n  /**\r\n   * Converts a numeric value to orientation (x, y, angle) point on axis\r\n   *\r\n   * @param value  Value\r\n   * @return Orientation point\r\n   */\n\n\n  DateAxis.prototype.anyToPoint = function (date) {\n    if (date instanceof Date) {\n      return this.dateToPoint(date);\n    } else {\n      return this.valueToPoint(date);\n    }\n  };\n  /**\r\n   * Converts pixel position within Axis to a corresponding Date.\r\n   *\r\n   * @param position  Position (px)\r\n   * @return Date\r\n   */\n\n\n  DateAxis.prototype.positionToDate = function (position) {\n    return new Date(this.positionToValue(position));\n  };\n  /**\r\n   * Returns the relative position on axis for series' data item's value.\r\n   *\r\n   * @since 4.5.14\r\n   * @param  dataItem  Data item\r\n   * @param  key       Data field to get value from\r\n   * @param  location  Location (0-1)\r\n   * @return           Relative position\r\n   */\n\n\n  DateAxis.prototype.getPositionX = function (dataItem, key, location, stackKey, range) {\n    var value = this.getTimeByLocation(dataItem, key, location); //let stack: number = dataItem.getValue(\"valueX\", \"stack\");\n\n    if (!$type.isNumber(value)) {\n      value = this.baseValue;\n    }\n\n    var position = this.valueToPosition(value);\n\n    if (range) {\n      position = $math.fitToRange(position, range.start, range.end);\n    }\n\n    return position;\n  };\n  /**\r\n   * Returns relative position on axis for series' data item's value.\r\n   *\r\n   * @since 4.5.14\r\n   * @param  dataItem  Data item\r\n   * @param  key       Data field to get value from\r\n   * @param  location  Location (0-1)\r\n   * @return           Relative position\r\n   */\n\n\n  DateAxis.prototype.getPositionY = function (dataItem, key, location, stackKey, range) {\n    var value = this.getTimeByLocation(dataItem, key, location);\n    var stack = dataItem.getValue(\"valueX\", \"stack\");\n\n    if (!$type.isNumber(value)) {\n      value = this.baseValue;\n    }\n\n    var position = this.valueToPosition(value + stack);\n\n    if (range) {\n      position = $math.fitToRange(position, range.start, range.end);\n    }\n\n    return position;\n  };\n  /**\r\n   * Returns an angle for series data item.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @todo Description (review)\r\n   * @param dataItem  Data item\r\n   * @param key       Data field to get value from\r\n   * @param location  Location (0-1)\r\n   * @param stackKey  Stack ID\r\n   * @param range Range to fit in\r\n   * @return Angle\r\n   */\n\n\n  DateAxis.prototype.getAngle = function (dataItem, key, location, stackKey, range) {\n    var value = this.getTimeByLocation(dataItem, key, location);\n    var stack = dataItem.getValue(stackKey, \"stack\");\n\n    if (!$type.isNumber(value)) {\n      value = this.baseValue;\n    }\n\n    var position = this.valueToPosition(value + stack);\n\n    if (range) {\n      position = $math.fitToRange(position, range.start, range.end);\n    }\n\n    return this.positionToAngle(position);\n  };\n  /**\r\n   * [getTimeByLocation description]\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @todo Description\r\n   * @param dataItem  [description]\r\n   * @param key       [description]\r\n   * @param location  [description]\r\n   * @return [description]\r\n   */\n\n\n  DateAxis.prototype.getTimeByLocation = function (dataItem, key, location) {\n    if (!$type.hasValue(key)) {\n      return;\n    }\n\n    if (!$type.isNumber(location)) {\n      location = dataItem.workingLocations[key];\n\n      if (!$type.isNumber(location)) {\n        location = 0;\n      }\n    }\n\n    var startTime = dataItem.values[key][\"open\"];\n    var endTime = dataItem.values[key][\"close\"];\n    var workingValue = dataItem.values[key].workingValue;\n    var value = dataItem.values[key].value;\n    var difference = value - workingValue;\n    startTime -= difference;\n    endTime -= difference;\n\n    if ($type.isNumber(startTime) && $type.isNumber(endTime)) {\n      return startTime + (endTime - startTime) * location;\n    }\n  };\n  /**\r\n   * Processes a related series' data item.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @todo Description\r\n   * @param dataItem  Data item\r\n   */\n\n\n  DateAxis.prototype.processSeriesDataItem = function (dataItem, axisLetter) {\n    var series = dataItem.component;\n    var time;\n    var date = dataItem[\"date\" + axisLetter];\n\n    if ($type.isNumber(this.timezoneOffset)) {\n      date.setTime(date.getTime() + (date.getTimezoneOffset() - this.timezoneOffset) * 60000);\n      dataItem.setValue(\"date\" + axisLetter, date.getTime(), 0);\n    } else if ($type.hasValue(this.timezone)) {\n      date = $time.setTimezone(date, this.timezone);\n      dataItem.setValue(\"date\" + axisLetter, date.getTime(), 0);\n      dataItem[\"date\" + axisLetter] = date;\n    }\n\n    if (date) {\n      time = date.getTime();\n    } else {\n      return;\n    }\n\n    var openDate = dataItem[\"openDate\" + axisLetter];\n    var prevSeriesTime = this._prevSeriesTime[series.uid];\n    var openTime;\n\n    if (openDate) {\n      openTime = openDate.getTime();\n    }\n\n    if ($type.isNumber(openTime)) {\n      var difference = Math.abs(time - openTime);\n\n      if (this._minDifference[series.uid] > difference) {\n        this._minDifference[series.uid] = difference;\n      }\n    }\n\n    var differece = time - prevSeriesTime;\n\n    if (differece > 0) {\n      if (this._minDifference[series.uid] > differece) {\n        this._minDifference[series.uid] = differece;\n      }\n    }\n\n    this._prevSeriesTime[series.uid] = time;\n\n    if (series._baseInterval[this.uid]) {\n      this.postProcessSeriesDataItem(dataItem);\n    }\n  };\n  /**\r\n   * [updateAxisBySeries description]\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @todo Description\r\n   */\n\n\n  DateAxis.prototype.updateAxisBySeries = function () {\n    _super.prototype.updateAxisBySeries.call(this);\n\n    var baseInterval = this.chooseInterval(0, this.minDifference, 1);\n\n    if (this.minDifference >= $time.getDuration(\"day\", 27) && baseInterval.timeUnit == \"week\") {\n      baseInterval.timeUnit = \"month\";\n      baseInterval.count = 1;\n    }\n\n    if (baseInterval.timeUnit == \"month\") {\n      if (this.minDifference >= $time.getDuration(\"day\", 29 * 2) && baseInterval.count == 1) {\n        baseInterval.count = 2;\n      }\n\n      if (this.minDifference >= $time.getDuration(\"day\", 29 * 3) && baseInterval.count == 2) {\n        baseInterval.count = 3;\n      }\n\n      if (this.minDifference >= $time.getDuration(\"day\", 29 * 6) && baseInterval.count == 5) {\n        baseInterval.count = 6;\n      }\n    } // handle daylight saving\n\n\n    if (this.minDifference >= $time.getDuration(\"hour\", 23) && baseInterval.timeUnit == \"hour\") {\n      baseInterval.timeUnit = \"day\";\n      baseInterval.count = 1;\n    }\n\n    if (this.minDifference >= $time.getDuration(\"week\", 1) - $time.getDuration(\"hour\", 1) && baseInterval.timeUnit == \"day\") {\n      baseInterval.timeUnit = \"week\";\n      baseInterval.count = 1;\n    }\n\n    if (this.minDifference >= $time.getDuration(\"year\", 1) - $time.getDuration(\"day\", 1.01) && baseInterval.timeUnit == \"month\") {\n      baseInterval.timeUnit = \"year\";\n      baseInterval.count = 1;\n    }\n\n    this._baseIntervalReal = baseInterval;\n    this._mainBaseInterval = baseInterval; // no need to invalidate\n  };\n\n  Object.defineProperty(DateAxis.prototype, \"baseInterval\", {\n    /**\r\n     * @return Base interval\r\n     */\n    get: function () {\n      if (this._groupInterval) {\n        return this._groupInterval;\n      } else if (this._baseInterval) {\n        return this._baseInterval;\n      } else {\n        return this._baseIntervalReal;\n      }\n    },\n\n    /**\r\n     * A base interval (granularity) of data.\r\n     *\r\n     * Used to indicate what are the base units of your data.\r\n     *\r\n     * For example, if you have a data set that has a data point every 5 minutes,\r\n     * you may want to set this to `{ timeUnit: \"minute\", count: 5 }`.\r\n     *\r\n     * If not set, the Axis will try to determine the setting by its own, looking\r\n     * at actual data.\r\n     *\r\n     * For best results, try to follow these values for `count`:\r\n     *\r\n     * When unit is \"month\", use 12 / count = round number\r\n     * When unit is \"hour\", use 24 / count = round number\r\n     * When unit is \"second\" and \"minute\", use 60 / count = round number\r\n     *\r\n     * @param timeInterval base interval\r\n     */\n    set: function (timeInterval) {\n      if (JSON.stringify(this._baseInterval) != JSON.stringify(timeInterval)) {\n        this._baseInterval = timeInterval;\n        this._mainBaseInterval = timeInterval;\n\n        if (!$type.isNumber(timeInterval.count)) {\n          timeInterval.count = 1;\n        }\n\n        this.invalidate();\n        this.postProcessSeriesDataItems();\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(DateAxis.prototype, \"mainBaseInterval\", {\n    /**\r\n     * Indicates granularity of the data of source (unaggregated) data.\r\n     *\r\n     * @since 4.7.0\r\n     * @return Granularity of the main data set\r\n     */\n    get: function () {\n      if (this._baseInterval) {\n        return this._baseInterval;\n      } else if (this._mainBaseInterval) {\n        return this._mainBaseInterval;\n      } else {\n        return this._baseIntervalReal;\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(DateAxis.prototype, \"skipEmptyPeriods\", {\n    /**\r\n     * @return Remove empty stretches of time?\r\n     */\n    get: function () {\n      return this.getPropertyValue(\"skipEmptyPeriods\");\n    },\n\n    /**\r\n     * If enabled, axis will automatically collapse empty (without data points)\r\n     * periods of time, i.e. weekends.\r\n     *\r\n     * An \"empty\" period is considered a stretch of time in the length of current\r\n     * `baseInterval` without a single data point in it.\r\n     *\r\n     * For each such empty period, axis will automatically create an\r\n     * [[AxisBreak]]. By default they will be invisible. You can still configure\r\n     * them by accessing `axis.breaks.template`.\r\n     *\r\n     * [More info about breaks](https://www.amcharts.com/docs/v4/concepts/axes/#Breaks).\r\n     *\r\n     * Important notes:\r\n     * * If you set this property to `true`, you can not add your custom axis breaks to this axis anymore.\r\n     * * Using this feature affects performance. Use only if you need it.\r\n     * * Setting this to `true` will reset appearance of breaks. If you want to modify appearance, do it *after* you set `skipEmptyPeriods`.\r\n     * * Some axis label overlapping might happen.\r\n     * * This setting is not compatible with `groupData = true`.\r\n     *\r\n     * @default false\r\n     * @param value  Remove empty stretches of time?\r\n     */\n    set: function (value) {\n      if (value) {\n        var breakTemplate = this.axisBreaks.template;\n        breakTemplate.startLine.disabled = true;\n        breakTemplate.endLine.disabled = true;\n        breakTemplate.fillShape.disabled = true;\n        breakTemplate.breakSize = 0;\n      } else {\n        if (this._gapBreaks) {\n          this.axisBreaks.clear();\n          this._gapBreaks = false;\n        }\n      }\n\n      if (this.setPropertyValue(\"skipEmptyPeriods\", value)) {\n        this.invalidate();\n        this.postProcessSeriesDataItems();\n        this.invalidateSeries();\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(DateAxis.prototype, \"tooltipDateFormat\", {\n    /**\r\n     * @return Date format\r\n     */\n    get: function () {\n      return this.getPropertyValue(\"tooltipDateFormat\");\n    },\n\n    /**\r\n     * A special date format to apply axis tooltips.\r\n     *\r\n     * Will use same format as for labels, if not set.\r\n     *\r\n     * @param value  Date format\r\n     */\n    set: function (value) {\n      this.setPropertyValue(\"tooltipDateFormat\", value);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(DateAxis.prototype, \"markUnitChange\", {\n    /**\r\n     * @return Use different format for period beginning?\r\n     */\n    get: function () {\n      return this.getPropertyValue(\"markUnitChange\");\n    },\n\n    /**\r\n     * Use `periodChangeDateFormats` to apply different formats to the first\r\n     * label in bigger time unit.\r\n     *\r\n     * @default true\r\n     * @param value  Use different format for period beginning?\r\n     */\n    set: function (value) {\n      if (this.setPropertyValue(\"markUnitChange\", value)) {\n        this.invalidateData();\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\r\n   * Returns text to show in a tooltip, based on specific relative position\r\n   * within axis.\r\n   *\r\n   * The label will be formatted as per [[DateFormatter]] set for the whole\r\n   * chart, or explicitly for this Axis.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param position  Position\r\n   * @return Label (formatted date)\r\n   */\n\n  DateAxis.prototype.getTooltipText = function (position) {\n    var text;\n    var date = this.positionToDate(position);\n    date = $time.round(date, this.baseInterval.timeUnit, this.baseInterval.count, this._firstWeekDay, this._df.utc, new Date(this.min), this._df.timezoneMinutes, this._df.timezone);\n    this.tooltipDate = date;\n\n    if ($type.hasValue(this.tooltipDateFormat)) {\n      text = this._df.format(date, this.tooltipDateFormat, [\"day\", \"month\", \"week\", \"year\"].indexOf(this.baseInterval.timeUnit) == -1);\n    } else {\n      var dateFormat = this.dateFormats.getKey(this.baseInterval.timeUnit);\n\n      if (dateFormat) {\n        text = this._df.format(date, dateFormat);\n      } else {\n        text = this.getPositionLabel(position);\n      }\n    }\n\n    if (!this._adapterO) {\n      return text;\n    } else {\n      return this._adapterO.apply(\"getTooltipText\", text);\n    }\n  };\n  /**\r\n   * Takes an absolute position within axis and adjust it to a specific position within base interval. (cell)\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param position Source position\r\n   * @param location  Location in the cell\r\n   * @return Adjusted position\r\n   */\n\n\n  DateAxis.prototype.roundPosition = function (position, location, axisLocation) {\n    var baseInterval = this.baseInterval;\n    var timeUnit = baseInterval.timeUnit;\n    var count = baseInterval.count;\n    var date = this.positionToDate(position);\n    $time.round(date, timeUnit, count, this._firstWeekDay, this._df.utc, undefined, this._df.timezoneMinutes, this._df.timezone);\n\n    if (location > 0) {\n      $time.add(date, timeUnit, location * count, this._df.utc);\n    }\n\n    if (axisLocation > 0 && axisLocation < 1) {\n      date.setTime(date.getTime() + this.baseDuration * axisLocation);\n    }\n\n    if (this.isInBreak(date.getTime())) {\n      while (date.getTime() < this.max) {\n        $time.add(date, timeUnit, count, this._df.utc);\n\n        if (!this.isInBreak(date.getTime())) {\n          break;\n        }\n      }\n    }\n\n    return this.dateToPosition(date);\n  };\n  /**\r\n   * Returns an relative position of the start of the cell (period), that specific position value falls into.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @todo Description (review)\r\n   * @param position  Relative position\r\n   * @return Cell start relative position\r\n   */\n\n\n  DateAxis.prototype.getCellStartPosition = function (position) {\n    return this.roundPosition(position, 0);\n  };\n  /**\r\n   * Returns an relative position of the end of the cell (period), that specific position value falls into.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @todo Description (review)\r\n   * @param position  Relative position\r\n   * @return Cell end relative position\r\n   */\n\n\n  DateAxis.prototype.getCellEndPosition = function (position) {\n    return this.roundPosition(position, 1); //return this.dateToPosition($time.add(this.positionToDate(this.roundPosition(position, 1)), this.baseInterval.timeUnit, this.baseInterval.count));\n  };\n  /**\r\n   * Returns a Series data item that corresponds to the specific pixel position\r\n   * of the Axis.\r\n   *\r\n   * If `findNearest` (third parameter) is set to `true`, the method will try\r\n   * to locate nearest available data item if none is found directly under\r\n   * `position`.\r\n   *\r\n   * @param series       Series\r\n   * @param position     Position (px)\r\n   * @param findNearest  Should axis try to find nearest tooltip if there is no data item at exact position\r\n   * @return Data item\r\n   */\n\n\n  DateAxis.prototype.getSeriesDataItem = function (series, position, findNearest) {\n    var value = this.positionToValue(position);\n    var location = 0.5;\n\n    if (this.axisLetter == \"Y\") {\n      location = series.dataItems.template.locations.dateY;\n    } else {\n      location = series.dataItems.template.locations.dateX;\n    }\n\n    var deltaValue = value - location * this.baseDuration;\n    var date = $time.round(new Date(value), this.baseInterval.timeUnit, this.baseInterval.count, this._firstWeekDay, this._df.utc, undefined, this._df.timezoneMinutes, this._df.timezone);\n    var nextDate = $time.round(new Date(value + this.baseDuration), this.baseInterval.timeUnit, this.baseInterval.count, this._firstWeekDay, this._df.utc, undefined, this._df.timezoneMinutes, this._df.timezone);\n\n    if (nextDate.getTime() > date.getTime()) {\n      if (Math.abs(nextDate.getTime() - deltaValue) < Math.abs(deltaValue - date.getTime())) {\n        date = nextDate;\n      }\n    }\n\n    var dataItemsByAxis = series.dataItemsByAxis.getKey(this.uid);\n    var dataItem = dataItemsByAxis.getKey(date.getTime() + series.currentDataSetId); // todo:  alternatively we can find closiest here\n\n    if (!dataItem && findNearest) {\n      var key_1;\n\n      if (this.axisLetter == \"Y\") {\n        key_1 = \"dateY\";\n      } else {\n        key_1 = \"dateX\";\n      }\n\n      dataItem = series.dataItems.getIndex(series.dataItems.findClosestIndex(date.getTime(), function (x) {\n        if (x[key_1]) {\n          return x[key_1].getTime();\n        } else {\n          return -Infinity;\n        }\n      }, \"any\"));\n    }\n\n    return dataItem;\n  };\n  /**\r\n   * Returns a formatted date based on position in axis scale.\r\n   *\r\n   * Please note that `position` represents position within axis which may be\r\n   * zoomed and not correspond to Cursor's `position`.\r\n   *\r\n   * To convert Cursor's `position` to Axis' `position` use `toAxisPosition()` method.\r\n   *\r\n   * @see {@link https://www.amcharts.com/docs/v4/tutorials/tracking-cursors-position-via-api/#Tracking_Cursor_s_position} For more information about cursor tracking.\r\n   * @param position  Relative position on axis (0-1)\r\n   * @return Position label\r\n   */\n\n\n  DateAxis.prototype.getPositionLabel = function (position) {\n    // @todo Better format recognition\n    var date = this.positionToDate(position);\n    return this._df.format(date, this.getCurrentLabelFormat());\n  };\n  /**\r\n   * Returns label date format based on currently used time units\r\n   *\r\n   * @return Format\r\n   */\n\n\n  DateAxis.prototype.getCurrentLabelFormat = function () {\n    return this.dateFormats.getKey(this._gridInterval ? this._gridInterval.timeUnit : \"day\");\n  };\n  /**\r\n   * Initializes an Axis renderer.\r\n   *\r\n   * @ignore Exclude from docs\r\n   */\n\n\n  DateAxis.prototype.initRenderer = function () {\n    _super.prototype.initRenderer.call(this);\n\n    var renderer = this.renderer;\n\n    if (renderer) {\n      // Set defaults\n      renderer.ticks.template.location = 0;\n      renderer.grid.template.location = 0;\n      renderer.labels.template.location = 0;\n      renderer.baseGrid.disabled = true;\n    }\n  };\n\n  Object.defineProperty(DateAxis.prototype, \"basePoint\", {\n    /**\r\n     * Coordinates of the actual axis start.\r\n     *\r\n     * @ignore Exclude from docs\r\n     * @return Base point\r\n     */\n    get: function () {\n      return {\n        x: 0,\n        y: 0\n      };\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\r\n   * @ignore\r\n   */\n\n  DateAxis.prototype.animateMinMax = function (min, max) {\n    var _this = this;\n\n    var animation = this.animate([{\n      property: \"_minAdjusted\",\n      from: this._minAdjusted,\n      to: min\n    }, {\n      property: \"_maxAdjusted\",\n      from: this._maxAdjusted,\n      to: max\n    }], this.rangeChangeDuration, this.rangeChangeEasing);\n    animation.events.on(\"animationprogress\", function () {\n      _this.dispatch(\"extremeschanged\");\n    });\n    return animation;\n  };\n  /**\r\n   * Invalidates axis data items when series extremes change\r\n   */\n\n\n  DateAxis.prototype.handleExtremesChange = function () {\n    _super.prototype.handleExtremesChange.call(this);\n\n    if (this.groupData) {\n      var id = this.baseInterval.timeUnit + this.baseInterval.count;\n      this.groupMin[id] = this._finalMin;\n      this.groupMax[id] = this._finalMax;\n    }\n  };\n  /**\r\n   * Zooms axis to specific Dates.\r\n   *\r\n   * @param startDate       Start date\r\n   * @param endValue        End date\r\n   * @param skipRangeEvent  Do not invoke events\r\n   * @param instantly       Do not play zoom animations\r\n   */\n\n\n  DateAxis.prototype.zoomToDates = function (startDate, endDate, skipRangeEvent, instantly, adjust) {\n    startDate = this._df.parse(startDate);\n    endDate = this._df.parse(endDate);\n    this.zoomToValues(startDate.getTime(), endDate.getTime(), skipRangeEvent, instantly, adjust);\n  };\n  /**\r\n   * Zooms axis to specific values.\r\n   *\r\n   * @param startValue      Start value\r\n   * @param endValue        End value\r\n   * @param skipRangeEvent  Do not invoke events\r\n   * @param instantly       Do not play zoom animations\r\n   */\n\n\n  DateAxis.prototype.zoomToValues = function (startValue, endValue, skipRangeEvent, instantly, adjust) {\n    var _this = this;\n\n    if (!this.groupData) {\n      //let start: number = (startValue - this.min) / (this.max - this.min);\n      //let end: number = (endValue - this.min) / (this.max - this.min);\n      var start = this.valueToPosition(startValue);\n      var end = this.valueToPosition(endValue);\n      this.zoom({\n        start: start,\n        end: end\n      }, skipRangeEvent, instantly);\n    } else {\n      var difference = this.adjustDifference(startValue, endValue);\n      var isEnd = false;\n\n      if (endValue == this.max) {\n        isEnd = true;\n      }\n\n      var isStart = false;\n\n      if (startValue == this.min) {\n        isStart = true;\n      }\n\n      if ($type.hasValue(difference)) {\n        var mainBaseInterval = this.mainBaseInterval;\n        var groupInterval_1 = this.chooseInterval(0, difference, this.groupCount, this.groupIntervals);\n\n        if (groupInterval_1.timeUnit == mainBaseInterval.timeUnit && groupInterval_1.count < mainBaseInterval.count || $time.getDuration(groupInterval_1.timeUnit, 1) < $time.getDuration(mainBaseInterval.timeUnit, 1)) {\n          groupInterval_1 = __assign({}, mainBaseInterval);\n        }\n\n        var id = groupInterval_1.timeUnit + groupInterval_1.count;\n        var min_1 = this.groupMin[id];\n        var max_1 = this.groupMax[id];\n\n        if (!$type.isNumber(min_1) || !$type.isNumber(max_1)) {\n          min_1 = Number.POSITIVE_INFINITY;\n          max_1 = Number.NEGATIVE_INFINITY;\n          this.series.each(function (series) {\n            var seriesMin = series.min(_this);\n            var seriesMax = series.max(_this);\n\n            if (series._dataSets) {\n              var ds = series._dataSets.getKey(groupInterval_1.timeUnit + groupInterval_1.count);\n\n              if (ds) {\n                var mindi = ds.getIndex(0);\n                var maxdi = ds.getIndex(ds.length - 1);\n\n                if (mindi) {\n                  if (series.xAxis == _this) {\n                    seriesMin = mindi.dateX.getTime();\n                  } else if (series.yAxis == _this) {\n                    seriesMin = mindi.dateY.getTime();\n                  }\n                }\n\n                if (maxdi) {\n                  if (series.xAxis == _this) {\n                    seriesMax = maxdi.dateX.getTime();\n                  } else if (series.yAxis == _this) {\n                    seriesMax = maxdi.dateY.getTime();\n                  }\n                }\n              }\n            }\n\n            seriesMax = $time.round($time.add(new Date(seriesMax), groupInterval_1.timeUnit, 1, _this._df.utc), groupInterval_1.timeUnit, 1, _this._df.firstDayOfWeek, _this._df.utc, undefined, _this._df.timezoneMinutes, _this._df.timezone).getTime();\n\n            if (seriesMin < min_1) {\n              min_1 = seriesMin;\n            }\n\n            if (seriesMax > max_1) {\n              max_1 = seriesMax;\n            }\n          });\n          this.groupMin[id] = min_1;\n          this.groupMax[id] = max_1;\n        }\n\n        startValue = $math.fitToRange(startValue, min_1, max_1);\n        endValue = $math.fitToRange(endValue, min_1, max_1);\n\n        if (adjust) {\n          if (isEnd) {\n            startValue = endValue - difference;\n            startValue = $math.fitToRange(startValue, min_1, max_1);\n          }\n\n          if (isStart) {\n            endValue = startValue + difference;\n            endValue = $math.fitToRange(endValue, min_1, max_1);\n          }\n        }\n\n        var start = (startValue - min_1) / (max_1 - min_1);\n        var end = (endValue - min_1) / (max_1 - min_1);\n        this.zoom({\n          start: start,\n          end: end\n        }, skipRangeEvent, instantly);\n      }\n    }\n  };\n  /**\r\n   * Adds `baseInterval` to \"as is\" fields.\r\n   *\r\n   * @param field  Field name\r\n   * @return Assign as is?\r\n   */\n\n\n  DateAxis.prototype.asIs = function (field) {\n    return field == \"baseInterval\" || _super.prototype.asIs.call(this, field);\n  };\n  /**\r\n   * Copies all properties and related data from a different instance of Axis.\r\n   *\r\n   * @param source Source Axis\r\n   */\n\n\n  DateAxis.prototype.copyFrom = function (source) {\n    var _this = this;\n\n    _super.prototype.copyFrom.call(this, source);\n\n    this.dateFormats = source.dateFormats;\n    this.periodChangeDateFormats = source.periodChangeDateFormats;\n    this.groupIntervals.clear();\n    source.groupIntervals.each(function (interval) {\n      _this.groupIntervals.push(__assign({}, interval));\n    });\n    this.gridIntervals.clear();\n    source.gridIntervals.each(function (interval) {\n      _this.gridIntervals.push(__assign({}, interval));\n    });\n\n    if (source._baseInterval) {\n      this.baseInterval = source._baseInterval;\n    }\n  };\n  /**\r\n   * Shows Axis tooltip at specific relative position within Axis. (0-1)\r\n   *\r\n   * @param position Position (0-1)\r\n   * @param local or global position\r\n   */\n\n\n  DateAxis.prototype.showTooltipAtPosition = function (position, local) {\n    var _this = this;\n\n    if (!local) {\n      position = this.toAxisPosition(position);\n    }\n\n    if (this.snapTooltip) {\n      // rounding is not good, pen/aac4e7f66f019d36b2447f050c600c13 (no last tootltip shown)\n      var actualDate = this.positionToDate(position); //$time.round(this.positionToDate(position), this.baseInterval.timeUnit, 1, this.getFirstWeekDay(), this.dateFormatter.utc, undefined, this._df.timezoneMinutes, this._df.timezone);\n\n      var actualTime_1 = actualDate.getTime();\n      var closestDate_1;\n      this.series.each(function (series) {\n        if (series.baseAxis == _this) {\n          var dataItem = _this.getSeriesDataItem(series, position, true);\n\n          if (dataItem) {\n            var date = void 0;\n\n            if (series.xAxis == _this) {\n              date = dataItem.dateX;\n            }\n\n            if (series.yAxis == _this) {\n              date = dataItem.dateY;\n            }\n\n            if (!closestDate_1) {\n              closestDate_1 = date;\n            } else {\n              if (Math.abs(closestDate_1.getTime() - actualTime_1) > Math.abs(date.getTime() - actualTime_1)) {\n                closestDate_1 = date;\n              }\n            }\n          }\n        }\n      });\n\n      if (closestDate_1) {\n        var closestTime_1 = closestDate_1.getTime();\n        closestDate_1 = $time.round(new Date(closestTime_1), this.baseInterval.timeUnit, this.baseInterval.count, this._firstWeekDay, this._df.utc, undefined, this._df.timezoneMinutes, this._df.timezone);\n        closestTime_1 = closestDate_1.getTime();\n        var tooltipLocation = this.renderer.tooltipLocation;\n\n        if (tooltipLocation == 0) {\n          tooltipLocation = 0.0001;\n        }\n\n        closestDate_1 = new Date(closestDate_1.getTime() + this.baseDuration * tooltipLocation);\n        position = this.dateToPosition(closestDate_1);\n\n        if (this.chart.cursor && this.chart.cursor.snapToSeries) {//void\n        } else {\n          this.series.each(function (series) {\n            var dataItem = series.dataItemsByAxis.getKey(_this.uid).getKey(closestTime_1 + series.currentDataSetId);\n            var point = series.showTooltipAtDataItem(dataItem);\n\n            if (point) {\n              _this.chart._seriesPoints.push({\n                series: series,\n                point: point\n              });\n            } else {\n              // check, otherwise column tooltip will be hidden\n              if (series.tooltipText || series.tooltipHTML) {\n                series.hideTooltip();\n              }\n            }\n          });\n        } //this.chart.sortSeriesTooltips(seriesPoints);\n\n      }\n    }\n\n    _super.prototype.showTooltipAtPosition.call(this, position, true);\n  };\n\n  Object.defineProperty(DateAxis.prototype, \"snapTooltip\", {\n    /**\r\n     * @return Should snap?\r\n     */\n    get: function () {\n      return this.getPropertyValue(\"snapTooltip\");\n    },\n\n    /**\r\n     * Should the nearest tooltip be shown if no data item is found on the\r\n     * current cursor position.\r\n     *\r\n     * @default true\r\n     * @param value  Should snap?\r\n     */\n    set: function (value) {\n      this.setPropertyValue(\"snapTooltip\", value);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(DateAxis.prototype, \"groupData\", {\n    /**\r\n     * @return Group data points?\r\n     */\n    get: function () {\n      return this.getPropertyValue(\"groupData\");\n    },\n\n    /**\r\n     * Indicates if data should be aggregated to composide data items if there\r\n     * are more data items in selected range than `groupCount`.\r\n     *\r\n     * Grouping will occur automatically, based on current selection range, and\r\n     * will change dynamically when user zooms in/out the chart.\r\n     *\r\n     * NOTE: This works only if [[DateAxis]] is base axis of an [[XYSeries]].\r\n     *\r\n     * The related [[XYSeries]] also needs to be set up to take advantage of, by\r\n     * setting its [`groupFields`](https://www.amcharts.com/docs/v4/reference/xyseries/#groupFields_property).\r\n     *\r\n     * The group intervals to aggregate data to is defined by `groupIntervals`\r\n     * property.\r\n     *\r\n     * ```TypeScript\r\n     * let dateAxis = chart.xAxes.push(new am4charts.DateAxis());\r\n     * dateAxis.groupData = true;\r\n     *\r\n     * let valueAxis = chart.xAxes.push(new am4charts.valueAxis());\r\n     *\r\n     * let series = chart.series.push(new am4charts.LineSeries());\r\n     * series.dataFields.dateX = \"date\";\r\n     * series.dataFields.valueY = \"value\";\r\n     * series.groupFields.valueY = \"average\";\r\n     * ```\r\n     * ```JavaScript\r\n     * var dateAxis = chart.xAxes.push(new am4charts.DateAxis());\r\n     * dateAxis.groupData = true;\r\n     *\r\n     * var valueAxis = chart.xAxes.push(new am4charts.valueAxis());\r\n     *\r\n     * var series = chart.series.push(new am4charts.LineSeries());\r\n     * series.dataFields.dateX = \"date\";\r\n     * series.dataFields.valueY = \"value\";\r\n     * series.groupFields.valueY = \"average\";\r\n     * ```\r\n     * ```JSON\r\n     * {\r\n     *   // ...\r\n     *   \"xAxes\": [{\r\n     *     \"type\": \"DateAxis\",\r\n     *     \"groupData\": true\r\n     *   }],\r\n     *   \"yAxes\": [{\r\n     *     \"type\": \"ValueAxis\"\r\n     *   }],\r\n     *   \"series\": [{\r\n     *     \"type\": \"LineSeries\",\r\n     *     \"dataFields\": {\r\n     *       \"dateX\": \"date\",\r\n     *       \"valueY\": \"value\"\r\n     *     },\r\n     *     \"groupFields\": {\r\n     *       \"valueY\": \"average\"\r\n     *     }\r\n     *   }]\r\n     * }\r\n     * ```\r\n     *\r\n     * @default false\r\n     * @see {@link https://www.amcharts.com/docs/v4/concepts/axes/date-axis/#Dynamic_data_item_grouping} for more information about dynamic data item grouping.\r\n     * @since 4.7.0\r\n     * @param  value  Group data points?\r\n     */\n    set: function (value) {\n      var _this = this;\n\n      if (this.setPropertyValue(\"groupData\", value)) {\n        this.series.each(function (series) {\n          series.setDataSet(\"\");\n\n          if (value && !series.dataGrouped && series.inited) {\n            series._baseInterval[_this.uid] = _this.mainBaseInterval;\n\n            _this.groupSeriesData(series);\n          }\n        });\n        this._currentDataSetId = \"\";\n        this._groupInterval = undefined;\n        this.invalidate();\n        this.invalidateSeries();\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(DateAxis.prototype, \"groupInterval\", {\n    /**\r\n     * @return Interval\r\n     */\n    get: function () {\n      return this.getPropertyValue(\"groupInterval\");\n    },\n\n    /**\r\n     * Disables automatic selection of data grouping intervals and always uses\r\n     * `groupInterval` if set. Works only if `groupData = true`.\r\n     *\r\n     * @since 4.9.24\r\n     * @param  value  Interval\r\n     */\n    set: function (value) {\n      if (this.setPropertyValue(\"groupInterval\", value)) {\n        this.invalidate();\n        this.invalidateSeries();\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(DateAxis.prototype, \"groupCount\", {\n    /**\r\n     * @return Number of data items\r\n     */\n    get: function () {\n      return this.getPropertyValue(\"groupCount\");\n    },\n\n    /**\r\n     * Indicates threshold of data items in selected range at which to start\r\n     * aggregating data items if `groupData = true`.\r\n     *\r\n     * @default 200\r\n     * @since 4.7.0\r\n     * @param  value  Number of data items\r\n     */\n    set: function (value) {\n      this.setPropertyValue(\"groupCount\", value);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(DateAxis.prototype, \"timezoneOffset\", {\n    /**\r\n     * @todo Timezone offset in minutes\r\n     */\n    get: function () {\n      return this.getPropertyValue(\"timezoneOffset\");\n    },\n\n    /**\r\n     * If set will recalculate all timestamps in data by applying specific offset\r\n     * in minutes.\r\n     *\r\n     * IMPORTANT: do not set `timezoneOffset` on both `DateAxis` and `dateFormatter`. It\r\n     * will skew your results by applying offset twice.\r\n     *\r\n     * @since 4.8.5\r\n     * @param  value Time zone offset in minutes\r\n     */\n    set: function (value) {\n      this.setPropertyValue(\"timezoneOffset\", value);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(DateAxis.prototype, \"timezone\", {\n    /**\r\n     * @return Timezone\r\n     */\n    get: function () {\n      return this.getPropertyValue(\"timezone\");\n    },\n\n    /**\r\n     * If set will recalculate all timestamps in data to specific named timezone,\r\n     * e.g. `\"America/Vancouver\"`, `\"Australia/Sydney\"`, `\"UTC\"`, etc.\r\n     *\r\n     * IMPORTANT: it is no longer recommended to use this setting. Please\r\n     * set`timezone` on `dateFormatter`.\r\n     *\r\n     * @deprecated\r\n     * @since 4.10.1\r\n     * @param  value Time zone\r\n     */\n    set: function (value) {\n      this.setPropertyValue(\"timezone\", value);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(DateAxis.prototype, \"gridInterval\", {\n    /**\r\n     * Current grid interval.\r\n     *\r\n     * @return Grid interval\r\n     */\n    get: function () {\n      return this._gridInterval;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\r\n   * @ignore\r\n   */\n\n  DateAxis.prototype.makeGap = function (dataItem, previous) {\n    var series = dataItem.component;\n\n    if (dataItem && previous) {\n      if (!series.connect && $type.isNumber(series.autoGapCount)) {\n        if (series.baseAxis == this) {\n          var date = dataItem.dates[\"date\" + this.axisLetter];\n          var prevDate = previous.dates[\"date\" + this.axisLetter];\n\n          if (date && prevDate) {\n            var time = date.getTime();\n            var prevTime = prevDate.getTime();\n\n            if (time - prevTime > series.autoGapCount * this.baseDuration) {\n              return true;\n            }\n          }\n        }\n      }\n    }\n\n    return false;\n  };\n\n  Object.defineProperty(DateAxis.prototype, \"baseValue\", {\n    /**\r\n     * @return base value\r\n     */\n    get: function () {\n      return this.min;\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  DateAxis.prototype._saveMinMax = function (min, max) {\n    var groupInterval = this.groupInterval;\n\n    if (!groupInterval) {\n      groupInterval = this.mainBaseInterval;\n    }\n\n    var id = groupInterval.timeUnit + groupInterval.count;\n    this._intervalMin[id] = min;\n    this._intervalMax[id] = max;\n  };\n\n  return DateAxis;\n}(ValueAxis);\n\nexport { DateAxis };\n/**\r\n * Register class in system, so that it can be instantiated using its name from\r\n * anywhere.\r\n *\r\n * @ignore\r\n */\n\nregistry.registeredClasses[\"DateAxis\"] = DateAxis;\nregistry.registeredClasses[\"DateAxisDataItem\"] = DateAxisDataItem;","map":{"version":3,"names":["__assign","__extends","ValueAxis","ValueAxisDataItem","List","Dictionary","DateAxisBreak","registry","$time","$type","$iter","$math","$array","$object","$utils","OrderedListTemplate","DateAxisDataItem","_super","_this","call","className","applyTheme","values","date","endDate","Object","defineProperty","prototype","get","dates","set","setDate","value","getTime","enumerable","configurable","endValue","DateAxis","_gapBreaks","gridIntervals","groupIntervals","dateFormats","periodChangeDateFormats","_baseIntervalReal","timeUnit","count","_prevSeriesTime","_minDifference","_firstWeekDay","groupMin","groupMax","_intervalMax","_intervalMin","setPropertyValue","snapTooltip","tooltipPosition","groupCount","events","on","getDFFormatter","pushAll","axisFieldName","fillRule","dataItem","axis","component","gridInterval","_gridInterval","gridDuration","getDuration","Math","round","min","axisFill","__disabled","applyInternalDefaults","hasKey","setKey","language","translate","createDataItem","createAxisBreak","validateDataItems","start","end","baseDuration","periodCount","max","getFirstWeekDay","mainBaseDuration","mainBaseInterval","maxZoomFactor","_deltaMinMax","newPeriodCount","zoom","handleSelectionExtremesChange","getIntervalMax","interval","getIntervalMin","calculateZoom","difference","adjustDifference","_minZoomed","_maxZoomed","dataSetChanged","groupData","hasValue","selectionMin","selectionMax","diff","modifiedDifference","startLocation","endLocation","groupInterval","chooseInterval","_groupInterval","newId","_currentDataSetId","dispatch","series","each","baseAxis","setDataSet","_gridCount","baseInterval","_nextGridUnit","getNextUnit","_intervalDuration","_gridDate","Date","minZoomed","_df","utc","timezoneMinutes","timezone","iterator","field_1","getAxisField","undefined","minZoomedStr","toString","startDataItem","dataItemsByAxis","getKey","uid","currentDataSetId","startIndex","findFirst","index","dataItems","findClosestIndex","x","maxZoomed","add","maxZoomedStr","endDataItem","endIndex","length","outOfRange","dataRangeInvalid","validateDataRange","time","key","previousDataItem","getIndex","previousDate","validateData","isNumber","minDifference","Number","MAX_VALUE","seriesDataChangeUpdate","postProcessSeriesDataItems","seriesGroupUpdate","addEmptyUnitsBreaks","JSON","stringify","_baseInterval","mainDataSet","postProcessSeriesDataItem","groupSeriesData","dataGrouped","bulletsContainer","removeChildren","intervals_1","mainIntervalDuration_1","intervalDuration","push","_dataSets","dispose","clear","axisLetter","dataSetId","dataSet","template","clone","dataSets","previousTime","NEGATIVE_INFINITY","i","newDataItem","dataFields","dfkey","df","dfk","indexOf","roundedDate","getDate","firstDayOfWeek","currentTime","_adapterO","vkey","apply","dataField","workingValue","create","dataContext","setWorkingLocation","locations","dateX","openDateX","dateY","openDateY","_index","dvalues","open","close","low","high","sum","average","propertyFields","fieldValue","f","properties","hasProperties","setProperty","groupDataItems","groupFieldName","groupFields","copyProperties","dateFormatter","intervalID","startDate","startTime","setCalculatedValue","skipEmptyPeriods","_axisBreaks","axisBreak","_loop_1","this_1","startTimeStr","hasData","contains","axisBreaks","fixAxisBreaks","breakGridCount","ceil","endPosition","startPosition","adjustedEndValue","adjustedStartValue","gridDate","getGridDate","intervalCount","realIntervalCount","prevTimestamp","newDate","copy","timestamp","isInBreak","durationBreaksRemoved","countBreaksRemoved","getBreaklessDate","validateAxisElements","prevGridDate","dataItemsIterator_1","_dataItemsIterator","resetIterators","_loop_2","this_2","format","markUnitChange","checkChange","text","find","appendDataItem","validateDataElement","renderer_1","renderer","breakSize","timeUnit_1","intervalCount_1","getDistance","startPoint","endPoint","minGridDistance","timestamp_1","prevGridDate_1","_loop_3","text_1","moveValue","adjustedMax","itemIndex","_axisItemCount","endTimestamp","position","valueToPosition","fillEndPosition","isRange","tick","disabled","updateTickElement","grid","updateGridElement","fill","updateFillElement","mask","bullet","updateBullet","label","location_1","location","updateLabelElement","adjustMinMax","step","fixMin","endTime","fixMax","duration","gridCount","intervals","lastIndex","formatLabel","dateToPosition","anyToPosition","dateToPoint","point","positionToPoint","angle","positionToAngle","y","anyToPoint","valueToPoint","positionToDate","positionToValue","getPositionX","stackKey","range","getTimeByLocation","baseValue","fitToRange","getPositionY","stack","getValue","getAngle","workingLocations","processSeriesDataItem","timezoneOffset","setTime","getTimezoneOffset","setValue","setTimezone","openDate","prevSeriesTime","openTime","abs","differece","updateAxisBySeries","_mainBaseInterval","timeInterval","invalidate","getPropertyValue","breakTemplate","startLine","endLine","fillShape","invalidateSeries","invalidateData","getTooltipText","tooltipDate","tooltipDateFormat","dateFormat","getPositionLabel","roundPosition","axisLocation","getCellStartPosition","getCellEndPosition","getSeriesDataItem","findNearest","deltaValue","nextDate","key_1","Infinity","getCurrentLabelFormat","initRenderer","ticks","labels","baseGrid","animateMinMax","animation","animate","property","from","_minAdjusted","to","_maxAdjusted","rangeChangeDuration","rangeChangeEasing","handleExtremesChange","id","_finalMin","_finalMax","zoomToDates","skipRangeEvent","instantly","adjust","parse","zoomToValues","startValue","isEnd","isStart","groupInterval_1","min_1","max_1","POSITIVE_INFINITY","seriesMin","seriesMax","ds","mindi","maxdi","xAxis","yAxis","asIs","field","copyFrom","source","showTooltipAtPosition","local","toAxisPosition","actualDate","actualTime_1","closestDate_1","closestTime_1","tooltipLocation","chart","cursor","snapToSeries","showTooltipAtDataItem","_seriesPoints","tooltipText","tooltipHTML","hideTooltip","inited","makeGap","previous","connect","autoGapCount","prevDate","prevTime","_saveMinMax","registeredClasses"],"sources":["D:/APPLICATION/UI/UPL/NEW/node_modules/@amcharts/amcharts4/.internal/charts/axes/DateAxis.js"],"sourcesContent":["/**\r\n * DateAxis module\r\n */\r\nimport { __assign, __extends } from \"tslib\";\r\n/**\r\n * ============================================================================\r\n * IMPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\r\nimport { ValueAxis, ValueAxisDataItem } from \"./ValueAxis\";\r\nimport { List } from \"../../core/utils/List\";\r\nimport { Dictionary } from \"../../core/utils/Dictionary\";\r\nimport { DateAxisBreak } from \"./DateAxisBreak\";\r\nimport { registry } from \"../../core/Registry\";\r\nimport * as $time from \"../../core/utils/Time\";\r\nimport * as $type from \"../../core/utils/Type\";\r\nimport * as $iter from \"../../core/utils/Iterator\";\r\nimport * as $math from \"../../core/utils/Math\";\r\nimport * as $array from \"../../core/utils/Array\";\r\nimport * as $object from \"../../core/utils/Object\";\r\nimport * as $utils from \"../../core/utils/Utils\";\r\nimport { OrderedListTemplate } from \"../../core/utils/SortedList\";\r\n/**\r\n * ============================================================================\r\n * DATA ITEM\r\n * ============================================================================\r\n * @hidden\r\n */\r\n/**\r\n * Defines data item for [[DateAxis]].\r\n *\r\n * @see {@link DataItem}\r\n */\r\nvar DateAxisDataItem = /** @class */ (function (_super) {\r\n    __extends(DateAxisDataItem, _super);\r\n    /**\r\n     * Constructor\r\n     */\r\n    function DateAxisDataItem() {\r\n        var _this = _super.call(this) || this;\r\n        _this.className = \"DateAxisDataItem\";\r\n        _this.applyTheme();\r\n        _this.values.date = {};\r\n        _this.values.endDate = {};\r\n        return _this;\r\n    }\r\n    Object.defineProperty(DateAxisDataItem.prototype, \"date\", {\r\n        /**\r\n         * @return Date\r\n         */\r\n        get: function () {\r\n            return this.dates[\"date\"];\r\n        },\r\n        /**\r\n         * Date position of the data item.\r\n         *\r\n         * @param date  Date\r\n         */\r\n        set: function (date) {\r\n            this.setDate(\"date\", date);\r\n            this.value = date.getTime();\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(DateAxisDataItem.prototype, \"endDate\", {\r\n        /**\r\n         * @return End date\r\n         */\r\n        get: function () {\r\n            return this.dates[\"endDate\"];\r\n        },\r\n        /**\r\n         * End date for data item.\r\n         *\r\n         * @param date End date\r\n         */\r\n        set: function (date) {\r\n            this.setDate(\"endDate\", date);\r\n            this.endValue = date.getTime();\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    return DateAxisDataItem;\r\n}(ValueAxisDataItem));\r\nexport { DateAxisDataItem };\r\n/**\r\n * ============================================================================\r\n * MAIN CLASS\r\n * ============================================================================\r\n * @hidden\r\n */\r\n/**\r\n * Used to create a date/time-based axis for the chart.\r\n *\r\n * ```TypeScript\r\n * // Create the axis\r\n * let xAxis = chart.xAxes.push(new am4charts.DateAxis());\r\n *\r\n * // Set settings\r\n * xAxis.title.text = \"Time\";\r\n * ```\r\n * ```JavaScript\r\n * // Create the axis\r\n * var valueAxis = chart.xAxes.push(new am4charts.DateAxis());\r\n *\r\n * // Set settings\r\n * valueAxis.title.text = \"Time\";\r\n * ```\r\n * ```JSON\r\n * \"xAxes\": [{\r\n *   \"type\": \"DateAxis\",\r\n *   \"title\": {\r\n *     \"text\": \"Time\"\r\n *   }\r\n * }]\r\n * ```\r\n *\r\n * @see {@link IDateAxisEvents} for a list of available Events\r\n * @see {@link IDateAxisAdapters} for a list of available Adapters\r\n * @see {@link https://www.amcharts.com/docs/v4/concepts/axes/date-axis/} got `DateAxis` documention\r\n * @important\r\n */\r\nvar DateAxis = /** @class */ (function (_super) {\r\n    __extends(DateAxis, _super);\r\n    /**\r\n     * Constructor\r\n     */\r\n    function DateAxis() {\r\n        var _this = \r\n        // Init\r\n        _super.call(this) || this;\r\n        _this._gapBreaks = false;\r\n        /**\r\n         * A list of date/time intervals for Date axis.\r\n         *\r\n         * This define various granularities available for the axis. For example\r\n         * if you have an axis spanning an hour, and space for 6 grid lines / labels\r\n         * the axis will choose the granularity of 10 minutes, displaying a label\r\n         * every 10 minutes.\r\n         *\r\n         * Default intervals:\r\n         *\r\n         * ```JSON\r\n         * [\r\n         *  { timeUnit: \"millisecond\", count: 1 },\r\n         *  { timeUnit: \"millisecond\", count: 5 },\r\n         *  { timeUnit: \"millisecond\", count: 10 },\r\n         *  { timeUnit: \"millisecond\", count: 50 },\r\n         *  { timeUnit: \"millisecond\", count: 100 },\r\n         *  { timeUnit: \"millisecond\", count: 500 },\r\n         *  { timeUnit: \"second\", count: 1 },\r\n         *  { timeUnit: \"second\", count: 5 },\r\n         *  { timeUnit: \"second\", count: 10 },\r\n         *  { timeUnit: \"second\", count: 30 },\r\n         *  { timeUnit: \"minute\", count: 1 },\r\n         *  { timeUnit: \"minute\", count: 5 },\r\n         *  { timeUnit: \"minute\", count: 10 },\r\n         *  { timeUnit: \"minute\", count: 30 },\r\n         *  { timeUnit: \"hour\", count: 1 },\r\n         *  { timeUnit: \"hour\", count: 3 },\r\n         *  { timeUnit: \"hour\", count: 6 },\r\n         *  { timeUnit: \"hour\", count: 12 },\r\n         *  { timeUnit: \"day\", count: 1 },\r\n         *  { timeUnit: \"day\", count: 2 },\r\n         *  { timeUnit: \"day\", count: 3 },\r\n         *  { timeUnit: \"day\", count: 4 },\r\n         *  { timeUnit: \"day\", count: 5 },\r\n         *  { timeUnit: \"week\", count: 1 },\r\n         *  { timeUnit: \"month\", count: 1 },\r\n         *  { timeUnit: \"month\", count: 2 },\r\n         *  { timeUnit: \"month\", count: 3 },\r\n         *  { timeUnit: \"month\", count: 6 },\r\n         *  { timeUnit: \"year\", count: 1 },\r\n         *  { timeUnit: \"year\", count: 2 },\r\n         *  { timeUnit: \"year\", count: 5 },\r\n         *  { timeUnit: \"year\", count: 10 },\r\n         *  { timeUnit: \"year\", count: 50 },\r\n         *  { timeUnit: \"year\", count: 100 }\r\n         * ]\r\n         * ```\r\n         */\r\n        _this.gridIntervals = new List();\r\n        /**\r\n         * If data aggregation is enabled by setting Axis' `groupData = true`, the\r\n         * chart will try to aggregate data items into grouped data items.\r\n         *\r\n         * If there are more data items in selected period than `groupCount`, it will\r\n         * group data items into bigger period.\r\n         *\r\n         * For example seconds might be grouped into 10-second aggregate data items.\r\n         *\r\n         * This setting indicates what group intervals can the chart group to.\r\n         *\r\n         * Default intervals:\r\n         *\r\n         * ```JSON\r\n         * [\r\n         *   { timeUnit: \"millisecond\", count: 1},\r\n         *   { timeUnit: \"millisecond\", count: 10 },\r\n         *   { timeUnit: \"millisecond\", count: 100 },\r\n         *   { timeUnit: \"second\", count: 1 },\r\n         *   { timeUnit: \"second\", count: 10 },\r\n         *   { timeUnit: \"minute\", count: 1 },\r\n         *   { timeUnit: \"minute\", count: 10 },\r\n         *   { timeUnit: \"hour\", count: 1 },\r\n         *   { timeUnit: \"day\", count: 1 },\r\n         *   { timeUnit: \"week\", count: 1 },\r\n         *   { timeUnit: \"month\", count: 1 },\r\n         *   { timeUnit: \"year\", count: 1 }\r\n         * ]\r\n         * ```\r\n         * `groupData = true` does not work in combination with `skipEmptyPeriods = true`.\r\n         *\r\n         * @since 4.7.0\r\n         * @see {@link https://www.amcharts.com/docs/v4/concepts/axes/date-axis/#Dynamic_data_item_grouping} for more information about dynamic data item grouping.\r\n         */\r\n        _this.groupIntervals = new List();\r\n        /**\r\n         * A collection of date formats to use when formatting different time units\r\n         * on Date/time axis.\r\n         *\r\n         * Actual defaults will depend on the language locale set for the chart.\r\n         *\r\n         * To override format for a specific time unit, say days, you need to set\r\n         * the appropriate key to a format string. E.g.:\r\n         *\r\n         * ```TypeScript\r\n         * axis.dateFormats.setKey(\"day\", \"MMMM d, yyyy\");\r\n         * ```\r\n         * ```JavaScript\r\n         * axis.dateFormats.setKey(\"day\", \"MMMM d, yyyy\");\r\n         * ```\r\n         * ```JSON\r\n         * \"xAxes\": [{\r\n         *   \"type\": \"DateAxis\",\r\n         *   \"dateFormats\": {\r\n         *     \"day\": \"MMMM d, yyyy\"\r\n         *   }\r\n         * }]\r\n         * ```\r\n         *\r\n         * @see {@link DateFormatter}\r\n         */\r\n        _this.dateFormats = new Dictionary();\r\n        /**\r\n         * These formats are applied to labels that are first in a larger unit.\r\n         *\r\n         * For example, if we have a DateAxis with days on it, the first day of month\r\n         * indicates a break in month - a start of the bigger period.\r\n         *\r\n         * For those labels, `periodChangeDateFormats` are applied instead of\r\n         * `dateFormats`.\r\n         *\r\n         * This allows us implement convenient structures, like instead of:\r\n         *\r\n         * `Jan 1 - Jan 2 - Jan 3 - ...`\r\n         *\r\n         * We can have:\r\n         *\r\n         * `Jan - 1 - 2 - 3 - ...`\r\n         *\r\n         * This can be disabled by setting `markUnitChange = false`.\r\n         */\r\n        _this.periodChangeDateFormats = new Dictionary();\r\n        /**\r\n         * Actual interval (granularity) derived from the actual data.\r\n         */\r\n        _this._baseIntervalReal = { timeUnit: \"day\", count: 1 };\r\n        /**\r\n         */\r\n        _this._prevSeriesTime = {};\r\n        /**\r\n         * [_minDifference description]\r\n         *\r\n         * @todo Description\r\n         */\r\n        _this._minDifference = {};\r\n        /**\r\n         * @ignore\r\n         */\r\n        _this._firstWeekDay = 1;\r\n        /**\r\n         * A collection of start timestamps to use as axis' min timestamp for\r\n         * particular data item item periods.\r\n         *\r\n         * @since 4.7.0\r\n         * @readonly\r\n         */\r\n        _this.groupMin = {};\r\n        /**\r\n         * A collection of start timestamps to use as axis' max timestamp for\r\n         * particular data item item periods.\r\n         *\r\n         * @since 4.7.0\r\n         * @readonly\r\n         */\r\n        _this.groupMax = {};\r\n        _this._intervalMax = {};\r\n        _this._intervalMin = {};\r\n        _this.className = \"DateAxis\";\r\n        _this.setPropertyValue(\"markUnitChange\", true);\r\n        _this.snapTooltip = true;\r\n        _this.tooltipPosition = \"pointer\";\r\n        _this.setPropertyValue(\"groupData\", false);\r\n        _this.groupCount = 200;\r\n        _this.events.on(\"parentset\", _this.getDFFormatter, _this, false);\r\n        // Translatable defaults are applied in `applyInternalDefaults()`\r\n        // ...\r\n        // Define default intervals\r\n        _this.gridIntervals.pushAll([\r\n            { timeUnit: \"millisecond\", count: 1 },\r\n            { timeUnit: \"millisecond\", count: 5 },\r\n            { timeUnit: \"millisecond\", count: 10 },\r\n            { timeUnit: \"millisecond\", count: 50 },\r\n            { timeUnit: \"millisecond\", count: 100 },\r\n            { timeUnit: \"millisecond\", count: 500 },\r\n            { timeUnit: \"second\", count: 1 },\r\n            { timeUnit: \"second\", count: 5 },\r\n            { timeUnit: \"second\", count: 10 },\r\n            { timeUnit: \"second\", count: 30 },\r\n            { timeUnit: \"minute\", count: 1 },\r\n            { timeUnit: \"minute\", count: 5 },\r\n            { timeUnit: \"minute\", count: 10 },\r\n            { timeUnit: \"minute\", count: 15 },\r\n            { timeUnit: \"minute\", count: 30 },\r\n            { timeUnit: \"hour\", count: 1 },\r\n            { timeUnit: \"hour\", count: 3 },\r\n            { timeUnit: \"hour\", count: 6 },\r\n            { timeUnit: \"hour\", count: 12 },\r\n            { timeUnit: \"day\", count: 1 },\r\n            { timeUnit: \"day\", count: 2 },\r\n            { timeUnit: \"day\", count: 3 },\r\n            { timeUnit: \"day\", count: 4 },\r\n            { timeUnit: \"day\", count: 5 },\r\n            { timeUnit: \"week\", count: 1 },\r\n            { timeUnit: \"month\", count: 1 },\r\n            { timeUnit: \"month\", count: 2 },\r\n            { timeUnit: \"month\", count: 3 },\r\n            { timeUnit: \"month\", count: 6 },\r\n            { timeUnit: \"year\", count: 1 },\r\n            { timeUnit: \"year\", count: 2 },\r\n            { timeUnit: \"year\", count: 5 },\r\n            { timeUnit: \"year\", count: 10 },\r\n            { timeUnit: \"year\", count: 50 },\r\n            { timeUnit: \"year\", count: 100 },\r\n            { timeUnit: \"year\", count: 200 },\r\n            { timeUnit: \"year\", count: 500 },\r\n            { timeUnit: \"year\", count: 1000 },\r\n            { timeUnit: \"year\", count: 2000 },\r\n            { timeUnit: \"year\", count: 5000 },\r\n            { timeUnit: \"year\", count: 10000 },\r\n            { timeUnit: \"year\", count: 100000 }\r\n        ]);\r\n        _this.groupIntervals.pushAll([\r\n            { timeUnit: \"millisecond\", count: 1 },\r\n            { timeUnit: \"millisecond\", count: 10 },\r\n            { timeUnit: \"millisecond\", count: 100 },\r\n            { timeUnit: \"second\", count: 1 },\r\n            { timeUnit: \"second\", count: 10 },\r\n            { timeUnit: \"minute\", count: 1 },\r\n            { timeUnit: \"minute\", count: 10 },\r\n            { timeUnit: \"hour\", count: 1 },\r\n            { timeUnit: \"day\", count: 1 },\r\n            { timeUnit: \"week\", count: 1 },\r\n            { timeUnit: \"month\", count: 1 },\r\n            { timeUnit: \"year\", count: 1 }\r\n        ]);\r\n        // Set field name\r\n        _this.axisFieldName = \"date\";\r\n        // Apply theme\r\n        _this.applyTheme();\r\n        return _this;\r\n    }\r\n    /**\r\n     * A function which applies fills to axis cells.\r\n     *\r\n     * Default function fills every second fill. You can set this to a function\r\n     * that follows some other logic.\r\n     *\r\n     * Function should accept a [[DateAxisDataItem]] and modify its `axisFill`\r\n     * property accordingly.\r\n     */\r\n    DateAxis.prototype.fillRule = function (dataItem) {\r\n        var value = dataItem.value;\r\n        var axis = dataItem.component;\r\n        var gridInterval = axis._gridInterval;\r\n        var gridDuration = $time.getDuration(gridInterval.timeUnit, gridInterval.count);\r\n        if (Math.round((value - axis.min) / gridDuration) / 2 == Math.round(Math.round((value - axis.min) / gridDuration) / 2)) {\r\n            dataItem.axisFill.__disabled = true;\r\n        }\r\n        else {\r\n            dataItem.axisFill.__disabled = false;\r\n        }\r\n    };\r\n    /**\r\n     * Sets defaults that instantiate some objects that rely on parent, so they\r\n     * cannot be set in constructor.\r\n     */\r\n    DateAxis.prototype.applyInternalDefaults = function () {\r\n        _super.prototype.applyInternalDefaults.call(this);\r\n        // Set default date formats\r\n        if (!this.dateFormats.hasKey(\"millisecond\")) {\r\n            this.dateFormats.setKey(\"millisecond\", this.language.translate(\"_date_millisecond\"));\r\n        }\r\n        if (!this.dateFormats.hasKey(\"second\")) {\r\n            this.dateFormats.setKey(\"second\", this.language.translate(\"_date_second\"));\r\n        }\r\n        if (!this.dateFormats.hasKey(\"minute\")) {\r\n            this.dateFormats.setKey(\"minute\", this.language.translate(\"_date_minute\"));\r\n        }\r\n        if (!this.dateFormats.hasKey(\"hour\")) {\r\n            this.dateFormats.setKey(\"hour\", this.language.translate(\"_date_hour\"));\r\n        }\r\n        if (!this.dateFormats.hasKey(\"day\")) {\r\n            this.dateFormats.setKey(\"day\", this.language.translate(\"_date_day\"));\r\n        }\r\n        if (!this.dateFormats.hasKey(\"week\")) {\r\n            this.dateFormats.setKey(\"week\", this.language.translate(\"_date_day\")); // not a mistake\r\n        }\r\n        if (!this.dateFormats.hasKey(\"month\")) {\r\n            this.dateFormats.setKey(\"month\", this.language.translate(\"_date_month\"));\r\n        }\r\n        if (!this.dateFormats.hasKey(\"year\")) {\r\n            this.dateFormats.setKey(\"year\", this.language.translate(\"_date_year\"));\r\n        }\r\n        if (!this.periodChangeDateFormats.hasKey(\"millisecond\")) {\r\n            this.periodChangeDateFormats.setKey(\"millisecond\", this.language.translate(\"_date_millisecond\"));\r\n        }\r\n        if (!this.periodChangeDateFormats.hasKey(\"second\")) {\r\n            this.periodChangeDateFormats.setKey(\"second\", this.language.translate(\"_date_second\"));\r\n        }\r\n        if (!this.periodChangeDateFormats.hasKey(\"minute\")) {\r\n            this.periodChangeDateFormats.setKey(\"minute\", this.language.translate(\"_date_minute\"));\r\n        }\r\n        if (!this.periodChangeDateFormats.hasKey(\"hour\")) {\r\n            this.periodChangeDateFormats.setKey(\"hour\", this.language.translate(\"_date_day\"));\r\n        }\r\n        if (!this.periodChangeDateFormats.hasKey(\"day\")) {\r\n            this.periodChangeDateFormats.setKey(\"day\", this.language.translate(\"_date_day\"));\r\n        }\r\n        if (!this.periodChangeDateFormats.hasKey(\"week\")) {\r\n            this.periodChangeDateFormats.setKey(\"week\", this.language.translate(\"_date_day\"));\r\n        }\r\n        if (!this.periodChangeDateFormats.hasKey(\"month\")) {\r\n            this.periodChangeDateFormats.setKey(\"month\", this.language.translate(\"_date_month\") + \" \" + this.language.translate(\"_date_year\"));\r\n        }\r\n    };\r\n    /**\r\n     * Returns a new/empty [[DataItem]] of the type appropriate for this object.\r\n     *\r\n     * @see {@link DataItem}\r\n     * @return Data Item\r\n     */\r\n    DateAxis.prototype.createDataItem = function () {\r\n        return new DateAxisDataItem();\r\n    };\r\n    /**\r\n     * Returns a new/empty [[AxisBreak]] of the appropriate type.\r\n     *\r\n     * @return Axis break\r\n     */\r\n    DateAxis.prototype.createAxisBreak = function () {\r\n        return new DateAxisBreak();\r\n    };\r\n    /**\r\n     * Validates Axis' data items.\r\n     *\r\n     * @ignore Exclude from docs\r\n     */\r\n    DateAxis.prototype.validateDataItems = function () {\r\n        // allows to keep selection of the same size\r\n        var start = this.start;\r\n        var end = this.end;\r\n        var baseDuration = this.baseDuration;\r\n        var periodCount = (this.max - this.min) / baseDuration;\r\n        this._firstWeekDay = this.getFirstWeekDay();\r\n        this.getDFFormatter();\r\n        _super.prototype.validateDataItems.call(this);\r\n        var mainBaseDuration = $time.getDuration(this.mainBaseInterval.timeUnit, this.mainBaseInterval.count);\r\n        this.maxZoomFactor = Math.max(1, (this.max - this.min) / mainBaseDuration);\r\n        this._deltaMinMax = this.baseDuration / 2;\r\n        // allows to keep selection of the same size\r\n        var newPeriodCount = (this.max - this.min) / baseDuration;\r\n        start = start + (end - start) * (1 - periodCount / newPeriodCount);\r\n        this.zoom({ start: start, end: end }, false, true); // added instantlyto solve zoomout problem when we have axes gaps. @todo: check how this affects maxZoomFactor\r\n    };\r\n    /**\r\n     * Handles process after zoom.\r\n     *\r\n     * @ignore Exclude from docs\r\n     * @todo Does nothing?\r\n     */\r\n    DateAxis.prototype.handleSelectionExtremesChange = function () {\r\n    };\r\n    /**\r\n     * @ignore\r\n     */\r\n    DateAxis.prototype.getIntervalMax = function (interval) {\r\n        return this._intervalMax[interval.timeUnit + interval.count];\r\n    };\r\n    /**\r\n     * @ignore\r\n     */\r\n    DateAxis.prototype.getIntervalMin = function (interval) {\r\n        return this._intervalMin[interval.timeUnit + interval.count];\r\n    };\r\n    /**\r\n     * Calculates all positions, related to axis as per current zoom.\r\n     *\r\n     * @ignore Exclude from docs\r\n     */\r\n    DateAxis.prototype.calculateZoom = function () {\r\n        var _this = this;\r\n        _super.prototype.calculateZoom.call(this);\r\n        var difference = this.adjustDifference(this._minZoomed, this._maxZoomed);\r\n        var dataSetChanged = false;\r\n        // if data has to be grouped, choose interval and set dataset\r\n        if (this.groupData && $type.hasValue(difference)) {\r\n            var mainBaseInterval = this.mainBaseInterval;\r\n            var min = this.getIntervalMin(mainBaseInterval);\r\n            var max = this.getIntervalMax(mainBaseInterval);\r\n            var selectionMin = min + (max - min) * this.start;\r\n            var selectionMax = min + (max - min) * this.end;\r\n            var diff = this.adjustDifference(selectionMin, selectionMax);\r\n            var modifiedDifference = diff + (this.startLocation + (1 - this.endLocation)) * this.baseDuration;\r\n            var groupInterval = void 0;\r\n            if (this.groupInterval) {\r\n                groupInterval = __assign({}, this.groupInterval);\r\n            }\r\n            else {\r\n                groupInterval = this.chooseInterval(0, modifiedDifference, this.groupCount, this.groupIntervals);\r\n                if ($time.getDuration(groupInterval.timeUnit, groupInterval.count) < $time.getDuration(mainBaseInterval.timeUnit, mainBaseInterval.count)) {\r\n                    groupInterval = __assign({}, mainBaseInterval);\r\n                }\r\n            }\r\n            this._groupInterval = groupInterval;\r\n            var newId = groupInterval.timeUnit + groupInterval.count;\r\n            if (this._currentDataSetId != newId) {\r\n                this._currentDataSetId = newId;\r\n                this.dispatch(\"groupperiodchanged\");\r\n            }\r\n            this.series.each(function (series) {\r\n                if (series.baseAxis == _this) {\r\n                    if (series.setDataSet(_this._currentDataSetId)) {\r\n                        dataSetChanged = true;\r\n                    }\r\n                }\r\n            });\r\n        }\r\n        var gridInterval = this.chooseInterval(0, difference, this._gridCount);\r\n        if ($time.getDuration(gridInterval.timeUnit, gridInterval.count) < this.baseDuration) {\r\n            gridInterval = __assign({}, this.baseInterval);\r\n        }\r\n        this._gridInterval = gridInterval;\r\n        this._nextGridUnit = $time.getNextUnit(gridInterval.timeUnit);\r\n        // the following is needed to avoid grid flickering while scrolling\r\n        this._intervalDuration = $time.getDuration(gridInterval.timeUnit, gridInterval.count);\r\n        this._gridDate = $time.round(new Date(this.minZoomed - $time.getDuration(gridInterval.timeUnit, gridInterval.count)), gridInterval.timeUnit, gridInterval.count, this._firstWeekDay, this._df.utc, new Date(this.min), this._df.timezoneMinutes, this._df.timezone);\r\n        // tell series start/end\r\n        $iter.each(this.series.iterator(), function (series) {\r\n            if (series.baseAxis == _this) {\r\n                var field_1 = series.getAxisField(_this);\r\n                var minZoomed = $time.round(new Date(_this._minZoomed + _this.baseDuration * 0.05), _this.baseInterval.timeUnit, _this.baseInterval.count, _this._firstWeekDay, _this._df.utc, undefined, _this._df.timezoneMinutes, _this._df.timezone).getTime();\r\n                var minZoomedStr = minZoomed.toString();\r\n                var startDataItem = series.dataItemsByAxis.getKey(_this.uid).getKey(minZoomedStr + series.currentDataSetId);\r\n                var startIndex = 0;\r\n                if (_this.start != 0) {\r\n                    if (startDataItem) {\r\n                        startDataItem = _this.findFirst(startDataItem, minZoomed, field_1);\r\n                        startIndex = startDataItem.index;\r\n                    }\r\n                    else {\r\n                        startIndex = series.dataItems.findClosestIndex(_this._minZoomed, function (x) { return x[field_1]; }, \"left\");\r\n                    }\r\n                }\r\n                // 1 millisecond is removed so that if only first item is selected, it would not count in the second.\r\n                var baseInterval = _this.baseInterval;\r\n                var maxZoomed = $time.add($time.round(new Date(_this._maxZoomed), baseInterval.timeUnit, baseInterval.count, _this._firstWeekDay, _this._df.utc, undefined, _this._df.timezoneMinutes, _this._df.timezone), baseInterval.timeUnit, baseInterval.count, _this._df.utc).getTime();\r\n                var maxZoomedStr = maxZoomed.toString();\r\n                var endDataItem = series.dataItemsByAxis.getKey(_this.uid).getKey(maxZoomedStr + series.currentDataSetId);\r\n                var endIndex = series.dataItems.length;\r\n                if (_this.end != 1) {\r\n                    if (endDataItem) {\r\n                        endIndex = endDataItem.index;\r\n                    }\r\n                    else {\r\n                        maxZoomed -= 1;\r\n                        endIndex = series.dataItems.findClosestIndex(maxZoomed, function (x) { return x[field_1]; }, \"right\");\r\n                        // not good - if end is in the gap, indexes go like 5,4,3,4,2,1\r\n                        //if (endIndex < series.dataItems.length) {\r\n                        endIndex++;\r\n                        //}\r\n                    }\r\n                }\r\n                if (series.max(_this) < minZoomed) {\r\n                    series.startIndex = series.dataItems.length;\r\n                    series.endIndex = series.dataItems.length;\r\n                    series.outOfRange = true;\r\n                }\r\n                else if (series.min(_this) > maxZoomed) {\r\n                    series.startIndex = 0;\r\n                    series.endIndex = 0;\r\n                    series.outOfRange = true;\r\n                }\r\n                else {\r\n                    series.outOfRange = false;\r\n                    series.startIndex = startIndex;\r\n                    series.endIndex = endIndex;\r\n                }\r\n                //\tconsole.log(series.name, startIndex, endIndex);\r\n                if (!dataSetChanged && series.dataRangeInvalid) {\r\n                    series.validateDataRange();\r\n                }\r\n            }\r\n        });\r\n    };\r\n    DateAxis.prototype.findFirst = function (dataItem, time, key) {\r\n        var index = dataItem.index;\r\n        if (index > 0) {\r\n            var series = dataItem.component;\r\n            var previousDataItem = series.dataItems.getIndex(index - 1);\r\n            var previousDate = previousDataItem[key];\r\n            if (!previousDate || previousDate.getTime() < time) {\r\n                return dataItem;\r\n            }\r\n            else {\r\n                return this.findFirst(previousDataItem, time, key);\r\n            }\r\n        }\r\n        else {\r\n            return dataItem;\r\n        }\r\n    };\r\n    /**\r\n     * (Re)validates data.\r\n     *\r\n     * @ignore Exclude from docs\r\n     */\r\n    DateAxis.prototype.validateData = function () {\r\n        _super.prototype.validateData.call(this);\r\n        if (!$type.isNumber(this.baseInterval.count)) {\r\n            this.baseInterval.count = 1;\r\n        }\r\n    };\r\n    Object.defineProperty(DateAxis.prototype, \"minDifference\", {\r\n        /**\r\n         * @ignore\r\n         */\r\n        get: function () {\r\n            var _this = this;\r\n            var minDifference = Number.MAX_VALUE;\r\n            this.series.each(function (series) {\r\n                if (minDifference > _this._minDifference[series.uid]) {\r\n                    minDifference = _this._minDifference[series.uid];\r\n                }\r\n            });\r\n            if (minDifference == Number.MAX_VALUE || minDifference == 0) {\r\n                minDifference = $time.getDuration(\"day\");\r\n            }\r\n            return minDifference;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    /**\r\n     * [dataChangeUpdate description]\r\n     *\r\n     *\r\n     * @ignore Exclude from docs\r\n     * @todo Description\r\n     */\r\n    DateAxis.prototype.seriesDataChangeUpdate = function (series) {\r\n        this._minDifference[series.uid] = Number.MAX_VALUE;\r\n    };\r\n    /**\r\n     * [postProcessSeriesDataItems description]\r\n     *\r\n     * @ignore Exclude from docs\r\n     * @todo Description\r\n     */\r\n    DateAxis.prototype.postProcessSeriesDataItems = function (series) {\r\n        var _this = this;\r\n        this._firstWeekDay = this.getFirstWeekDay();\r\n        if (series) {\r\n            this.seriesGroupUpdate(series);\r\n        }\r\n        else {\r\n            this.series.each(function (series) {\r\n                _this.seriesGroupUpdate(series);\r\n            });\r\n        }\r\n        this.addEmptyUnitsBreaks();\r\n    };\r\n    DateAxis.prototype.seriesGroupUpdate = function (series) {\r\n        var _this = this;\r\n        if (JSON.stringify(series._baseInterval[this.uid]) != JSON.stringify(this.mainBaseInterval)) {\r\n            series._baseInterval[this.uid] = this.mainBaseInterval;\r\n            series.mainDataSet.each(function (dataItem) {\r\n                _this.postProcessSeriesDataItem(dataItem);\r\n            });\r\n            if (this.groupData) {\r\n                this.groupSeriesData(series);\r\n            }\r\n        }\r\n    };\r\n    /**\r\n     * Calculates series group data.\r\n     *\r\n     * @param  series  Series\r\n     * @ignore\r\n     */\r\n    DateAxis.prototype.groupSeriesData = function (series) {\r\n        var _this = this;\r\n        if (series.baseAxis == this && series.dataItems.length > 0 && !series.dataGrouped) {\r\n            series.bulletsContainer.removeChildren();\r\n            // make array of intervals which will be used;\r\n            var intervals_1 = [];\r\n            var mainBaseInterval = this.mainBaseInterval;\r\n            var mainIntervalDuration_1 = $time.getDuration(mainBaseInterval.timeUnit, mainBaseInterval.count);\r\n            this.groupIntervals.each(function (interval) {\r\n                var intervalDuration = $time.getDuration(interval.timeUnit, interval.count);\r\n                if ((intervalDuration > mainIntervalDuration_1 && intervalDuration < (_this.max - _this.min)) || _this.groupInterval) {\r\n                    intervals_1.push(interval);\r\n                }\r\n            });\r\n            if (series._dataSets) {\r\n                series._dataSets.each(function (key, dataItems) {\r\n                    dataItems.each(function (dataItem) {\r\n                        dataItem.dispose();\r\n                    });\r\n                    dataItems.clear();\r\n                });\r\n                series._dataSets.clear();\r\n            }\r\n            series.dataGrouped = true;\r\n            $array.each(intervals_1, function (interval) {\r\n                //let mainBaseInterval = this._mainBaseInterval;\r\n                var key = \"date\" + _this.axisLetter;\r\n                // create data set\r\n                var dataSetId = interval.timeUnit + interval.count;\r\n                // todo: check where this clone goes\r\n                var dataSet = new OrderedListTemplate(series.mainDataSet.template.clone());\r\n                series.dataSets.setKey(dataSetId, dataSet);\r\n                var dataItems = series.mainDataSet;\r\n                var previousTime = Number.NEGATIVE_INFINITY;\r\n                var i = 0;\r\n                var newDataItem;\r\n                var dataFields = [];\r\n                $object.each(series.dataFields, function (dfkey, df) {\r\n                    var dfk = dfkey;\r\n                    if (dfk != key && dfk.indexOf(\"Show\") == -1) {\r\n                        dataFields.push(dfk);\r\n                    }\r\n                });\r\n                var roundedDate;\r\n                dataItems.each(function (dataItem) {\r\n                    var date = dataItem.getDate(key);\r\n                    if (date) {\r\n                        var time = date.getTime();\r\n                        roundedDate = $time.round(new Date(time), interval.timeUnit, interval.count, _this._df.firstDayOfWeek, _this._df.utc, undefined, _this._df.timezoneMinutes, _this._df.timezone);\r\n                        var currentTime = roundedDate.getTime();\r\n                        // changed period\t\t\t\t\t\t\t\t\r\n                        if (previousTime < currentTime) {\r\n                            if (newDataItem && series._adapterO) {\r\n                                $array.each(dataFields, function (vkey) {\r\n                                    newDataItem.values[vkey].value = series._adapterO.apply(\"groupDataItem\", {\r\n                                        dataItem: newDataItem,\r\n                                        interval: interval,\r\n                                        dataField: vkey,\r\n                                        date: roundedDate,\r\n                                        value: newDataItem.values[vkey].value\r\n                                    }).value;\r\n                                    newDataItem.values[vkey].workingValue = newDataItem.values[vkey].value;\r\n                                });\r\n                            }\r\n                            newDataItem = dataSet.create();\r\n                            newDataItem.dataContext = {};\r\n                            newDataItem.setWorkingLocation(\"dateX\", series.dataItems.template.locations.dateX, 0);\r\n                            newDataItem.setWorkingLocation(\"openDateX\", series.dataItems.template.locations.openDateX, 0);\r\n                            newDataItem.setWorkingLocation(\"dateY\", series.dataItems.template.locations.dateY, 0);\r\n                            newDataItem.setWorkingLocation(\"openDateY\", series.dataItems.template.locations.openDateY, 0);\r\n                            newDataItem.component = series;\r\n                            // other Dates?\r\n                            newDataItem.setDate(key, roundedDate);\r\n                            newDataItem._index = i;\r\n                            i++;\r\n                            $array.each(dataFields, function (vkey) {\r\n                                //let groupFieldName = vkey + \"Group\";\r\n                                var dvalues = dataItem.values[vkey];\r\n                                if (dvalues) {\r\n                                    var value = dvalues.value;\r\n                                    if (series._adapterO) {\r\n                                        value = series._adapterO.apply(\"groupValue\", {\r\n                                            dataItem: dataItem,\r\n                                            interval: interval,\r\n                                            dataField: vkey,\r\n                                            date: roundedDate,\r\n                                            value: value\r\n                                        }).value;\r\n                                    }\r\n                                    var values = newDataItem.values[vkey];\r\n                                    if ($type.isNumber(value)) {\r\n                                        values.value = value;\r\n                                        values.workingValue = value;\r\n                                        values.open = value;\r\n                                        values.close = value;\r\n                                        values.low = value;\r\n                                        values.high = value;\r\n                                        values.sum = value;\r\n                                        values.average = value;\r\n                                        values.count = 1;\r\n                                    }\r\n                                    else {\r\n                                        values.count = 0;\r\n                                    }\r\n                                }\r\n                            });\r\n                            _this.postProcessSeriesDataItem(newDataItem, interval);\r\n                            $object.each(series.propertyFields, function (key, fieldValue) {\r\n                                var f = key;\r\n                                var value = dataItem.properties[key];\r\n                                if ($type.hasValue(value)) {\r\n                                    newDataItem.hasProperties = true;\r\n                                    newDataItem.setProperty(f, value);\r\n                                }\r\n                            });\r\n                            newDataItem.groupDataItems = [dataItem];\r\n                            previousTime = currentTime;\r\n                        }\r\n                        else {\r\n                            if (newDataItem) {\r\n                                $array.each(dataFields, function (vkey) {\r\n                                    var groupFieldName = series.groupFields[vkey];\r\n                                    var dvalues = dataItem.values[vkey];\r\n                                    if (dvalues) {\r\n                                        var value = dvalues.value;\r\n                                        if (series._adapterO) {\r\n                                            value = series._adapterO.apply(\"groupValue\", {\r\n                                                dataItem: dataItem,\r\n                                                interval: interval,\r\n                                                dataField: vkey,\r\n                                                date: roundedDate,\r\n                                                value: value\r\n                                            }).value;\r\n                                        }\r\n                                        if ($type.isNumber(value)) {\r\n                                            var values = newDataItem.values[vkey];\r\n                                            if (!$type.isNumber(values.open)) {\r\n                                                values.open = value;\r\n                                            }\r\n                                            values.close = value;\r\n                                            if (values.low > value || !$type.isNumber(values.low)) {\r\n                                                values.low = value;\r\n                                            }\r\n                                            if (values.high < value || !$type.isNumber(values.high)) {\r\n                                                values.high = value;\r\n                                            }\r\n                                            if ($type.isNumber(values.sum)) {\r\n                                                values.sum += value;\r\n                                            }\r\n                                            else {\r\n                                                values.sum = value;\r\n                                            }\r\n                                            values.count++;\r\n                                            values.average = values.sum / values.count;\r\n                                            if ($type.isNumber(values[groupFieldName])) {\r\n                                                values.value = values[groupFieldName];\r\n                                                values.workingValue = values.value;\r\n                                            }\r\n                                        }\r\n                                    }\r\n                                });\r\n                                $utils.copyProperties(dataItem.properties, newDataItem.properties);\r\n                                $object.each(series.propertyFields, function (key, fieldValue) {\r\n                                    var f = key;\r\n                                    var value = dataItem.properties[key];\r\n                                    if ($type.hasValue(value)) {\r\n                                        newDataItem.hasProperties = true;\r\n                                        newDataItem.setProperty(f, value);\r\n                                    }\r\n                                });\r\n                                newDataItem.groupDataItems.push(dataItem);\r\n                            }\r\n                        }\r\n                    }\r\n                    if (newDataItem) {\r\n                        $utils.copyProperties(dataItem.dataContext, newDataItem.dataContext);\r\n                    }\r\n                });\r\n                if (newDataItem && series._adapterO) {\r\n                    $array.each(dataFields, function (vkey) {\r\n                        newDataItem.values[vkey].value = series._adapterO.apply(\"groupDataItem\", {\r\n                            dataItem: newDataItem,\r\n                            interval: interval,\r\n                            dataField: vkey,\r\n                            date: roundedDate,\r\n                            value: newDataItem.values[vkey].value\r\n                        }).value;\r\n                        newDataItem.values[vkey].workingValue = newDataItem.values[vkey].value;\r\n                    });\r\n                }\r\n            });\r\n            this.calculateZoom();\r\n        }\r\n    };\r\n    /**\r\n     * @ignore\r\n     */\r\n    DateAxis.prototype.getDFFormatter = function () {\r\n        this._df = this.dateFormatter;\r\n    };\r\n    /**\r\n     * [postProcessSeriesDataItem description]\r\n     *\r\n     * @ignore Exclude from docs\r\n     * @todo Description\r\n     * @param dataItem Data item\r\n     */\r\n    DateAxis.prototype.postProcessSeriesDataItem = function (dataItem, interval) {\r\n        var _this = this;\r\n        // we need to do this for all series data items not only added recently, as baseInterval might change\r\n        var intervalID = \"\";\r\n        if (interval) {\r\n            intervalID = interval.timeUnit + interval.count;\r\n        }\r\n        else {\r\n            interval = this.mainBaseInterval;\r\n        }\r\n        var series = dataItem.component;\r\n        var dataItemsByAxis = series.dataItemsByAxis.getKey(this.uid);\r\n        $object.each(dataItem.dates, function (key) {\r\n            var date = dataItem.getDate(key);\r\n            var time = date.getTime();\r\n            var startDate = $time.round(new Date(time), interval.timeUnit, interval.count, _this._firstWeekDay, _this._df.utc, undefined, _this._df.timezoneMinutes, _this._df.timezone);\r\n            var startTime = startDate.getTime();\r\n            var endDate = $time.add(new Date(startTime), interval.timeUnit, interval.count, _this._df.utc);\r\n            dataItem.setCalculatedValue(key, startTime, \"open\");\r\n            dataItem.setCalculatedValue(key, endDate.getTime(), \"close\");\r\n            dataItemsByAxis.setKey(startTime + intervalID, dataItem);\r\n        });\r\n    };\r\n    /**\r\n     * Collapses empty stretches of date/time scale by creating [[AxisBreak]]\r\n     * elements for them.\r\n     *\r\n     * Can be used to automatically remove strethes without data, like weekends.\r\n     *\r\n     * No, need to call this manually. It will automatically be done if\r\n     * `skipEmptyPeriods = true`.\r\n     *\r\n     * @ignore Exclude from docs\r\n     */\r\n    DateAxis.prototype.addEmptyUnitsBreaks = function () {\r\n        var _this = this;\r\n        if (this.skipEmptyPeriods && $type.isNumber(this.min) && $type.isNumber(this.max)) {\r\n            var timeUnit = this.baseInterval.timeUnit;\r\n            var count = this.baseInterval.count;\r\n            if (this._axisBreaks) {\r\n                this._axisBreaks.clear(); // TODO: what about breaks added by user?\r\n            }\r\n            var date = $time.round(new Date(this.min), timeUnit, count, this._firstWeekDay, this._df.utc, undefined, this._df.timezoneMinutes, this._df.timezone);\r\n            var axisBreak = void 0;\r\n            var _loop_1 = function () {\r\n                $time.add(date, timeUnit, count, this_1._df.utc);\r\n                var startTime = date.getTime();\r\n                var startTimeStr = startTime.toString();\r\n                var hasData = $iter.contains(this_1.series.iterator(), function (series) {\r\n                    return !!series.dataItemsByAxis.getKey(_this.uid).getKey(startTimeStr + series.currentDataSetId);\r\n                });\r\n                // open break if not yet opened\r\n                if (!hasData) {\r\n                    if (!axisBreak) {\r\n                        axisBreak = this_1.axisBreaks.create();\r\n                        axisBreak.startDate = new Date(startTime);\r\n                        this_1._gapBreaks = true;\r\n                    }\r\n                }\r\n                else {\r\n                    // close if already opened\r\n                    if (axisBreak) {\r\n                        // close at end time minus one millisecond\r\n                        axisBreak.endDate = new Date(startTime - 1);\r\n                        axisBreak = undefined;\r\n                    }\r\n                }\r\n            };\r\n            var this_1 = this;\r\n            while (date.getTime() < this.max - this.baseDuration) {\r\n                _loop_1();\r\n            }\r\n        }\r\n    };\r\n    /**\r\n     * Updates positioning of Axis breaks after something changes.\r\n     *\r\n     * @ignore Exclude from docs\r\n     */\r\n    DateAxis.prototype.fixAxisBreaks = function () {\r\n        var _this = this;\r\n        _super.prototype.fixAxisBreaks.call(this);\r\n        var axisBreaks = this._axisBreaks;\r\n        if (axisBreaks) {\r\n            if (axisBreaks.length > 0) {\r\n                // process breaks\r\n                axisBreaks.each(function (axisBreak) {\r\n                    var breakGridCount = Math.ceil(_this._gridCount * (Math.min(_this.end, axisBreak.endPosition) - Math.max(_this.start, axisBreak.startPosition)) / (_this.end - _this.start));\r\n                    axisBreak.gridInterval = _this.chooseInterval(0, axisBreak.adjustedEndValue - axisBreak.adjustedStartValue, breakGridCount);\r\n                    var gridDate = $time.round(new Date(axisBreak.adjustedStartValue), axisBreak.gridInterval.timeUnit, axisBreak.gridInterval.count, _this._firstWeekDay, _this._df.utc, undefined, _this._df.timezoneMinutes, _this._df.timezone);\r\n                    if (gridDate.getTime() > axisBreak.startDate.getTime()) {\r\n                        $time.add(gridDate, axisBreak.gridInterval.timeUnit, axisBreak.gridInterval.count, _this._df.utc);\r\n                    }\r\n                    axisBreak.gridDate = gridDate;\r\n                });\r\n            }\r\n        }\r\n    };\r\n    /**\r\n     * @ignore\r\n     */\r\n    DateAxis.prototype.getFirstWeekDay = function () {\r\n        if (this._df) {\r\n            return this._df.firstDayOfWeek;\r\n        }\r\n        return 1;\r\n    };\r\n    /**\r\n     * [getGridDate description]\r\n     *\r\n     * @ignore Exclude from docs\r\n     * @todo Description\r\n     * @param date           [description]\r\n     * @param intervalCount  [description]\r\n     * @return [description]\r\n     */\r\n    DateAxis.prototype.getGridDate = function (date, intervalCount) {\r\n        var timeUnit = this._gridInterval.timeUnit;\r\n        var realIntervalCount = this._gridInterval.count;\r\n        // round date\r\n        $time.round(date, timeUnit, 1, this._firstWeekDay, this._df.utc, undefined, this._df.timezoneMinutes, this._df.timezone);\r\n        var prevTimestamp = date.getTime();\r\n        var newDate = $time.copy(date);\r\n        // modify date by adding intervalcount\r\n        var timestamp = $time.add(newDate, timeUnit, intervalCount, this._df.utc).getTime();\r\n        // if it's axis break, get first rounded date which is not in a break\r\n        var axisBreak = this.isInBreak(timestamp);\r\n        if (axisBreak && axisBreak.endDate) {\r\n            newDate = new Date(axisBreak.endDate.getTime());\r\n            $time.round(newDate, timeUnit, realIntervalCount, this._firstWeekDay, this._df.utc, undefined, this._df.timezoneMinutes, this._df.timezone);\r\n            if (newDate.getTime() < axisBreak.endDate.getTime()) {\r\n                $time.add(newDate, timeUnit, realIntervalCount, this._df.utc);\r\n            }\r\n            timestamp = newDate.getTime();\r\n        }\r\n        // get duration between grid lines with break duration removed\r\n        var durationBreaksRemoved = this.adjustDifference(prevTimestamp, timestamp);\r\n        // calculate how many time units fit to this duration\r\n        var countBreaksRemoved = Math.round(durationBreaksRemoved / $time.getDuration(timeUnit));\r\n        // if less units fit, add one and repeat\r\n        if (countBreaksRemoved < realIntervalCount) {\r\n            return this.getGridDate(date, intervalCount + realIntervalCount);\r\n        }\r\n        return newDate;\r\n    };\r\n    /**\r\n     * [getBreaklessDate description]\r\n     *\r\n     * @ignore Exclude from docs\r\n     * @todo Description\r\n     * @param axisBreak  [description]\r\n     * @param timeUnit   [description]\r\n     * @param count      [description]\r\n     * @return [description]\r\n     */\r\n    DateAxis.prototype.getBreaklessDate = function (axisBreak, timeUnit, count) {\r\n        var date = new Date(axisBreak.endValue);\r\n        $time.round(date, timeUnit, count, this._firstWeekDay, this._df.utc, undefined, this._df.timezoneMinutes, this._df.timezone);\r\n        $time.add(date, timeUnit, count, this._df.utc);\r\n        var timestamp = date.getTime();\r\n        axisBreak = this.isInBreak(timestamp);\r\n        if (axisBreak) {\r\n            return this.getBreaklessDate(axisBreak, timeUnit, count);\r\n        }\r\n        return date;\r\n    };\r\n    /**\r\n     * (Re)validates all Axis elements.\r\n     *\r\n     * @ignore Exclude from docs\r\n     * @todo Description (review)\r\n     */\r\n    DateAxis.prototype.validateAxisElements = function () {\r\n        var _this = this;\r\n        if ($type.isNumber(this.max) && $type.isNumber(this.min)) {\r\n            this.calculateZoom();\r\n            // first regular items\r\n            var timestamp = this._gridDate.getTime();\r\n            var timeUnit = this._gridInterval.timeUnit;\r\n            var intervalCount = this._gridInterval.count;\r\n            var prevGridDate = $time.copy(this._gridDate);\r\n            var dataItemsIterator_1 = this._dataItemsIterator;\r\n            this.resetIterators();\r\n            var _loop_2 = function () {\r\n                var date = this_2.getGridDate($time.copy(prevGridDate), intervalCount);\r\n                timestamp = date.getTime();\r\n                var endDate = $time.copy(date); // you might think it's easier to add intervalduration to timestamp, however it won't work for months or years which are not of the same length\r\n                endDate = $time.add(endDate, timeUnit, intervalCount, this_2._df.utc);\r\n                var format = this_2.dateFormats.getKey(timeUnit);\r\n                if (this_2.markUnitChange && prevGridDate) {\r\n                    if ($time.checkChange(date, prevGridDate, this_2._nextGridUnit, this_2._df.utc)) {\r\n                        if (timeUnit !== \"year\") {\r\n                            format = this_2.periodChangeDateFormats.getKey(timeUnit);\r\n                        }\r\n                    }\r\n                }\r\n                var text = this_2._df.format(date, format);\r\n                var dataItem = dataItemsIterator_1.find(function (x) { return x.text === text; });\r\n                if (dataItem.__disabled) {\r\n                    dataItem.__disabled = false;\r\n                }\r\n                this_2.appendDataItem(dataItem);\r\n                dataItem.axisBreak = undefined;\r\n                dataItem.date = date;\r\n                dataItem.endDate = endDate;\r\n                dataItem.text = text;\r\n                this_2.validateDataElement(dataItem);\r\n                prevGridDate = date;\r\n            };\r\n            var this_2 = this;\r\n            while (timestamp <= this._maxZoomed) {\r\n                _loop_2();\r\n            }\r\n            // breaks later\r\n            var renderer_1 = this.renderer;\r\n            if (this._axisBreaks) {\r\n                $iter.each(this._axisBreaks.iterator(), function (axisBreak) {\r\n                    if (axisBreak.breakSize > 0) {\r\n                        var timeUnit_1 = axisBreak.gridInterval.timeUnit;\r\n                        var intervalCount_1 = axisBreak.gridInterval.count;\r\n                        // only add grid if gap is bigger then minGridDistance\r\n                        if ($math.getDistance(axisBreak.startPoint, axisBreak.endPoint) > renderer_1.minGridDistance * 4) {\r\n                            var timestamp_1 = axisBreak.gridDate.getTime();\r\n                            var prevGridDate_1;\r\n                            var count = 0;\r\n                            var _loop_3 = function () {\r\n                                var date = $time.copy(axisBreak.gridDate);\r\n                                timestamp_1 = $time.add(date, timeUnit_1, intervalCount_1 * count, _this._df.utc).getTime();\r\n                                count++;\r\n                                if (timestamp_1 > axisBreak.adjustedStartValue && timestamp_1 < axisBreak.adjustedEndValue) {\r\n                                    var endDate = $time.copy(date); // you might think it's easier to add intervalduration to timestamp, however it won't work for months or years which are not of the same length\r\n                                    endDate = $time.add(endDate, timeUnit_1, intervalCount_1, _this._df.utc);\r\n                                    var format = _this.dateFormats.getKey(timeUnit_1);\r\n                                    if (_this.markUnitChange && prevGridDate_1) {\r\n                                        if ($time.checkChange(date, prevGridDate_1, _this._nextGridUnit, _this._df.utc)) {\r\n                                            if (timeUnit_1 !== \"year\") {\r\n                                                format = _this.periodChangeDateFormats.getKey(timeUnit_1);\r\n                                            }\r\n                                        }\r\n                                    }\r\n                                    var text_1 = _this._df.format(date, format);\r\n                                    var dataItem = dataItemsIterator_1.find(function (x) { return x.text === text_1; });\r\n                                    if (dataItem.__disabled) {\r\n                                        dataItem.__disabled = false;\r\n                                    }\r\n                                    //this.processDataItem(dataItem);\r\n                                    _this.appendDataItem(dataItem);\r\n                                    dataItem.axisBreak = axisBreak;\r\n                                    axisBreak.dataItems.moveValue(dataItem);\r\n                                    dataItem.date = date;\r\n                                    dataItem.endDate = endDate;\r\n                                    dataItem.text = text_1;\r\n                                    prevGridDate_1 = date;\r\n                                    _this.validateDataElement(dataItem);\r\n                                }\r\n                            };\r\n                            while (timestamp_1 <= axisBreak.adjustedMax) {\r\n                                _loop_3();\r\n                            }\r\n                        }\r\n                    }\r\n                });\r\n            }\r\n        }\r\n    };\r\n    /**\r\n     * Validates Axis data item.\r\n     *\r\n     * @ignore Exclude from docs\r\n     * @param dataItem Data item\r\n     */\r\n    DateAxis.prototype.validateDataElement = function (dataItem) {\r\n        dataItem.itemIndex = this._axisItemCount;\r\n        this._axisItemCount++;\r\n        if ($type.isNumber(this.max) && $type.isNumber(this.min)) {\r\n            var renderer = this.renderer;\r\n            var timestamp = dataItem.value;\r\n            var endTimestamp = dataItem.endValue;\r\n            if (!$type.isNumber(endTimestamp)) {\r\n                endTimestamp = timestamp;\r\n            }\r\n            var position = this.valueToPosition(timestamp);\r\n            var endPosition = this.valueToPosition(endTimestamp);\r\n            var fillEndPosition = endPosition;\r\n            if (!dataItem.isRange && this._gridInterval.count > this.baseInterval.count) {\r\n                endPosition = position + (endPosition - position) / (this._gridInterval.count / this.baseInterval.count);\r\n            }\r\n            dataItem.position = position;\r\n            var tick = dataItem.tick;\r\n            if (tick && !tick.disabled) {\r\n                renderer.updateTickElement(tick, position, endPosition);\r\n            }\r\n            var grid = dataItem.grid;\r\n            if (grid && !grid.disabled) {\r\n                renderer.updateGridElement(grid, position, endPosition);\r\n            }\r\n            var fill = dataItem.axisFill;\r\n            if (fill && !fill.disabled) {\r\n                renderer.updateFillElement(fill, position, fillEndPosition);\r\n                if (!dataItem.isRange) {\r\n                    this.fillRule(dataItem);\r\n                }\r\n            }\r\n            var mask = dataItem.mask;\r\n            if (mask) {\r\n                renderer.updateFillElement(mask, position, endPosition);\r\n            }\r\n            if (dataItem.bullet) {\r\n                renderer.updateBullet(dataItem.bullet, position, endPosition);\r\n            }\r\n            var label = dataItem.label;\r\n            if (label && !label.disabled) {\r\n                var location_1 = label.location;\r\n                if (location_1 == 0) {\r\n                    if (this._gridInterval.count == 1 && this._gridInterval.timeUnit != \"week\" && !dataItem.isRange) {\r\n                        location_1 = 0.5;\r\n                    }\r\n                    else {\r\n                        location_1 = 0;\r\n                    }\r\n                }\r\n                renderer.updateLabelElement(label, position, endPosition, location_1);\r\n            }\r\n        }\r\n    };\r\n    Object.defineProperty(DateAxis.prototype, \"baseDuration\", {\r\n        /**\r\n         * A duration in milliseconds of the `baseInterval`.\r\n         *\r\n         * @return Duration (ms)\r\n         */\r\n        get: function () {\r\n            return $time.getDuration(this.baseInterval.timeUnit, this.baseInterval.count);\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    /**\r\n     * Adjusts min/max values.\r\n     *\r\n     * @ignore Exclude from docs.\r\n     * @todo Description (review)\r\n     * @param min  Min timestamp\r\n     * @param max  Max timestamp\r\n     * @return Adjusted min/max step\r\n     */\r\n    DateAxis.prototype.adjustMinMax = function (min, max) {\r\n        return { min: min, max: max, step: this.baseDuration };\r\n    };\r\n    /**\r\n     * Adjusts the minimum timestamp as per cell start location.\r\n     *\r\n     * @param value  Value\r\n     * @return Adjusted value\r\n     */\r\n    DateAxis.prototype.fixMin = function (value) {\r\n        // like this because months are not equal\r\n        var interval = this.baseInterval;\r\n        var startTime = $time.round(new Date(value), interval.timeUnit, interval.count, this._firstWeekDay, this._df.utc, undefined, this._df.timezoneMinutes, this._df.timezone).getTime();\r\n        var endTime = $time.add(new Date(startTime), interval.timeUnit, interval.count, this._df.utc).getTime();\r\n        return startTime + (endTime - startTime) * this.startLocation;\r\n    };\r\n    /**\r\n     * Adjusts the maximum timestamp as per cell start location.\r\n     *\r\n     * @param value  Value\r\n     * @return Adjusted value\r\n     */\r\n    DateAxis.prototype.fixMax = function (value) {\r\n        // like this because months are not equal\r\n        var interval = this.baseInterval;\r\n        var startTime = $time.round(new Date(value), interval.timeUnit, interval.count, this._firstWeekDay, this._df.utc, undefined, this._df.timezoneMinutes, this._df.timezone).getTime();\r\n        var endTime = $time.add(new Date(startTime), interval.timeUnit, interval.count, this._df.utc).getTime();\r\n        return startTime + (endTime - startTime) * this.endLocation;\r\n    };\r\n    /**\r\n     * [chooseInterval description]\r\n     *\r\n     * @ignore Exclude from docs.\r\n     * @todo Description\r\n     * @param index      [description]\r\n     * @param duration   [description]\r\n     * @param gridCount  [description]\r\n     * @return [description]\r\n     */\r\n    DateAxis.prototype.chooseInterval = function (index, duration, gridCount, intervals) {\r\n        if (!intervals) {\r\n            intervals = this.gridIntervals;\r\n        }\r\n        var gridInterval = intervals.getIndex(index);\r\n        var intervalDuration = $time.getDuration(gridInterval.timeUnit, gridInterval.count);\r\n        var lastIndex = intervals.length - 1;\r\n        if (index >= lastIndex) {\r\n            return __assign({}, intervals.getIndex(lastIndex));\r\n        }\r\n        var count = Math.ceil(duration / intervalDuration);\r\n        if (duration < intervalDuration && index > 0) {\r\n            return __assign({}, intervals.getIndex(index - 1));\r\n        }\r\n        if (count <= gridCount) {\r\n            return __assign({}, intervals.getIndex(index));\r\n        }\r\n        else {\r\n            if (index + 1 < intervals.length) {\r\n                return this.chooseInterval(index + 1, duration, gridCount, intervals);\r\n            }\r\n            else {\r\n                return __assign({}, intervals.getIndex(index));\r\n            }\r\n        }\r\n    };\r\n    /**\r\n     * Formats the value according to axis' own [[DateFormatter]].\r\n     *\r\n     * @param value  Source value\r\n     * @return Formatted value\r\n     */\r\n    DateAxis.prototype.formatLabel = function (value) {\r\n        return this._df.format(value);\r\n    };\r\n    /**\r\n     * Converts a Date to an asbolute pixel position within Axis.\r\n     *\r\n     * @param date  Date\r\n     * @return Position (px)\r\n     */\r\n    DateAxis.prototype.dateToPosition = function (date) {\r\n        return this.valueToPosition(date.getTime());\r\n    };\r\n    /**\r\n     * Converts a numeric timestamp or a `Date` to a relative position on axis.\r\n     *\r\n     * @param date  Date or a timestamp\r\n     * @return Relative position\r\n     */\r\n    DateAxis.prototype.anyToPosition = function (date) {\r\n        if (date instanceof Date) {\r\n            return this.dateToPosition(date);\r\n        }\r\n        else {\r\n            return this.valueToPosition(date);\r\n        }\r\n    };\r\n    /**\r\n     * Converts date to orientation point (x, y, angle) on axis\r\n     *\r\n     * @param date Date\r\n     * @return IOrientationPoint\r\n     */\r\n    DateAxis.prototype.dateToPoint = function (date) {\r\n        var position = this.dateToPosition(date);\r\n        var point = this.renderer.positionToPoint(position);\r\n        var angle = this.renderer.positionToAngle(position);\r\n        return { x: point.x, y: point.y, angle: angle };\r\n    };\r\n    /**\r\n     * Converts a numeric value to orientation (x, y, angle) point on axis\r\n     *\r\n     * @param value  Value\r\n     * @return Orientation point\r\n     */\r\n    DateAxis.prototype.anyToPoint = function (date) {\r\n        if (date instanceof Date) {\r\n            return this.dateToPoint(date);\r\n        }\r\n        else {\r\n            return this.valueToPoint(date);\r\n        }\r\n    };\r\n    /**\r\n     * Converts pixel position within Axis to a corresponding Date.\r\n     *\r\n     * @param position  Position (px)\r\n     * @return Date\r\n     */\r\n    DateAxis.prototype.positionToDate = function (position) {\r\n        return new Date(this.positionToValue(position));\r\n    };\r\n    /**\r\n     * Returns the relative position on axis for series' data item's value.\r\n     *\r\n     * @since 4.5.14\r\n     * @param  dataItem  Data item\r\n     * @param  key       Data field to get value from\r\n     * @param  location  Location (0-1)\r\n     * @return           Relative position\r\n     */\r\n    DateAxis.prototype.getPositionX = function (dataItem, key, location, stackKey, range) {\r\n        var value = this.getTimeByLocation(dataItem, key, location);\r\n        //let stack: number = dataItem.getValue(\"valueX\", \"stack\");\r\n        if (!$type.isNumber(value)) {\r\n            value = this.baseValue;\r\n        }\r\n        var position = this.valueToPosition(value);\r\n        if (range) {\r\n            position = $math.fitToRange(position, range.start, range.end);\r\n        }\r\n        return position;\r\n    };\r\n    /**\r\n     * Returns relative position on axis for series' data item's value.\r\n     *\r\n     * @since 4.5.14\r\n     * @param  dataItem  Data item\r\n     * @param  key       Data field to get value from\r\n     * @param  location  Location (0-1)\r\n     * @return           Relative position\r\n     */\r\n    DateAxis.prototype.getPositionY = function (dataItem, key, location, stackKey, range) {\r\n        var value = this.getTimeByLocation(dataItem, key, location);\r\n        var stack = dataItem.getValue(\"valueX\", \"stack\");\r\n        if (!$type.isNumber(value)) {\r\n            value = this.baseValue;\r\n        }\r\n        var position = this.valueToPosition(value + stack);\r\n        if (range) {\r\n            position = $math.fitToRange(position, range.start, range.end);\r\n        }\r\n        return position;\r\n    };\r\n    /**\r\n     * Returns an angle for series data item.\r\n     *\r\n     * @ignore Exclude from docs\r\n     * @todo Description (review)\r\n     * @param dataItem  Data item\r\n     * @param key       Data field to get value from\r\n     * @param location  Location (0-1)\r\n     * @param stackKey  Stack ID\r\n     * @param range Range to fit in\r\n     * @return Angle\r\n     */\r\n    DateAxis.prototype.getAngle = function (dataItem, key, location, stackKey, range) {\r\n        var value = this.getTimeByLocation(dataItem, key, location);\r\n        var stack = dataItem.getValue(stackKey, \"stack\");\r\n        if (!$type.isNumber(value)) {\r\n            value = this.baseValue;\r\n        }\r\n        var position = this.valueToPosition(value + stack);\r\n        if (range) {\r\n            position = $math.fitToRange(position, range.start, range.end);\r\n        }\r\n        return this.positionToAngle(position);\r\n    };\r\n    /**\r\n     * [getTimeByLocation description]\r\n     *\r\n     * @ignore Exclude from docs\r\n     * @todo Description\r\n     * @param dataItem  [description]\r\n     * @param key       [description]\r\n     * @param location  [description]\r\n     * @return [description]\r\n     */\r\n    DateAxis.prototype.getTimeByLocation = function (dataItem, key, location) {\r\n        if (!$type.hasValue(key)) {\r\n            return;\r\n        }\r\n        if (!$type.isNumber(location)) {\r\n            location = dataItem.workingLocations[key];\r\n            if (!$type.isNumber(location)) {\r\n                location = 0;\r\n            }\r\n        }\r\n        var startTime = dataItem.values[key][\"open\"];\r\n        var endTime = dataItem.values[key][\"close\"];\r\n        var workingValue = dataItem.values[key].workingValue;\r\n        var value = dataItem.values[key].value;\r\n        var difference = value - workingValue;\r\n        startTime -= difference;\r\n        endTime -= difference;\r\n        if ($type.isNumber(startTime) && $type.isNumber(endTime)) {\r\n            return startTime + (endTime - startTime) * location;\r\n        }\r\n    };\r\n    /**\r\n     * Processes a related series' data item.\r\n     *\r\n     * @ignore Exclude from docs\r\n     * @todo Description\r\n     * @param dataItem  Data item\r\n     */\r\n    DateAxis.prototype.processSeriesDataItem = function (dataItem, axisLetter) {\r\n        var series = dataItem.component;\r\n        var time;\r\n        var date = dataItem[\"date\" + axisLetter];\r\n        if ($type.isNumber(this.timezoneOffset)) {\r\n            date.setTime(date.getTime() + (date.getTimezoneOffset() - this.timezoneOffset) * 60000);\r\n            dataItem.setValue(\"date\" + axisLetter, date.getTime(), 0);\r\n        }\r\n        else if ($type.hasValue(this.timezone)) {\r\n            date = $time.setTimezone(date, this.timezone);\r\n            dataItem.setValue(\"date\" + axisLetter, date.getTime(), 0);\r\n            dataItem[\"date\" + axisLetter] = date;\r\n        }\r\n        if (date) {\r\n            time = date.getTime();\r\n        }\r\n        else {\r\n            return;\r\n        }\r\n        var openDate = dataItem[\"openDate\" + axisLetter];\r\n        var prevSeriesTime = this._prevSeriesTime[series.uid];\r\n        var openTime;\r\n        if (openDate) {\r\n            openTime = openDate.getTime();\r\n        }\r\n        if ($type.isNumber(openTime)) {\r\n            var difference = Math.abs(time - openTime);\r\n            if (this._minDifference[series.uid] > difference) {\r\n                this._minDifference[series.uid] = difference;\r\n            }\r\n        }\r\n        var differece = time - prevSeriesTime;\r\n        if (differece > 0) {\r\n            if (this._minDifference[series.uid] > differece) {\r\n                this._minDifference[series.uid] = differece;\r\n            }\r\n        }\r\n        this._prevSeriesTime[series.uid] = time;\r\n        if (series._baseInterval[this.uid]) {\r\n            this.postProcessSeriesDataItem(dataItem);\r\n        }\r\n    };\r\n    /**\r\n     * [updateAxisBySeries description]\r\n     *\r\n     * @ignore Exclude from docs\r\n     * @todo Description\r\n     */\r\n    DateAxis.prototype.updateAxisBySeries = function () {\r\n        _super.prototype.updateAxisBySeries.call(this);\r\n        var baseInterval = this.chooseInterval(0, this.minDifference, 1);\r\n        if (this.minDifference >= $time.getDuration(\"day\", 27) && baseInterval.timeUnit == \"week\") {\r\n            baseInterval.timeUnit = \"month\";\r\n            baseInterval.count = 1;\r\n        }\r\n        if (baseInterval.timeUnit == \"month\") {\r\n            if (this.minDifference >= $time.getDuration(\"day\", 29 * 2) && baseInterval.count == 1) {\r\n                baseInterval.count = 2;\r\n            }\r\n            if (this.minDifference >= $time.getDuration(\"day\", 29 * 3) && baseInterval.count == 2) {\r\n                baseInterval.count = 3;\r\n            }\r\n            if (this.minDifference >= $time.getDuration(\"day\", 29 * 6) && baseInterval.count == 5) {\r\n                baseInterval.count = 6;\r\n            }\r\n        }\r\n        // handle daylight saving\r\n        if (this.minDifference >= $time.getDuration(\"hour\", 23) && baseInterval.timeUnit == \"hour\") {\r\n            baseInterval.timeUnit = \"day\";\r\n            baseInterval.count = 1;\r\n        }\r\n        if (this.minDifference >= $time.getDuration(\"week\", 1) - $time.getDuration(\"hour\", 1) && baseInterval.timeUnit == \"day\") {\r\n            baseInterval.timeUnit = \"week\";\r\n            baseInterval.count = 1;\r\n        }\r\n        if (this.minDifference >= $time.getDuration(\"year\", 1) - $time.getDuration(\"day\", 1.01) && baseInterval.timeUnit == \"month\") {\r\n            baseInterval.timeUnit = \"year\";\r\n            baseInterval.count = 1;\r\n        }\r\n        this._baseIntervalReal = baseInterval;\r\n        this._mainBaseInterval = baseInterval;\r\n        // no need to invalidate\r\n    };\r\n    Object.defineProperty(DateAxis.prototype, \"baseInterval\", {\r\n        /**\r\n         * @return Base interval\r\n         */\r\n        get: function () {\r\n            if (this._groupInterval) {\r\n                return this._groupInterval;\r\n            }\r\n            else if (this._baseInterval) {\r\n                return this._baseInterval;\r\n            }\r\n            else {\r\n                return this._baseIntervalReal;\r\n            }\r\n        },\r\n        /**\r\n         * A base interval (granularity) of data.\r\n         *\r\n         * Used to indicate what are the base units of your data.\r\n         *\r\n         * For example, if you have a data set that has a data point every 5 minutes,\r\n         * you may want to set this to `{ timeUnit: \"minute\", count: 5 }`.\r\n         *\r\n         * If not set, the Axis will try to determine the setting by its own, looking\r\n         * at actual data.\r\n         *\r\n         * For best results, try to follow these values for `count`:\r\n         *\r\n         * When unit is \"month\", use 12 / count = round number\r\n         * When unit is \"hour\", use 24 / count = round number\r\n         * When unit is \"second\" and \"minute\", use 60 / count = round number\r\n         *\r\n         * @param timeInterval base interval\r\n         */\r\n        set: function (timeInterval) {\r\n            if (JSON.stringify(this._baseInterval) != JSON.stringify(timeInterval)) {\r\n                this._baseInterval = timeInterval;\r\n                this._mainBaseInterval = timeInterval;\r\n                if (!$type.isNumber(timeInterval.count)) {\r\n                    timeInterval.count = 1;\r\n                }\r\n                this.invalidate();\r\n                this.postProcessSeriesDataItems();\r\n            }\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(DateAxis.prototype, \"mainBaseInterval\", {\r\n        /**\r\n         * Indicates granularity of the data of source (unaggregated) data.\r\n         *\r\n         * @since 4.7.0\r\n         * @return Granularity of the main data set\r\n         */\r\n        get: function () {\r\n            if (this._baseInterval) {\r\n                return this._baseInterval;\r\n            }\r\n            else if (this._mainBaseInterval) {\r\n                return this._mainBaseInterval;\r\n            }\r\n            else {\r\n                return this._baseIntervalReal;\r\n            }\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(DateAxis.prototype, \"skipEmptyPeriods\", {\r\n        /**\r\n         * @return Remove empty stretches of time?\r\n         */\r\n        get: function () {\r\n            return this.getPropertyValue(\"skipEmptyPeriods\");\r\n        },\r\n        /**\r\n         * If enabled, axis will automatically collapse empty (without data points)\r\n         * periods of time, i.e. weekends.\r\n         *\r\n         * An \"empty\" period is considered a stretch of time in the length of current\r\n         * `baseInterval` without a single data point in it.\r\n         *\r\n         * For each such empty period, axis will automatically create an\r\n         * [[AxisBreak]]. By default they will be invisible. You can still configure\r\n         * them by accessing `axis.breaks.template`.\r\n         *\r\n         * [More info about breaks](https://www.amcharts.com/docs/v4/concepts/axes/#Breaks).\r\n         *\r\n         * Important notes:\r\n         * * If you set this property to `true`, you can not add your custom axis breaks to this axis anymore.\r\n         * * Using this feature affects performance. Use only if you need it.\r\n         * * Setting this to `true` will reset appearance of breaks. If you want to modify appearance, do it *after* you set `skipEmptyPeriods`.\r\n         * * Some axis label overlapping might happen.\r\n         * * This setting is not compatible with `groupData = true`.\r\n         *\r\n         * @default false\r\n         * @param value  Remove empty stretches of time?\r\n         */\r\n        set: function (value) {\r\n            if (value) {\r\n                var breakTemplate = this.axisBreaks.template;\r\n                breakTemplate.startLine.disabled = true;\r\n                breakTemplate.endLine.disabled = true;\r\n                breakTemplate.fillShape.disabled = true;\r\n                breakTemplate.breakSize = 0;\r\n            }\r\n            else {\r\n                if (this._gapBreaks) {\r\n                    this.axisBreaks.clear();\r\n                    this._gapBreaks = false;\r\n                }\r\n            }\r\n            if (this.setPropertyValue(\"skipEmptyPeriods\", value)) {\r\n                this.invalidate();\r\n                this.postProcessSeriesDataItems();\r\n                this.invalidateSeries();\r\n            }\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(DateAxis.prototype, \"tooltipDateFormat\", {\r\n        /**\r\n         * @return Date format\r\n         */\r\n        get: function () {\r\n            return this.getPropertyValue(\"tooltipDateFormat\");\r\n        },\r\n        /**\r\n         * A special date format to apply axis tooltips.\r\n         *\r\n         * Will use same format as for labels, if not set.\r\n         *\r\n         * @param value  Date format\r\n         */\r\n        set: function (value) {\r\n            this.setPropertyValue(\"tooltipDateFormat\", value);\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(DateAxis.prototype, \"markUnitChange\", {\r\n        /**\r\n         * @return Use different format for period beginning?\r\n         */\r\n        get: function () {\r\n            return this.getPropertyValue(\"markUnitChange\");\r\n        },\r\n        /**\r\n         * Use `periodChangeDateFormats` to apply different formats to the first\r\n         * label in bigger time unit.\r\n         *\r\n         * @default true\r\n         * @param value  Use different format for period beginning?\r\n         */\r\n        set: function (value) {\r\n            if (this.setPropertyValue(\"markUnitChange\", value)) {\r\n                this.invalidateData();\r\n            }\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    /**\r\n     * Returns text to show in a tooltip, based on specific relative position\r\n     * within axis.\r\n     *\r\n     * The label will be formatted as per [[DateFormatter]] set for the whole\r\n     * chart, or explicitly for this Axis.\r\n     *\r\n     * @ignore Exclude from docs\r\n     * @param position  Position\r\n     * @return Label (formatted date)\r\n     */\r\n    DateAxis.prototype.getTooltipText = function (position) {\r\n        var text;\r\n        var date = this.positionToDate(position);\r\n        date = $time.round(date, this.baseInterval.timeUnit, this.baseInterval.count, this._firstWeekDay, this._df.utc, new Date(this.min), this._df.timezoneMinutes, this._df.timezone);\r\n        this.tooltipDate = date;\r\n        if ($type.hasValue(this.tooltipDateFormat)) {\r\n            text = this._df.format(date, this.tooltipDateFormat, [\"day\", \"month\", \"week\", \"year\"].indexOf(this.baseInterval.timeUnit) == -1);\r\n        }\r\n        else {\r\n            var dateFormat = this.dateFormats.getKey(this.baseInterval.timeUnit);\r\n            if (dateFormat) {\r\n                text = this._df.format(date, dateFormat);\r\n            }\r\n            else {\r\n                text = this.getPositionLabel(position);\r\n            }\r\n        }\r\n        if (!this._adapterO) {\r\n            return text;\r\n        }\r\n        else {\r\n            return this._adapterO.apply(\"getTooltipText\", text);\r\n        }\r\n    };\r\n    /**\r\n     * Takes an absolute position within axis and adjust it to a specific position within base interval. (cell)\r\n     *\r\n     * @ignore Exclude from docs\r\n     * @param position Source position\r\n     * @param location  Location in the cell\r\n     * @return Adjusted position\r\n     */\r\n    DateAxis.prototype.roundPosition = function (position, location, axisLocation) {\r\n        var baseInterval = this.baseInterval;\r\n        var timeUnit = baseInterval.timeUnit;\r\n        var count = baseInterval.count;\r\n        var date = this.positionToDate(position);\r\n        $time.round(date, timeUnit, count, this._firstWeekDay, this._df.utc, undefined, this._df.timezoneMinutes, this._df.timezone);\r\n        if (location > 0) {\r\n            $time.add(date, timeUnit, location * count, this._df.utc);\r\n        }\r\n        if (axisLocation > 0 && axisLocation < 1) {\r\n            date.setTime(date.getTime() + this.baseDuration * axisLocation);\r\n        }\r\n        if (this.isInBreak(date.getTime())) {\r\n            while (date.getTime() < this.max) {\r\n                $time.add(date, timeUnit, count, this._df.utc);\r\n                if (!this.isInBreak(date.getTime())) {\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        return this.dateToPosition(date);\r\n    };\r\n    /**\r\n     * Returns an relative position of the start of the cell (period), that specific position value falls into.\r\n     *\r\n     * @ignore Exclude from docs\r\n     * @todo Description (review)\r\n     * @param position  Relative position\r\n     * @return Cell start relative position\r\n     */\r\n    DateAxis.prototype.getCellStartPosition = function (position) {\r\n        return this.roundPosition(position, 0);\r\n    };\r\n    /**\r\n     * Returns an relative position of the end of the cell (period), that specific position value falls into.\r\n     *\r\n     * @ignore Exclude from docs\r\n     * @todo Description (review)\r\n     * @param position  Relative position\r\n     * @return Cell end relative position\r\n     */\r\n    DateAxis.prototype.getCellEndPosition = function (position) {\r\n        return this.roundPosition(position, 1);\r\n        //return this.dateToPosition($time.add(this.positionToDate(this.roundPosition(position, 1)), this.baseInterval.timeUnit, this.baseInterval.count));\r\n    };\r\n    /**\r\n     * Returns a Series data item that corresponds to the specific pixel position\r\n     * of the Axis.\r\n     *\r\n     * If `findNearest` (third parameter) is set to `true`, the method will try\r\n     * to locate nearest available data item if none is found directly under\r\n     * `position`.\r\n     *\r\n     * @param series       Series\r\n     * @param position     Position (px)\r\n     * @param findNearest  Should axis try to find nearest tooltip if there is no data item at exact position\r\n     * @return Data item\r\n     */\r\n    DateAxis.prototype.getSeriesDataItem = function (series, position, findNearest) {\r\n        var value = this.positionToValue(position);\r\n        var location = 0.5;\r\n        if (this.axisLetter == \"Y\") {\r\n            location = series.dataItems.template.locations.dateY;\r\n        }\r\n        else {\r\n            location = series.dataItems.template.locations.dateX;\r\n        }\r\n        var deltaValue = value - location * this.baseDuration;\r\n        var date = $time.round(new Date(value), this.baseInterval.timeUnit, this.baseInterval.count, this._firstWeekDay, this._df.utc, undefined, this._df.timezoneMinutes, this._df.timezone);\r\n        var nextDate = $time.round(new Date(value + this.baseDuration), this.baseInterval.timeUnit, this.baseInterval.count, this._firstWeekDay, this._df.utc, undefined, this._df.timezoneMinutes, this._df.timezone);\r\n        if (nextDate.getTime() > date.getTime()) {\r\n            if (Math.abs(nextDate.getTime() - deltaValue) < Math.abs(deltaValue - date.getTime())) {\r\n                date = nextDate;\r\n            }\r\n        }\r\n        var dataItemsByAxis = series.dataItemsByAxis.getKey(this.uid);\r\n        var dataItem = dataItemsByAxis.getKey(date.getTime() + series.currentDataSetId);\r\n        // todo:  alternatively we can find closiest here\r\n        if (!dataItem && findNearest) {\r\n            var key_1;\r\n            if (this.axisLetter == \"Y\") {\r\n                key_1 = \"dateY\";\r\n            }\r\n            else {\r\n                key_1 = \"dateX\";\r\n            }\r\n            dataItem = series.dataItems.getIndex(series.dataItems.findClosestIndex(date.getTime(), function (x) {\r\n                if (x[key_1]) {\r\n                    return x[key_1].getTime();\r\n                }\r\n                else {\r\n                    return -Infinity;\r\n                }\r\n            }, \"any\"));\r\n        }\r\n        return dataItem;\r\n    };\r\n    /**\r\n     * Returns a formatted date based on position in axis scale.\r\n     *\r\n     * Please note that `position` represents position within axis which may be\r\n     * zoomed and not correspond to Cursor's `position`.\r\n     *\r\n     * To convert Cursor's `position` to Axis' `position` use `toAxisPosition()` method.\r\n     *\r\n     * @see {@link https://www.amcharts.com/docs/v4/tutorials/tracking-cursors-position-via-api/#Tracking_Cursor_s_position} For more information about cursor tracking.\r\n     * @param position  Relative position on axis (0-1)\r\n     * @return Position label\r\n     */\r\n    DateAxis.prototype.getPositionLabel = function (position) {\r\n        // @todo Better format recognition\r\n        var date = this.positionToDate(position);\r\n        return this._df.format(date, this.getCurrentLabelFormat());\r\n    };\r\n    /**\r\n     * Returns label date format based on currently used time units\r\n     *\r\n     * @return Format\r\n     */\r\n    DateAxis.prototype.getCurrentLabelFormat = function () {\r\n        return this.dateFormats.getKey(this._gridInterval ? this._gridInterval.timeUnit : \"day\");\r\n    };\r\n    /**\r\n     * Initializes an Axis renderer.\r\n     *\r\n     * @ignore Exclude from docs\r\n     */\r\n    DateAxis.prototype.initRenderer = function () {\r\n        _super.prototype.initRenderer.call(this);\r\n        var renderer = this.renderer;\r\n        if (renderer) {\r\n            // Set defaults\r\n            renderer.ticks.template.location = 0;\r\n            renderer.grid.template.location = 0;\r\n            renderer.labels.template.location = 0;\r\n            renderer.baseGrid.disabled = true;\r\n        }\r\n    };\r\n    Object.defineProperty(DateAxis.prototype, \"basePoint\", {\r\n        /**\r\n         * Coordinates of the actual axis start.\r\n         *\r\n         * @ignore Exclude from docs\r\n         * @return Base point\r\n         */\r\n        get: function () {\r\n            return { x: 0, y: 0 };\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    /**\r\n     * @ignore\r\n     */\r\n    DateAxis.prototype.animateMinMax = function (min, max) {\r\n        var _this = this;\r\n        var animation = this.animate([{ property: \"_minAdjusted\", from: this._minAdjusted, to: min }, { property: \"_maxAdjusted\", from: this._maxAdjusted, to: max }], this.rangeChangeDuration, this.rangeChangeEasing);\r\n        animation.events.on(\"animationprogress\", function () {\r\n            _this.dispatch(\"extremeschanged\");\r\n        });\r\n        return animation;\r\n    };\r\n    /**\r\n     * Invalidates axis data items when series extremes change\r\n     */\r\n    DateAxis.prototype.handleExtremesChange = function () {\r\n        _super.prototype.handleExtremesChange.call(this);\r\n        if (this.groupData) {\r\n            var id = this.baseInterval.timeUnit + this.baseInterval.count;\r\n            this.groupMin[id] = this._finalMin;\r\n            this.groupMax[id] = this._finalMax;\r\n        }\r\n    };\r\n    /**\r\n     * Zooms axis to specific Dates.\r\n     *\r\n     * @param startDate       Start date\r\n     * @param endValue        End date\r\n     * @param skipRangeEvent  Do not invoke events\r\n     * @param instantly       Do not play zoom animations\r\n     */\r\n    DateAxis.prototype.zoomToDates = function (startDate, endDate, skipRangeEvent, instantly, adjust) {\r\n        startDate = this._df.parse(startDate);\r\n        endDate = this._df.parse(endDate);\r\n        this.zoomToValues(startDate.getTime(), endDate.getTime(), skipRangeEvent, instantly, adjust);\r\n    };\r\n    /**\r\n     * Zooms axis to specific values.\r\n     *\r\n     * @param startValue      Start value\r\n     * @param endValue        End value\r\n     * @param skipRangeEvent  Do not invoke events\r\n     * @param instantly       Do not play zoom animations\r\n     */\r\n    DateAxis.prototype.zoomToValues = function (startValue, endValue, skipRangeEvent, instantly, adjust) {\r\n        var _this = this;\r\n        if (!this.groupData) {\r\n            //let start: number = (startValue - this.min) / (this.max - this.min);\r\n            //let end: number = (endValue - this.min) / (this.max - this.min);\r\n            var start = this.valueToPosition(startValue);\r\n            var end = this.valueToPosition(endValue);\r\n            this.zoom({ start: start, end: end }, skipRangeEvent, instantly);\r\n        }\r\n        else {\r\n            var difference = this.adjustDifference(startValue, endValue);\r\n            var isEnd = false;\r\n            if (endValue == this.max) {\r\n                isEnd = true;\r\n            }\r\n            var isStart = false;\r\n            if (startValue == this.min) {\r\n                isStart = true;\r\n            }\r\n            if ($type.hasValue(difference)) {\r\n                var mainBaseInterval = this.mainBaseInterval;\r\n                var groupInterval_1 = this.chooseInterval(0, difference, this.groupCount, this.groupIntervals);\r\n                if ((groupInterval_1.timeUnit == mainBaseInterval.timeUnit && groupInterval_1.count < mainBaseInterval.count) || $time.getDuration(groupInterval_1.timeUnit, 1) < $time.getDuration(mainBaseInterval.timeUnit, 1)) {\r\n                    groupInterval_1 = __assign({}, mainBaseInterval);\r\n                }\r\n                var id = groupInterval_1.timeUnit + groupInterval_1.count;\r\n                var min_1 = this.groupMin[id];\r\n                var max_1 = this.groupMax[id];\r\n                if (!$type.isNumber(min_1) || !$type.isNumber(max_1)) {\r\n                    min_1 = Number.POSITIVE_INFINITY;\r\n                    max_1 = Number.NEGATIVE_INFINITY;\r\n                    this.series.each(function (series) {\r\n                        var seriesMin = series.min(_this);\r\n                        var seriesMax = series.max(_this);\r\n                        if (series._dataSets) {\r\n                            var ds = series._dataSets.getKey(groupInterval_1.timeUnit + groupInterval_1.count);\r\n                            if (ds) {\r\n                                var mindi = ds.getIndex(0);\r\n                                var maxdi = ds.getIndex(ds.length - 1);\r\n                                if (mindi) {\r\n                                    if (series.xAxis == _this) {\r\n                                        seriesMin = mindi.dateX.getTime();\r\n                                    }\r\n                                    else if (series.yAxis == _this) {\r\n                                        seriesMin = mindi.dateY.getTime();\r\n                                    }\r\n                                }\r\n                                if (maxdi) {\r\n                                    if (series.xAxis == _this) {\r\n                                        seriesMax = maxdi.dateX.getTime();\r\n                                    }\r\n                                    else if (series.yAxis == _this) {\r\n                                        seriesMax = maxdi.dateY.getTime();\r\n                                    }\r\n                                }\r\n                            }\r\n                        }\r\n                        seriesMax = $time.round($time.add(new Date(seriesMax), groupInterval_1.timeUnit, 1, _this._df.utc), groupInterval_1.timeUnit, 1, _this._df.firstDayOfWeek, _this._df.utc, undefined, _this._df.timezoneMinutes, _this._df.timezone).getTime();\r\n                        if (seriesMin < min_1) {\r\n                            min_1 = seriesMin;\r\n                        }\r\n                        if (seriesMax > max_1) {\r\n                            max_1 = seriesMax;\r\n                        }\r\n                    });\r\n                    this.groupMin[id] = min_1;\r\n                    this.groupMax[id] = max_1;\r\n                }\r\n                startValue = $math.fitToRange(startValue, min_1, max_1);\r\n                endValue = $math.fitToRange(endValue, min_1, max_1);\r\n                if (adjust) {\r\n                    if (isEnd) {\r\n                        startValue = endValue - difference;\r\n                        startValue = $math.fitToRange(startValue, min_1, max_1);\r\n                    }\r\n                    if (isStart) {\r\n                        endValue = startValue + difference;\r\n                        endValue = $math.fitToRange(endValue, min_1, max_1);\r\n                    }\r\n                }\r\n                var start = (startValue - min_1) / (max_1 - min_1);\r\n                var end = (endValue - min_1) / (max_1 - min_1);\r\n                this.zoom({ start: start, end: end }, skipRangeEvent, instantly);\r\n            }\r\n        }\r\n    };\r\n    /**\r\n     * Adds `baseInterval` to \"as is\" fields.\r\n     *\r\n     * @param field  Field name\r\n     * @return Assign as is?\r\n     */\r\n    DateAxis.prototype.asIs = function (field) {\r\n        return field == \"baseInterval\" || _super.prototype.asIs.call(this, field);\r\n    };\r\n    /**\r\n     * Copies all properties and related data from a different instance of Axis.\r\n     *\r\n     * @param source Source Axis\r\n     */\r\n    DateAxis.prototype.copyFrom = function (source) {\r\n        var _this = this;\r\n        _super.prototype.copyFrom.call(this, source);\r\n        this.dateFormats = source.dateFormats;\r\n        this.periodChangeDateFormats = source.periodChangeDateFormats;\r\n        this.groupIntervals.clear();\r\n        source.groupIntervals.each(function (interval) {\r\n            _this.groupIntervals.push(__assign({}, interval));\r\n        });\r\n        this.gridIntervals.clear();\r\n        source.gridIntervals.each(function (interval) {\r\n            _this.gridIntervals.push(__assign({}, interval));\r\n        });\r\n        if (source._baseInterval) {\r\n            this.baseInterval = source._baseInterval;\r\n        }\r\n    };\r\n    /**\r\n     * Shows Axis tooltip at specific relative position within Axis. (0-1)\r\n     *\r\n     * @param position Position (0-1)\r\n     * @param local or global position\r\n     */\r\n    DateAxis.prototype.showTooltipAtPosition = function (position, local) {\r\n        var _this = this;\r\n        if (!local) {\r\n            position = this.toAxisPosition(position);\r\n        }\r\n        if (this.snapTooltip) {\r\n            // rounding is not good, pen/aac4e7f66f019d36b2447f050c600c13 (no last tootltip shown)\r\n            var actualDate = this.positionToDate(position); //$time.round(this.positionToDate(position), this.baseInterval.timeUnit, 1, this.getFirstWeekDay(), this.dateFormatter.utc, undefined, this._df.timezoneMinutes, this._df.timezone);\r\n            var actualTime_1 = actualDate.getTime();\r\n            var closestDate_1;\r\n            this.series.each(function (series) {\r\n                if (series.baseAxis == _this) {\r\n                    var dataItem = _this.getSeriesDataItem(series, position, true);\r\n                    if (dataItem) {\r\n                        var date = void 0;\r\n                        if (series.xAxis == _this) {\r\n                            date = dataItem.dateX;\r\n                        }\r\n                        if (series.yAxis == _this) {\r\n                            date = dataItem.dateY;\r\n                        }\r\n                        if (!closestDate_1) {\r\n                            closestDate_1 = date;\r\n                        }\r\n                        else {\r\n                            if (Math.abs(closestDate_1.getTime() - actualTime_1) > Math.abs(date.getTime() - actualTime_1)) {\r\n                                closestDate_1 = date;\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            });\r\n            if (closestDate_1) {\r\n                var closestTime_1 = closestDate_1.getTime();\r\n                closestDate_1 = $time.round(new Date(closestTime_1), this.baseInterval.timeUnit, this.baseInterval.count, this._firstWeekDay, this._df.utc, undefined, this._df.timezoneMinutes, this._df.timezone);\r\n                closestTime_1 = closestDate_1.getTime();\r\n                var tooltipLocation = this.renderer.tooltipLocation;\r\n                if (tooltipLocation == 0) {\r\n                    tooltipLocation = 0.0001;\r\n                }\r\n                closestDate_1 = new Date(closestDate_1.getTime() + this.baseDuration * tooltipLocation);\r\n                position = this.dateToPosition(closestDate_1);\r\n                if (this.chart.cursor && this.chart.cursor.snapToSeries) {\r\n                    //void\r\n                }\r\n                else {\r\n                    this.series.each(function (series) {\r\n                        var dataItem = series.dataItemsByAxis.getKey(_this.uid).getKey(closestTime_1 + series.currentDataSetId);\r\n                        var point = series.showTooltipAtDataItem(dataItem);\r\n                        if (point) {\r\n                            _this.chart._seriesPoints.push({ series: series, point: point });\r\n                        }\r\n                        else {\r\n                            // check, otherwise column tooltip will be hidden\r\n                            if (series.tooltipText || series.tooltipHTML) {\r\n                                series.hideTooltip();\r\n                            }\r\n                        }\r\n                    });\r\n                }\r\n                //this.chart.sortSeriesTooltips(seriesPoints);\r\n            }\r\n        }\r\n        _super.prototype.showTooltipAtPosition.call(this, position, true);\r\n    };\r\n    Object.defineProperty(DateAxis.prototype, \"snapTooltip\", {\r\n        /**\r\n         * @return Should snap?\r\n         */\r\n        get: function () {\r\n            return this.getPropertyValue(\"snapTooltip\");\r\n        },\r\n        /**\r\n         * Should the nearest tooltip be shown if no data item is found on the\r\n         * current cursor position.\r\n         *\r\n         * @default true\r\n         * @param value  Should snap?\r\n         */\r\n        set: function (value) {\r\n            this.setPropertyValue(\"snapTooltip\", value);\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(DateAxis.prototype, \"groupData\", {\r\n        /**\r\n         * @return Group data points?\r\n         */\r\n        get: function () {\r\n            return this.getPropertyValue(\"groupData\");\r\n        },\r\n        /**\r\n         * Indicates if data should be aggregated to composide data items if there\r\n         * are more data items in selected range than `groupCount`.\r\n         *\r\n         * Grouping will occur automatically, based on current selection range, and\r\n         * will change dynamically when user zooms in/out the chart.\r\n         *\r\n         * NOTE: This works only if [[DateAxis]] is base axis of an [[XYSeries]].\r\n         *\r\n         * The related [[XYSeries]] also needs to be set up to take advantage of, by\r\n         * setting its [`groupFields`](https://www.amcharts.com/docs/v4/reference/xyseries/#groupFields_property).\r\n         *\r\n         * The group intervals to aggregate data to is defined by `groupIntervals`\r\n         * property.\r\n         *\r\n         * ```TypeScript\r\n         * let dateAxis = chart.xAxes.push(new am4charts.DateAxis());\r\n         * dateAxis.groupData = true;\r\n         *\r\n         * let valueAxis = chart.xAxes.push(new am4charts.valueAxis());\r\n         *\r\n         * let series = chart.series.push(new am4charts.LineSeries());\r\n         * series.dataFields.dateX = \"date\";\r\n         * series.dataFields.valueY = \"value\";\r\n         * series.groupFields.valueY = \"average\";\r\n         * ```\r\n         * ```JavaScript\r\n         * var dateAxis = chart.xAxes.push(new am4charts.DateAxis());\r\n         * dateAxis.groupData = true;\r\n         *\r\n         * var valueAxis = chart.xAxes.push(new am4charts.valueAxis());\r\n         *\r\n         * var series = chart.series.push(new am4charts.LineSeries());\r\n         * series.dataFields.dateX = \"date\";\r\n         * series.dataFields.valueY = \"value\";\r\n         * series.groupFields.valueY = \"average\";\r\n         * ```\r\n         * ```JSON\r\n         * {\r\n         *   // ...\r\n         *   \"xAxes\": [{\r\n         *     \"type\": \"DateAxis\",\r\n         *     \"groupData\": true\r\n         *   }],\r\n         *   \"yAxes\": [{\r\n         *     \"type\": \"ValueAxis\"\r\n         *   }],\r\n         *   \"series\": [{\r\n         *     \"type\": \"LineSeries\",\r\n         *     \"dataFields\": {\r\n         *       \"dateX\": \"date\",\r\n         *       \"valueY\": \"value\"\r\n         *     },\r\n         *     \"groupFields\": {\r\n         *       \"valueY\": \"average\"\r\n         *     }\r\n         *   }]\r\n         * }\r\n         * ```\r\n         *\r\n         * @default false\r\n         * @see {@link https://www.amcharts.com/docs/v4/concepts/axes/date-axis/#Dynamic_data_item_grouping} for more information about dynamic data item grouping.\r\n         * @since 4.7.0\r\n         * @param  value  Group data points?\r\n         */\r\n        set: function (value) {\r\n            var _this = this;\r\n            if (this.setPropertyValue(\"groupData\", value)) {\r\n                this.series.each(function (series) {\r\n                    series.setDataSet(\"\");\r\n                    if (value && !series.dataGrouped && series.inited) {\r\n                        series._baseInterval[_this.uid] = _this.mainBaseInterval;\r\n                        _this.groupSeriesData(series);\r\n                    }\r\n                });\r\n                this._currentDataSetId = \"\";\r\n                this._groupInterval = undefined;\r\n                this.invalidate();\r\n                this.invalidateSeries();\r\n            }\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(DateAxis.prototype, \"groupInterval\", {\r\n        /**\r\n         * @return Interval\r\n         */\r\n        get: function () {\r\n            return this.getPropertyValue(\"groupInterval\");\r\n        },\r\n        /**\r\n         * Disables automatic selection of data grouping intervals and always uses\r\n         * `groupInterval` if set. Works only if `groupData = true`.\r\n         *\r\n         * @since 4.9.24\r\n         * @param  value  Interval\r\n         */\r\n        set: function (value) {\r\n            if (this.setPropertyValue(\"groupInterval\", value)) {\r\n                this.invalidate();\r\n                this.invalidateSeries();\r\n            }\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(DateAxis.prototype, \"groupCount\", {\r\n        /**\r\n         * @return Number of data items\r\n         */\r\n        get: function () {\r\n            return this.getPropertyValue(\"groupCount\");\r\n        },\r\n        /**\r\n         * Indicates threshold of data items in selected range at which to start\r\n         * aggregating data items if `groupData = true`.\r\n         *\r\n         * @default 200\r\n         * @since 4.7.0\r\n         * @param  value  Number of data items\r\n         */\r\n        set: function (value) {\r\n            this.setPropertyValue(\"groupCount\", value);\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(DateAxis.prototype, \"timezoneOffset\", {\r\n        /**\r\n         * @todo Timezone offset in minutes\r\n         */\r\n        get: function () {\r\n            return this.getPropertyValue(\"timezoneOffset\");\r\n        },\r\n        /**\r\n         * If set will recalculate all timestamps in data by applying specific offset\r\n         * in minutes.\r\n         *\r\n         * IMPORTANT: do not set `timezoneOffset` on both `DateAxis` and `dateFormatter`. It\r\n         * will skew your results by applying offset twice.\r\n         *\r\n         * @since 4.8.5\r\n         * @param  value Time zone offset in minutes\r\n         */\r\n        set: function (value) {\r\n            this.setPropertyValue(\"timezoneOffset\", value);\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(DateAxis.prototype, \"timezone\", {\r\n        /**\r\n         * @return Timezone\r\n         */\r\n        get: function () {\r\n            return this.getPropertyValue(\"timezone\");\r\n        },\r\n        /**\r\n         * If set will recalculate all timestamps in data to specific named timezone,\r\n         * e.g. `\"America/Vancouver\"`, `\"Australia/Sydney\"`, `\"UTC\"`, etc.\r\n         *\r\n         * IMPORTANT: it is no longer recommended to use this setting. Please\r\n         * set`timezone` on `dateFormatter`.\r\n         *\r\n         * @deprecated\r\n         * @since 4.10.1\r\n         * @param  value Time zone\r\n         */\r\n        set: function (value) {\r\n            this.setPropertyValue(\"timezone\", value);\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(DateAxis.prototype, \"gridInterval\", {\r\n        /**\r\n         * Current grid interval.\r\n         *\r\n         * @return Grid interval\r\n         */\r\n        get: function () {\r\n            return this._gridInterval;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    /**\r\n     * @ignore\r\n     */\r\n    DateAxis.prototype.makeGap = function (dataItem, previous) {\r\n        var series = dataItem.component;\r\n        if (dataItem && previous) {\r\n            if (!series.connect && $type.isNumber(series.autoGapCount)) {\r\n                if (series.baseAxis == this) {\r\n                    var date = dataItem.dates[\"date\" + this.axisLetter];\r\n                    var prevDate = previous.dates[\"date\" + this.axisLetter];\r\n                    if (date && prevDate) {\r\n                        var time = date.getTime();\r\n                        var prevTime = prevDate.getTime();\r\n                        if (time - prevTime > series.autoGapCount * this.baseDuration) {\r\n                            return true;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return false;\r\n    };\r\n    Object.defineProperty(DateAxis.prototype, \"baseValue\", {\r\n        /**\r\n         * @return base value\r\n         */\r\n        get: function () {\r\n            return this.min;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    DateAxis.prototype._saveMinMax = function (min, max) {\r\n        var groupInterval = this.groupInterval;\r\n        if (!groupInterval) {\r\n            groupInterval = this.mainBaseInterval;\r\n        }\r\n        var id = groupInterval.timeUnit + groupInterval.count;\r\n        this._intervalMin[id] = min;\r\n        this._intervalMax[id] = max;\r\n    };\r\n    return DateAxis;\r\n}(ValueAxis));\r\nexport { DateAxis };\r\n/**\r\n * Register class in system, so that it can be instantiated using its name from\r\n * anywhere.\r\n *\r\n * @ignore\r\n */\r\nregistry.registeredClasses[\"DateAxis\"] = DateAxis;\r\nregistry.registeredClasses[\"DateAxisDataItem\"] = DateAxisDataItem;\r\n"],"mappings":"AAAA;AACA;AACA;AACA,SAASA,QAAT,EAAmBC,SAAnB,QAAoC,OAApC;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,SAASC,SAAT,EAAoBC,iBAApB,QAA6C,aAA7C;AACA,SAASC,IAAT,QAAqB,uBAArB;AACA,SAASC,UAAT,QAA2B,6BAA3B;AACA,SAASC,aAAT,QAA8B,iBAA9B;AACA,SAASC,QAAT,QAAyB,qBAAzB;AACA,OAAO,KAAKC,KAAZ,MAAuB,uBAAvB;AACA,OAAO,KAAKC,KAAZ,MAAuB,uBAAvB;AACA,OAAO,KAAKC,KAAZ,MAAuB,2BAAvB;AACA,OAAO,KAAKC,KAAZ,MAAuB,uBAAvB;AACA,OAAO,KAAKC,MAAZ,MAAwB,wBAAxB;AACA,OAAO,KAAKC,OAAZ,MAAyB,yBAAzB;AACA,OAAO,KAAKC,MAAZ,MAAwB,wBAAxB;AACA,SAASC,mBAAT,QAAoC,6BAApC;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;;AACA,IAAIC,gBAAgB;AAAG;AAAe,UAAUC,MAAV,EAAkB;EACpDhB,SAAS,CAACe,gBAAD,EAAmBC,MAAnB,CAAT;EACA;AACJ;AACA;;;EACI,SAASD,gBAAT,GAA4B;IACxB,IAAIE,KAAK,GAAGD,MAAM,CAACE,IAAP,CAAY,IAAZ,KAAqB,IAAjC;;IACAD,KAAK,CAACE,SAAN,GAAkB,kBAAlB;;IACAF,KAAK,CAACG,UAAN;;IACAH,KAAK,CAACI,MAAN,CAAaC,IAAb,GAAoB,EAApB;IACAL,KAAK,CAACI,MAAN,CAAaE,OAAb,GAAuB,EAAvB;IACA,OAAON,KAAP;EACH;;EACDO,MAAM,CAACC,cAAP,CAAsBV,gBAAgB,CAACW,SAAvC,EAAkD,MAAlD,EAA0D;IACtD;AACR;AACA;IACQC,GAAG,EAAE,YAAY;MACb,OAAO,KAAKC,KAAL,CAAW,MAAX,CAAP;IACH,CANqD;;IAOtD;AACR;AACA;AACA;AACA;IACQC,GAAG,EAAE,UAAUP,IAAV,EAAgB;MACjB,KAAKQ,OAAL,CAAa,MAAb,EAAqBR,IAArB;MACA,KAAKS,KAAL,GAAaT,IAAI,CAACU,OAAL,EAAb;IACH,CAfqD;IAgBtDC,UAAU,EAAE,IAhB0C;IAiBtDC,YAAY,EAAE;EAjBwC,CAA1D;EAmBAV,MAAM,CAACC,cAAP,CAAsBV,gBAAgB,CAACW,SAAvC,EAAkD,SAAlD,EAA6D;IACzD;AACR;AACA;IACQC,GAAG,EAAE,YAAY;MACb,OAAO,KAAKC,KAAL,CAAW,SAAX,CAAP;IACH,CANwD;;IAOzD;AACR;AACA;AACA;AACA;IACQC,GAAG,EAAE,UAAUP,IAAV,EAAgB;MACjB,KAAKQ,OAAL,CAAa,SAAb,EAAwBR,IAAxB;MACA,KAAKa,QAAL,GAAgBb,IAAI,CAACU,OAAL,EAAhB;IACH,CAfwD;IAgBzDC,UAAU,EAAE,IAhB6C;IAiBzDC,YAAY,EAAE;EAjB2C,CAA7D;EAmBA,OAAOnB,gBAAP;AACH,CApDqC,CAoDpCb,iBApDoC,CAAtC;;AAqDA,SAASa,gBAAT;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,IAAIqB,QAAQ;AAAG;AAAe,UAAUpB,MAAV,EAAkB;EAC5ChB,SAAS,CAACoC,QAAD,EAAWpB,MAAX,CAAT;EACA;AACJ;AACA;;;EACI,SAASoB,QAAT,GAAoB;IAChB,IAAInB,KAAK,GACT;IACAD,MAAM,CAACE,IAAP,CAAY,IAAZ,KAAqB,IAFrB;;IAGAD,KAAK,CAACoB,UAAN,GAAmB,KAAnB;IACA;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;IACQpB,KAAK,CAACqB,aAAN,GAAsB,IAAInC,IAAJ,EAAtB;IACA;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;IACQc,KAAK,CAACsB,cAAN,GAAuB,IAAIpC,IAAJ,EAAvB;IACA;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;IACQc,KAAK,CAACuB,WAAN,GAAoB,IAAIpC,UAAJ,EAApB;IACA;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;IACQa,KAAK,CAACwB,uBAAN,GAAgC,IAAIrC,UAAJ,EAAhC;IACA;AACR;AACA;;IACQa,KAAK,CAACyB,iBAAN,GAA0B;MAAEC,QAAQ,EAAE,KAAZ;MAAmBC,KAAK,EAAE;IAA1B,CAA1B;IACA;AACR;;IACQ3B,KAAK,CAAC4B,eAAN,GAAwB,EAAxB;IACA;AACR;AACA;AACA;AACA;;IACQ5B,KAAK,CAAC6B,cAAN,GAAuB,EAAvB;IACA;AACR;AACA;;IACQ7B,KAAK,CAAC8B,aAAN,GAAsB,CAAtB;IACA;AACR;AACA;AACA;AACA;AACA;AACA;;IACQ9B,KAAK,CAAC+B,QAAN,GAAiB,EAAjB;IACA;AACR;AACA;AACA;AACA;AACA;AACA;;IACQ/B,KAAK,CAACgC,QAAN,GAAiB,EAAjB;IACAhC,KAAK,CAACiC,YAAN,GAAqB,EAArB;IACAjC,KAAK,CAACkC,YAAN,GAAqB,EAArB;IACAlC,KAAK,CAACE,SAAN,GAAkB,UAAlB;;IACAF,KAAK,CAACmC,gBAAN,CAAuB,gBAAvB,EAAyC,IAAzC;;IACAnC,KAAK,CAACoC,WAAN,GAAoB,IAApB;IACApC,KAAK,CAACqC,eAAN,GAAw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"},"metadata":{},"sourceType":"module"}