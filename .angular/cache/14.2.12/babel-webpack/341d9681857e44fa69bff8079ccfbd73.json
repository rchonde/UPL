{"ast":null,"code":"/**\r\n * DevExtreme (esm/ui/scheduler/appointments/settingsGenerator.js)\r\n * Version: 22.2.4\r\n * Build date: Thu Jan 19 2023\r\n *\r\n * Copyright (c) 2012 - 2023 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\nimport _extends from \"@babel/runtime/helpers/esm/extends\";\nimport dateUtils from \"../../../core/utils/date\";\nimport { isEmptyObject } from \"../../../core/utils/type\";\nimport { extend } from \"../../../core/utils/extend\";\nimport { getRecurrenceProcessor } from \"../recurrence\";\nimport timeZoneUtils from \"../utils.timeZone\";\nimport { createResourcesTree, getDataAccessors, getGroupCount, getResourceTreeLeaves } from \"../resources/utils\";\nimport { createAppointmentAdapter } from \"../appointmentAdapter\";\nimport { CellPositionCalculator } from \"./cellPositionCalculator\";\nimport { ExpressionUtils } from \"../expressionUtils\";\nimport { isDateAndTimeView } from \"../../../renovation/ui/scheduler/view_model/to_test/views/utils/base\";\nimport { createFormattedDateText } from \"./textUtils\";\nvar toMs = dateUtils.dateToMilliseconds;\nvar APPOINTMENT_DATE_TEXT_FORMAT = \"TIME\";\nexport class DateGeneratorBaseStrategy {\n  constructor(options) {\n    this.options = options;\n  }\n\n  get rawAppointment() {\n    return this.options.rawAppointment;\n  }\n\n  get timeZoneCalculator() {\n    return this.options.timeZoneCalculator;\n  }\n\n  get viewDataProvider() {\n    return this.options.viewDataProvider;\n  }\n\n  get appointmentTakesAllDay() {\n    return this.options.appointmentTakesAllDay;\n  }\n\n  get supportAllDayRow() {\n    return this.options.supportAllDayRow;\n  }\n\n  get isAllDayRowAppointment() {\n    return this.options.isAllDayRowAppointment;\n  }\n\n  get timeZone() {\n    return this.options.timeZone;\n  }\n\n  get dateRange() {\n    return this.options.dateRange;\n  }\n\n  get firstDayOfWeek() {\n    return this.options.firstDayOfWeek;\n  }\n\n  get viewStartDayHour() {\n    return this.options.viewStartDayHour;\n  }\n\n  get viewEndDayHour() {\n    return this.options.viewEndDayHour;\n  }\n\n  get endViewDate() {\n    return this.options.endViewDate;\n  }\n\n  get viewType() {\n    return this.options.viewType;\n  }\n\n  get isGroupedByDate() {\n    return this.options.isGroupedByDate;\n  }\n\n  get isVerticalOrientation() {\n    return this.options.isVerticalGroupOrientation;\n  }\n\n  get dataAccessors() {\n    return this.options.dataAccessors;\n  }\n\n  get loadedResources() {\n    return this.options.loadedResources;\n  }\n\n  get isDateAppointment() {\n    return !isDateAndTimeView(this.viewType) && this.appointmentTakesAllDay;\n  }\n\n  getIntervalDuration() {\n    return this.appointmentTakesAllDay ? this.options.allDayIntervalDuration : this.options.intervalDuration;\n  }\n\n  generate(appointmentAdapter) {\n    var itemGroupIndices = this._getGroupIndices(this.rawAppointment);\n\n    var appointmentList = this._createAppointments(appointmentAdapter, itemGroupIndices);\n\n    appointmentList = this._getProcessedByAppointmentTimeZone(appointmentList, appointmentAdapter);\n\n    if (this._canProcessNotNativeTimezoneDates(appointmentAdapter)) {\n      appointmentList = this._getProcessedNotNativeTimezoneDates(appointmentList, appointmentAdapter);\n    }\n\n    var dateSettings = this._createGridAppointmentList(appointmentList, appointmentAdapter);\n\n    var firstViewDates = this._getAppointmentsFirstViewDate(dateSettings);\n\n    this._fillNormalizedStartDate(dateSettings, firstViewDates);\n\n    dateSettings = this._cropAppointmentsByStartDayHour(dateSettings, firstViewDates, this.rawAppointment);\n    dateSettings = this._fillNormalizedEndDate(dateSettings, this.rawAppointment);\n\n    if (this._needSeparateLongParts()) {\n      dateSettings = this._separateLongParts(dateSettings, appointmentAdapter);\n    }\n\n    var {\n      isRecurrent: isRecurrent\n    } = appointmentAdapter;\n    return {\n      dateSettings: dateSettings,\n      itemGroupIndices: itemGroupIndices,\n      isRecurrent: isRecurrent\n    };\n  }\n\n  _getProcessedByAppointmentTimeZone(appointmentList, appointment) {\n    var hasAppointmentTimeZone = !isEmptyObject(appointment.startDateTimeZone) || !isEmptyObject(appointment.endDateTimeZone);\n\n    if (hasAppointmentTimeZone) {\n      var appointmentOffsets = {\n        startDate: this.timeZoneCalculator.getOffsets(appointment.startDate, appointment.startDateTimeZone),\n        endDate: this.timeZoneCalculator.getOffsets(appointment.endDate, appointment.endDateTimeZone)\n      };\n      appointmentList.forEach(a => {\n        var sourceOffsets_startDate = this.timeZoneCalculator.getOffsets(a.startDate, appointment.startDateTimeZone),\n            sourceOffsets_endDate = this.timeZoneCalculator.getOffsets(a.endDate, appointment.endDateTimeZone);\n        var startDateOffsetDiff = appointmentOffsets.startDate.appointment - sourceOffsets_startDate.appointment;\n        var endDateOffsetDiff = appointmentOffsets.endDate.appointment - sourceOffsets_endDate.appointment;\n\n        if (sourceOffsets_startDate.appointment !== sourceOffsets_startDate.common) {\n          a.startDate = new Date(a.startDate.getTime() + startDateOffsetDiff * toMs(\"hour\"));\n        }\n\n        if (sourceOffsets_endDate.appointment !== sourceOffsets_endDate.common) {\n          a.endDate = new Date(a.endDate.getTime() + endDateOffsetDiff * toMs(\"hour\"));\n        }\n      });\n    }\n\n    return appointmentList;\n  }\n\n  _createAppointments(appointment, groupIndices) {\n    var appointments = this._createRecurrenceAppointments(appointment, groupIndices);\n\n    if (!appointment.isRecurrent && 0 === appointments.length) {\n      appointments.push({\n        startDate: appointment.startDate,\n        endDate: appointment.endDate\n      });\n    }\n\n    appointments = appointments.map(item => {\n      var _item$endDate;\n\n      var resultEndTime = null === (_item$endDate = item.endDate) || void 0 === _item$endDate ? void 0 : _item$endDate.getTime();\n\n      if (item.startDate.getTime() === resultEndTime) {\n        item.endDate.setTime(resultEndTime + toMs(\"minute\"));\n      }\n\n      return _extends({}, item, {\n        exceptionDate: new Date(item.startDate)\n      });\n    });\n    return appointments;\n  }\n\n  _canProcessNotNativeTimezoneDates(appointment) {\n    var isTimeZoneSet = !isEmptyObject(this.timeZone);\n\n    if (!isTimeZoneSet) {\n      return false;\n    }\n\n    if (!appointment.isRecurrent) {\n      return false;\n    }\n\n    return !timeZoneUtils.isEqualLocalTimeZone(this.timeZone, appointment.startDate);\n  }\n\n  _getProcessedNotNativeDateIfCrossDST(date, offset) {\n    if (offset < 0) {\n      var newDate = new Date(date);\n      var newDateMinusOneHour = new Date(newDate);\n      newDateMinusOneHour.setHours(newDateMinusOneHour.getHours() - 1);\n      var newDateOffset = this.timeZoneCalculator.getOffsets(newDate).common;\n      var newDateMinusOneHourOffset = this.timeZoneCalculator.getOffsets(newDateMinusOneHour).common;\n\n      if (newDateOffset !== newDateMinusOneHourOffset) {\n        return 0;\n      }\n    }\n\n    return offset;\n  }\n\n  _getCommonOffset(date) {\n    return this.timeZoneCalculator.getOffsets(date).common;\n  }\n\n  _getProcessedNotNativeTimezoneDates(appointmentList, appointment) {\n    return appointmentList.map(item => {\n      var diffStartDateOffset = this._getCommonOffset(appointment.startDate) - this._getCommonOffset(item.startDate);\n\n      var diffEndDateOffset = this._getCommonOffset(appointment.endDate) - this._getCommonOffset(item.endDate);\n\n      if (0 === diffStartDateOffset && 0 === diffEndDateOffset) {\n        return item;\n      }\n\n      diffStartDateOffset = this._getProcessedNotNativeDateIfCrossDST(item.startDate, diffStartDateOffset);\n      diffEndDateOffset = this._getProcessedNotNativeDateIfCrossDST(item.endDate, diffEndDateOffset);\n      var newStartDate = new Date(item.startDate.getTime() + diffStartDateOffset * toMs(\"hour\"));\n      var newEndDate = new Date(item.endDate.getTime() + diffEndDateOffset * toMs(\"hour\"));\n      var testNewStartDate = this.timeZoneCalculator.createDate(newStartDate, {\n        path: \"toGrid\"\n      });\n      var testNewEndDate = this.timeZoneCalculator.createDate(newEndDate, {\n        path: \"toGrid\"\n      });\n\n      if (appointment.duration > testNewEndDate.getTime() - testNewStartDate.getTime()) {\n        newEndDate = new Date(newStartDate.getTime() + appointment.duration);\n      }\n\n      return _extends({}, item, {\n        startDate: newStartDate,\n        endDate: newEndDate,\n        exceptionDate: new Date(newStartDate)\n      });\n    });\n  }\n\n  _needSeparateLongParts() {\n    return this.isVerticalOrientation ? this.isGroupedByDate : this.isGroupedByDate && this.appointmentTakesAllDay;\n  }\n\n  normalizeEndDateByViewEnd(rawAppointment, endDate) {\n    var result = new Date(endDate.getTime());\n    var isAllDay = isDateAndTimeView(this.viewType) && this.appointmentTakesAllDay;\n\n    if (!isAllDay) {\n      var roundedEndViewDate = dateUtils.roundToHour(this.endViewDate);\n\n      if (result > roundedEndViewDate) {\n        result = roundedEndViewDate;\n      }\n    }\n\n    var endDayHour = this.viewEndDayHour;\n    var allDay = ExpressionUtils.getField(this.dataAccessors, \"allDay\", rawAppointment);\n    var currentViewEndTime = new Date(new Date(endDate.getTime()).setHours(endDayHour, 0, 0, 0));\n\n    if (result.getTime() > currentViewEndTime.getTime() || allDay && result.getHours() < endDayHour) {\n      result = currentViewEndTime;\n    }\n\n    return result;\n  }\n\n  _fillNormalizedEndDate(dateSettings, rawAppointment) {\n    return dateSettings.map(item => {\n      var {\n        endDate: endDate\n      } = item;\n      var normalizedEndDate = this.normalizeEndDateByViewEnd(rawAppointment, endDate);\n      return _extends({}, item, {\n        normalizedEndDate: normalizedEndDate\n      });\n    });\n  }\n\n  _separateLongParts(gridAppointmentList, appointmentAdapter) {\n    var result = [];\n    gridAppointmentList.forEach(gridAppointment => {\n      var maxDate = new Date(this.dateRange[1]);\n      var {\n        normalizedEndDate: endDateOfPart\n      } = gridAppointment;\n      var longStartDateParts = dateUtils.getDatesOfInterval(gridAppointment.startDate, endDateOfPart, {\n        milliseconds: this.getIntervalDuration(this.appointmentTakesAllDay)\n      });\n      var list = longStartDateParts.filter(startDatePart => new Date(startDatePart) < maxDate).map(date => {\n        var endDate = new Date(new Date(date).setMilliseconds(appointmentAdapter.duration));\n        var normalizedEndDate = this.normalizeEndDateByViewEnd(this.rawAppointment, endDate);\n        return {\n          startDate: date,\n          endDate: endDate,\n          normalizedEndDate: normalizedEndDate,\n          source: gridAppointment.source\n        };\n      });\n      result = result.concat(list);\n    });\n    return result;\n  }\n\n  _createGridAppointmentList(appointmentList, appointmentAdapter) {\n    return appointmentList.map(source => {\n      var offsetDifference = appointmentAdapter.startDate.getTimezoneOffset() - source.startDate.getTimezoneOffset();\n\n      if (0 !== offsetDifference && this._canProcessNotNativeTimezoneDates(appointmentAdapter)) {\n        source.startDate = new Date(source.startDate.getTime() + offsetDifference * toMs(\"minute\"));\n        source.endDate = new Date(source.endDate.getTime() + offsetDifference * toMs(\"minute\"));\n        source.exceptionDate = new Date(source.startDate);\n      }\n\n      var startDate = this.timeZoneCalculator.createDate(source.startDate, {\n        path: \"toGrid\"\n      });\n      var endDate = this.timeZoneCalculator.createDate(source.endDate, {\n        path: \"toGrid\"\n      });\n      return {\n        startDate: startDate,\n        endDate: endDate,\n        allDay: appointmentAdapter.allDay || false,\n        source: source\n      };\n    });\n  }\n\n  _createExtremeRecurrenceDates() {\n    var startViewDate = this.appointmentTakesAllDay ? dateUtils.trimTime(this.dateRange[0]) : this.dateRange[0];\n    var endViewDateByEndDayHour = this.dateRange[1];\n\n    if (this.timeZone) {\n      startViewDate = this.timeZoneCalculator.createDate(startViewDate, {\n        path: \"fromGrid\"\n      });\n      endViewDateByEndDayHour = this.timeZoneCalculator.createDate(endViewDateByEndDayHour, {\n        path: \"fromGrid\"\n      });\n      var daylightOffset = timeZoneUtils.getDaylightOffsetInMs(startViewDate, endViewDateByEndDayHour);\n\n      if (daylightOffset) {\n        endViewDateByEndDayHour = new Date(endViewDateByEndDayHour.getTime() + daylightOffset);\n      }\n    }\n\n    return [startViewDate, endViewDateByEndDayHour];\n  }\n\n  _createRecurrenceOptions(appointment, groupIndex) {\n    var [minRecurrenceDate, maxRecurrenceDate] = this._createExtremeRecurrenceDates(groupIndex);\n\n    return {\n      rule: appointment.recurrenceRule,\n      exception: appointment.recurrenceException,\n      min: minRecurrenceDate,\n      max: maxRecurrenceDate,\n      firstDayOfWeek: this.firstDayOfWeek,\n      start: appointment.startDate,\n      end: appointment.endDate,\n      appointmentTimezoneOffset: this.timeZoneCalculator.getOriginStartDateOffsetInMs(appointment.startDate, appointment.rawAppointment.startDateTimeZone, true),\n      getPostProcessedException: date => {\n        if (isEmptyObject(this.timeZone) || timeZoneUtils.isEqualLocalTimeZone(this.timeZone, date)) {\n          return date;\n        }\n\n        var appointmentOffset = this.timeZoneCalculator.getOffsets(appointment.startDate).common;\n        var exceptionAppointmentOffset = this.timeZoneCalculator.getOffsets(date).common;\n        var diff = appointmentOffset - exceptionAppointmentOffset;\n        diff = this._getProcessedNotNativeDateIfCrossDST(date, diff);\n        return new Date(date.getTime() - diff * dateUtils.dateToMilliseconds(\"hour\"));\n      }\n    };\n  }\n\n  _createRecurrenceAppointments(appointment, groupIndices) {\n    var {\n      duration: duration\n    } = appointment;\n\n    var option = this._createRecurrenceOptions(appointment);\n\n    var generatedStartDates = getRecurrenceProcessor().generateDates(option);\n    return generatedStartDates.map(date => {\n      var utcDate = timeZoneUtils.createUTCDateWithLocalOffset(date);\n      utcDate.setTime(utcDate.getTime() + duration);\n      var endDate = timeZoneUtils.createDateFromUTCWithLocalOffset(utcDate);\n      return {\n        startDate: new Date(date),\n        endDate: endDate\n      };\n    });\n  }\n\n  _getAppointmentsFirstViewDate(appointments) {\n    return appointments.map(appointment => this._getAppointmentFirstViewDate(appointment));\n  }\n\n  _fillNormalizedStartDate(appointments, firstViewDates, rawAppointment) {\n    appointments.forEach((appointment, idx) => {\n      appointment.startDate = this._getAppointmentResultDate({\n        appointment: appointment,\n        rawAppointment: rawAppointment,\n        startDate: new Date(appointment.startDate),\n        startDayHour: this.viewStartDayHour,\n        firstViewDate: firstViewDates[idx]\n      });\n    });\n  }\n\n  _cropAppointmentsByStartDayHour(appointments, firstViewDates) {\n    return appointments.filter((appointment, idx) => {\n      if (!firstViewDates[idx]) {\n        return false;\n      } else if (this.appointmentTakesAllDay) {\n        return true;\n      }\n\n      return appointment.endDate > appointment.startDate;\n    });\n  }\n\n  _getAppointmentResultDate(options) {\n    var {\n      appointment: appointment,\n      startDayHour: startDayHour,\n      firstViewDate: firstViewDate\n    } = options;\n    var {\n      startDate: startDate\n    } = options;\n    var resultDate;\n\n    if (this.appointmentTakesAllDay) {\n      resultDate = dateUtils.normalizeDate(startDate, firstViewDate);\n    } else {\n      if (startDate < firstViewDate) {\n        startDate = firstViewDate;\n      }\n\n      resultDate = dateUtils.normalizeDate(appointment.startDate, startDate);\n    }\n\n    return !this.isDateAppointment ? dateUtils.roundDateByStartDayHour(resultDate, startDayHour) : resultDate;\n  }\n\n  _getAppointmentFirstViewDate(appointment) {\n    var groupIndex = appointment.source.groupIndex || 0;\n    var {\n      startDate: startDate,\n      endDate: endDate\n    } = appointment;\n\n    if (this.isAllDayRowAppointment || appointment.allDay) {\n      return this.viewDataProvider.findAllDayGroupCellStartDate(groupIndex, startDate);\n    }\n\n    return this.viewDataProvider.findGroupCellStartDate(groupIndex, startDate, endDate, this.isDateAppointment);\n  }\n\n  _getGroupIndices(rawAppointment) {\n    var result = [];\n\n    if (rawAppointment && this.loadedResources.length) {\n      var tree = createResourcesTree(this.loadedResources);\n      result = getResourceTreeLeaves((field, action) => getDataAccessors(this.options.dataAccessors.resources, field, action), tree, rawAppointment);\n    }\n\n    return result;\n  }\n\n}\nexport class DateGeneratorVirtualStrategy extends DateGeneratorBaseStrategy {\n  get groupCount() {\n    return getGroupCount(this.loadedResources);\n  }\n\n  _createRecurrenceAppointments(appointment, groupIndices) {\n    var {\n      duration: duration\n    } = appointment;\n    var result = [];\n    var validGroupIndices = this.groupCount ? groupIndices : [0];\n    validGroupIndices.forEach(groupIndex => {\n      var option = this._createRecurrenceOptions(appointment, groupIndex);\n\n      var generatedStartDates = getRecurrenceProcessor().generateDates(option);\n      var recurrentInfo = generatedStartDates.map(date => {\n        var startDate = new Date(date);\n        var utcDate = timeZoneUtils.createUTCDateWithLocalOffset(date);\n        utcDate.setTime(utcDate.getTime() + duration);\n        var endDate = timeZoneUtils.createDateFromUTCWithLocalOffset(utcDate);\n        return {\n          startDate: startDate,\n          endDate: endDate,\n          groupIndex: groupIndex\n        };\n      });\n      result.push(...recurrentInfo);\n    });\n    return result;\n  }\n\n  _updateGroupIndices(appointments, groupIndices) {\n    var result = [];\n    groupIndices.forEach(groupIndex => {\n      var groupStartDate = this.viewDataProvider.getGroupStartDate(groupIndex);\n\n      if (groupStartDate) {\n        appointments.forEach(appointment => {\n          var appointmentCopy = extend({}, appointment);\n          appointmentCopy.groupIndex = groupIndex;\n          result.push(appointmentCopy);\n        });\n      }\n    });\n    return result;\n  }\n\n  _getGroupIndices(resources) {\n    var _groupIndices;\n\n    var groupIndices = super._getGroupIndices(resources);\n\n    var viewDataGroupIndices = this.viewDataProvider.getGroupIndices();\n\n    if (!(null !== (_groupIndices = groupIndices) && void 0 !== _groupIndices && _groupIndices.length)) {\n      groupIndices = [0];\n    }\n\n    return groupIndices.filter(groupIndex => -1 !== viewDataGroupIndices.indexOf(groupIndex));\n  }\n\n  _createAppointments(appointment, groupIndices) {\n    var appointments = super._createAppointments(appointment, groupIndices);\n\n    return !appointment.isRecurrent ? this._updateGroupIndices(appointments, groupIndices) : appointments;\n  }\n\n}\nexport class AppointmentSettingsGenerator {\n  constructor(options) {\n    this.options = options;\n    this.appointmentAdapter = createAppointmentAdapter(this.rawAppointment, this.dataAccessors, this.timeZoneCalculator);\n  }\n\n  get rawAppointment() {\n    return this.options.rawAppointment;\n  }\n\n  get dataAccessors() {\n    return this.options.dataAccessors;\n  }\n\n  get timeZoneCalculator() {\n    return this.options.timeZoneCalculator;\n  }\n\n  get isAllDayRowAppointment() {\n    return this.options.appointmentTakesAllDay && this.options.supportAllDayRow;\n  }\n\n  get groups() {\n    return this.options.groups;\n  }\n\n  get dateSettingsStrategy() {\n    var options = _extends({}, this.options, {\n      isAllDayRowAppointment: this.isAllDayRowAppointment\n    });\n\n    return this.options.isVirtualScrolling ? new DateGeneratorVirtualStrategy(options) : new DateGeneratorBaseStrategy(options);\n  }\n\n  create() {\n    var {\n      dateSettings: dateSettings,\n      itemGroupIndices: itemGroupIndices,\n      isRecurrent: isRecurrent\n    } = this._generateDateSettings();\n\n    var cellPositions = this._calculateCellPositions(dateSettings, itemGroupIndices);\n\n    var result = this._prepareAppointmentInfos(dateSettings, cellPositions, isRecurrent);\n\n    return result;\n  }\n\n  _generateDateSettings() {\n    return this.dateSettingsStrategy.generate(this.appointmentAdapter);\n  }\n\n  _calculateCellPositions(dateSettings, itemGroupIndices) {\n    var cellPositionCalculator = new CellPositionCalculator(_extends({}, this.options, {\n      dateSettings: dateSettings\n    }));\n    return cellPositionCalculator.calculateCellPositions(itemGroupIndices, this.isAllDayRowAppointment, this.appointmentAdapter.isRecurrent);\n  }\n\n  _prepareAppointmentInfos(dateSettings, cellPositions, isRecurrent) {\n    var infos = [];\n    cellPositions.forEach(_ref => {\n      var {\n        coordinates: coordinates,\n        dateSettingIndex: dateSettingIndex\n      } = _ref;\n      var dateSetting = dateSettings[dateSettingIndex];\n\n      var dateText = this._getAppointmentDateText(dateSetting);\n\n      var info = {\n        appointment: dateSetting,\n        sourceAppointment: dateSetting.source,\n        dateText: dateText,\n        isRecurrent: isRecurrent\n      };\n      infos.push(_extends({}, coordinates, {\n        info: info\n      }));\n    });\n    return infos;\n  }\n\n  _getAppointmentDateText(sourceAppointment) {\n    var {\n      startDate: startDate,\n      endDate: endDate,\n      allDay: allDay\n    } = sourceAppointment;\n    return createFormattedDateText({\n      startDate: startDate,\n      endDate: endDate,\n      allDay: allDay,\n      format: APPOINTMENT_DATE_TEXT_FORMAT\n    });\n  }\n\n}","map":{"version":3,"names":["_extends","dateUtils","isEmptyObject","extend","getRecurrenceProcessor","timeZoneUtils","createResourcesTree","getDataAccessors","getGroupCount","getResourceTreeLeaves","createAppointmentAdapter","CellPositionCalculator","ExpressionUtils","isDateAndTimeView","createFormattedDateText","toMs","dateToMilliseconds","APPOINTMENT_DATE_TEXT_FORMAT","DateGeneratorBaseStrategy","constructor","options","rawAppointment","timeZoneCalculator","viewDataProvider","appointmentTakesAllDay","supportAllDayRow","isAllDayRowAppointment","timeZone","dateRange","firstDayOfWeek","viewStartDayHour","viewEndDayHour","endViewDate","viewType","isGroupedByDate","isVerticalOrientation","isVerticalGroupOrientation","dataAccessors","loadedResources","isDateAppointment","getIntervalDuration","allDayIntervalDuration","intervalDuration","generate","appointmentAdapter","itemGroupIndices","_getGroupIndices","appointmentList","_createAppointments","_getProcessedByAppointmentTimeZone","_canProcessNotNativeTimezoneDates","_getProcessedNotNativeTimezoneDates","dateSettings","_createGridAppointmentList","firstViewDates","_getAppointmentsFirstViewDate","_fillNormalizedStartDate","_cropAppointmentsByStartDayHour","_fillNormalizedEndDate","_needSeparateLongParts","_separateLongParts","isRecurrent","appointment","hasAppointmentTimeZone","startDateTimeZone","endDateTimeZone","appointmentOffsets","startDate","getOffsets","endDate","forEach","a","sourceOffsets_startDate","sourceOffsets_endDate","startDateOffsetDiff","endDateOffsetDiff","common","Date","getTime","groupIndices","appointments","_createRecurrenceAppointments","length","push","map","item","_item$endDate","resultEndTime","setTime","exceptionDate","isTimeZoneSet","isEqualLocalTimeZone","_getProcessedNotNativeDateIfCrossDST","date","offset","newDate","newDateMinusOneHour","setHours","getHours","newDateOffset","newDateMinusOneHourOffset","_getCommonOffset","diffStartDateOffset","diffEndDateOffset","newStartDate","newEndDate","testNewStartDate","createDate","path","testNewEndDate","duration","normalizeEndDateByViewEnd","result","isAllDay","roundedEndViewDate","roundToHour","endDayHour","allDay","getField","currentViewEndTime","normalizedEndDate","gridAppointmentList","gridAppointment","maxDate","endDateOfPart","longStartDateParts","getDatesOfInterval","milliseconds","list","filter","startDatePart","setMilliseconds","source","concat","offsetDifference","getTimezoneOffset","_createExtremeRecurrenceDates","startViewDate","trimTime","endViewDateByEndDayHour","daylightOffset","getDaylightOffsetInMs","_createRecurrenceOptions","groupIndex","minRecurrenceDate","maxRecurrenceDate","rule","recurrenceRule","exception","recurrenceException","min","max","start","end","appointmentTimezoneOffset","getOriginStartDateOffsetInMs","getPostProcessedException","appointmentOffset","exceptionAppointmentOffset","diff","option","generatedStartDates","generateDates","utcDate","createUTCDateWithLocalOffset","createDateFromUTCWithLocalOffset","_getAppointmentFirstViewDate","idx","_getAppointmentResultDate","startDayHour","firstViewDate","resultDate","normalizeDate","roundDateByStartDayHour","findAllDayGroupCellStartDate","findGroupCellStartDate","tree","field","action","resources","DateGeneratorVirtualStrategy","groupCount","validGroupIndices","recurrentInfo","_updateGroupIndices","groupStartDate","getGroupStartDate","appointmentCopy","_groupIndices","viewDataGroupIndices","getGroupIndices","indexOf","AppointmentSettingsGenerator","groups","dateSettingsStrategy","isVirtualScrolling","create","_generateDateSettings","cellPositions","_calculateCellPositions","_prepareAppointmentInfos","cellPositionCalculator","calculateCellPositions","infos","_ref","coordinates","dateSettingIndex","dateSetting","dateText","_getAppointmentDateText","info","sourceAppointment","format"],"sources":["D:/APPLICATION/UI/UPL/NEW/node_modules/devextreme/esm/ui/scheduler/appointments/settingsGenerator.js"],"sourcesContent":["/**\r\n * DevExtreme (esm/ui/scheduler/appointments/settingsGenerator.js)\r\n * Version: 22.2.4\r\n * Build date: Thu Jan 19 2023\r\n *\r\n * Copyright (c) 2012 - 2023 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\r\nimport _extends from \"@babel/runtime/helpers/esm/extends\";\r\nimport dateUtils from \"../../../core/utils/date\";\r\nimport {\r\n    isEmptyObject\r\n} from \"../../../core/utils/type\";\r\nimport {\r\n    extend\r\n} from \"../../../core/utils/extend\";\r\nimport {\r\n    getRecurrenceProcessor\r\n} from \"../recurrence\";\r\nimport timeZoneUtils from \"../utils.timeZone\";\r\nimport {\r\n    createResourcesTree,\r\n    getDataAccessors,\r\n    getGroupCount,\r\n    getResourceTreeLeaves\r\n} from \"../resources/utils\";\r\nimport {\r\n    createAppointmentAdapter\r\n} from \"../appointmentAdapter\";\r\nimport {\r\n    CellPositionCalculator\r\n} from \"./cellPositionCalculator\";\r\nimport {\r\n    ExpressionUtils\r\n} from \"../expressionUtils\";\r\nimport {\r\n    isDateAndTimeView\r\n} from \"../../../renovation/ui/scheduler/view_model/to_test/views/utils/base\";\r\nimport {\r\n    createFormattedDateText\r\n} from \"./textUtils\";\r\nvar toMs = dateUtils.dateToMilliseconds;\r\nvar APPOINTMENT_DATE_TEXT_FORMAT = \"TIME\";\r\nexport class DateGeneratorBaseStrategy {\r\n    constructor(options) {\r\n        this.options = options\r\n    }\r\n    get rawAppointment() {\r\n        return this.options.rawAppointment\r\n    }\r\n    get timeZoneCalculator() {\r\n        return this.options.timeZoneCalculator\r\n    }\r\n    get viewDataProvider() {\r\n        return this.options.viewDataProvider\r\n    }\r\n    get appointmentTakesAllDay() {\r\n        return this.options.appointmentTakesAllDay\r\n    }\r\n    get supportAllDayRow() {\r\n        return this.options.supportAllDayRow\r\n    }\r\n    get isAllDayRowAppointment() {\r\n        return this.options.isAllDayRowAppointment\r\n    }\r\n    get timeZone() {\r\n        return this.options.timeZone\r\n    }\r\n    get dateRange() {\r\n        return this.options.dateRange\r\n    }\r\n    get firstDayOfWeek() {\r\n        return this.options.firstDayOfWeek\r\n    }\r\n    get viewStartDayHour() {\r\n        return this.options.viewStartDayHour\r\n    }\r\n    get viewEndDayHour() {\r\n        return this.options.viewEndDayHour\r\n    }\r\n    get endViewDate() {\r\n        return this.options.endViewDate\r\n    }\r\n    get viewType() {\r\n        return this.options.viewType\r\n    }\r\n    get isGroupedByDate() {\r\n        return this.options.isGroupedByDate\r\n    }\r\n    get isVerticalOrientation() {\r\n        return this.options.isVerticalGroupOrientation\r\n    }\r\n    get dataAccessors() {\r\n        return this.options.dataAccessors\r\n    }\r\n    get loadedResources() {\r\n        return this.options.loadedResources\r\n    }\r\n    get isDateAppointment() {\r\n        return !isDateAndTimeView(this.viewType) && this.appointmentTakesAllDay\r\n    }\r\n    getIntervalDuration() {\r\n        return this.appointmentTakesAllDay ? this.options.allDayIntervalDuration : this.options.intervalDuration\r\n    }\r\n    generate(appointmentAdapter) {\r\n        var itemGroupIndices = this._getGroupIndices(this.rawAppointment);\r\n        var appointmentList = this._createAppointments(appointmentAdapter, itemGroupIndices);\r\n        appointmentList = this._getProcessedByAppointmentTimeZone(appointmentList, appointmentAdapter);\r\n        if (this._canProcessNotNativeTimezoneDates(appointmentAdapter)) {\r\n            appointmentList = this._getProcessedNotNativeTimezoneDates(appointmentList, appointmentAdapter)\r\n        }\r\n        var dateSettings = this._createGridAppointmentList(appointmentList, appointmentAdapter);\r\n        var firstViewDates = this._getAppointmentsFirstViewDate(dateSettings);\r\n        this._fillNormalizedStartDate(dateSettings, firstViewDates);\r\n        dateSettings = this._cropAppointmentsByStartDayHour(dateSettings, firstViewDates, this.rawAppointment);\r\n        dateSettings = this._fillNormalizedEndDate(dateSettings, this.rawAppointment);\r\n        if (this._needSeparateLongParts()) {\r\n            dateSettings = this._separateLongParts(dateSettings, appointmentAdapter)\r\n        }\r\n        var {\r\n            isRecurrent: isRecurrent\r\n        } = appointmentAdapter;\r\n        return {\r\n            dateSettings: dateSettings,\r\n            itemGroupIndices: itemGroupIndices,\r\n            isRecurrent: isRecurrent\r\n        }\r\n    }\r\n    _getProcessedByAppointmentTimeZone(appointmentList, appointment) {\r\n        var hasAppointmentTimeZone = !isEmptyObject(appointment.startDateTimeZone) || !isEmptyObject(appointment.endDateTimeZone);\r\n        if (hasAppointmentTimeZone) {\r\n            var appointmentOffsets = {\r\n                startDate: this.timeZoneCalculator.getOffsets(appointment.startDate, appointment.startDateTimeZone),\r\n                endDate: this.timeZoneCalculator.getOffsets(appointment.endDate, appointment.endDateTimeZone)\r\n            };\r\n            appointmentList.forEach(a => {\r\n                var sourceOffsets_startDate = this.timeZoneCalculator.getOffsets(a.startDate, appointment.startDateTimeZone),\r\n                    sourceOffsets_endDate = this.timeZoneCalculator.getOffsets(a.endDate, appointment.endDateTimeZone);\r\n                var startDateOffsetDiff = appointmentOffsets.startDate.appointment - sourceOffsets_startDate.appointment;\r\n                var endDateOffsetDiff = appointmentOffsets.endDate.appointment - sourceOffsets_endDate.appointment;\r\n                if (sourceOffsets_startDate.appointment !== sourceOffsets_startDate.common) {\r\n                    a.startDate = new Date(a.startDate.getTime() + startDateOffsetDiff * toMs(\"hour\"))\r\n                }\r\n                if (sourceOffsets_endDate.appointment !== sourceOffsets_endDate.common) {\r\n                    a.endDate = new Date(a.endDate.getTime() + endDateOffsetDiff * toMs(\"hour\"))\r\n                }\r\n            })\r\n        }\r\n        return appointmentList\r\n    }\r\n    _createAppointments(appointment, groupIndices) {\r\n        var appointments = this._createRecurrenceAppointments(appointment, groupIndices);\r\n        if (!appointment.isRecurrent && 0 === appointments.length) {\r\n            appointments.push({\r\n                startDate: appointment.startDate,\r\n                endDate: appointment.endDate\r\n            })\r\n        }\r\n        appointments = appointments.map(item => {\r\n            var _item$endDate;\r\n            var resultEndTime = null === (_item$endDate = item.endDate) || void 0 === _item$endDate ? void 0 : _item$endDate.getTime();\r\n            if (item.startDate.getTime() === resultEndTime) {\r\n                item.endDate.setTime(resultEndTime + toMs(\"minute\"))\r\n            }\r\n            return _extends({}, item, {\r\n                exceptionDate: new Date(item.startDate)\r\n            })\r\n        });\r\n        return appointments\r\n    }\r\n    _canProcessNotNativeTimezoneDates(appointment) {\r\n        var isTimeZoneSet = !isEmptyObject(this.timeZone);\r\n        if (!isTimeZoneSet) {\r\n            return false\r\n        }\r\n        if (!appointment.isRecurrent) {\r\n            return false\r\n        }\r\n        return !timeZoneUtils.isEqualLocalTimeZone(this.timeZone, appointment.startDate)\r\n    }\r\n    _getProcessedNotNativeDateIfCrossDST(date, offset) {\r\n        if (offset < 0) {\r\n            var newDate = new Date(date);\r\n            var newDateMinusOneHour = new Date(newDate);\r\n            newDateMinusOneHour.setHours(newDateMinusOneHour.getHours() - 1);\r\n            var newDateOffset = this.timeZoneCalculator.getOffsets(newDate).common;\r\n            var newDateMinusOneHourOffset = this.timeZoneCalculator.getOffsets(newDateMinusOneHour).common;\r\n            if (newDateOffset !== newDateMinusOneHourOffset) {\r\n                return 0\r\n            }\r\n        }\r\n        return offset\r\n    }\r\n    _getCommonOffset(date) {\r\n        return this.timeZoneCalculator.getOffsets(date).common\r\n    }\r\n    _getProcessedNotNativeTimezoneDates(appointmentList, appointment) {\r\n        return appointmentList.map(item => {\r\n            var diffStartDateOffset = this._getCommonOffset(appointment.startDate) - this._getCommonOffset(item.startDate);\r\n            var diffEndDateOffset = this._getCommonOffset(appointment.endDate) - this._getCommonOffset(item.endDate);\r\n            if (0 === diffStartDateOffset && 0 === diffEndDateOffset) {\r\n                return item\r\n            }\r\n            diffStartDateOffset = this._getProcessedNotNativeDateIfCrossDST(item.startDate, diffStartDateOffset);\r\n            diffEndDateOffset = this._getProcessedNotNativeDateIfCrossDST(item.endDate, diffEndDateOffset);\r\n            var newStartDate = new Date(item.startDate.getTime() + diffStartDateOffset * toMs(\"hour\"));\r\n            var newEndDate = new Date(item.endDate.getTime() + diffEndDateOffset * toMs(\"hour\"));\r\n            var testNewStartDate = this.timeZoneCalculator.createDate(newStartDate, {\r\n                path: \"toGrid\"\r\n            });\r\n            var testNewEndDate = this.timeZoneCalculator.createDate(newEndDate, {\r\n                path: \"toGrid\"\r\n            });\r\n            if (appointment.duration > testNewEndDate.getTime() - testNewStartDate.getTime()) {\r\n                newEndDate = new Date(newStartDate.getTime() + appointment.duration)\r\n            }\r\n            return _extends({}, item, {\r\n                startDate: newStartDate,\r\n                endDate: newEndDate,\r\n                exceptionDate: new Date(newStartDate)\r\n            })\r\n        })\r\n    }\r\n    _needSeparateLongParts() {\r\n        return this.isVerticalOrientation ? this.isGroupedByDate : this.isGroupedByDate && this.appointmentTakesAllDay\r\n    }\r\n    normalizeEndDateByViewEnd(rawAppointment, endDate) {\r\n        var result = new Date(endDate.getTime());\r\n        var isAllDay = isDateAndTimeView(this.viewType) && this.appointmentTakesAllDay;\r\n        if (!isAllDay) {\r\n            var roundedEndViewDate = dateUtils.roundToHour(this.endViewDate);\r\n            if (result > roundedEndViewDate) {\r\n                result = roundedEndViewDate\r\n            }\r\n        }\r\n        var endDayHour = this.viewEndDayHour;\r\n        var allDay = ExpressionUtils.getField(this.dataAccessors, \"allDay\", rawAppointment);\r\n        var currentViewEndTime = new Date(new Date(endDate.getTime()).setHours(endDayHour, 0, 0, 0));\r\n        if (result.getTime() > currentViewEndTime.getTime() || allDay && result.getHours() < endDayHour) {\r\n            result = currentViewEndTime\r\n        }\r\n        return result\r\n    }\r\n    _fillNormalizedEndDate(dateSettings, rawAppointment) {\r\n        return dateSettings.map(item => {\r\n            var {\r\n                endDate: endDate\r\n            } = item;\r\n            var normalizedEndDate = this.normalizeEndDateByViewEnd(rawAppointment, endDate);\r\n            return _extends({}, item, {\r\n                normalizedEndDate: normalizedEndDate\r\n            })\r\n        })\r\n    }\r\n    _separateLongParts(gridAppointmentList, appointmentAdapter) {\r\n        var result = [];\r\n        gridAppointmentList.forEach(gridAppointment => {\r\n            var maxDate = new Date(this.dateRange[1]);\r\n            var {\r\n                normalizedEndDate: endDateOfPart\r\n            } = gridAppointment;\r\n            var longStartDateParts = dateUtils.getDatesOfInterval(gridAppointment.startDate, endDateOfPart, {\r\n                milliseconds: this.getIntervalDuration(this.appointmentTakesAllDay)\r\n            });\r\n            var list = longStartDateParts.filter(startDatePart => new Date(startDatePart) < maxDate).map(date => {\r\n                var endDate = new Date(new Date(date).setMilliseconds(appointmentAdapter.duration));\r\n                var normalizedEndDate = this.normalizeEndDateByViewEnd(this.rawAppointment, endDate);\r\n                return {\r\n                    startDate: date,\r\n                    endDate: endDate,\r\n                    normalizedEndDate: normalizedEndDate,\r\n                    source: gridAppointment.source\r\n                }\r\n            });\r\n            result = result.concat(list)\r\n        });\r\n        return result\r\n    }\r\n    _createGridAppointmentList(appointmentList, appointmentAdapter) {\r\n        return appointmentList.map(source => {\r\n            var offsetDifference = appointmentAdapter.startDate.getTimezoneOffset() - source.startDate.getTimezoneOffset();\r\n            if (0 !== offsetDifference && this._canProcessNotNativeTimezoneDates(appointmentAdapter)) {\r\n                source.startDate = new Date(source.startDate.getTime() + offsetDifference * toMs(\"minute\"));\r\n                source.endDate = new Date(source.endDate.getTime() + offsetDifference * toMs(\"minute\"));\r\n                source.exceptionDate = new Date(source.startDate)\r\n            }\r\n            var startDate = this.timeZoneCalculator.createDate(source.startDate, {\r\n                path: \"toGrid\"\r\n            });\r\n            var endDate = this.timeZoneCalculator.createDate(source.endDate, {\r\n                path: \"toGrid\"\r\n            });\r\n            return {\r\n                startDate: startDate,\r\n                endDate: endDate,\r\n                allDay: appointmentAdapter.allDay || false,\r\n                source: source\r\n            }\r\n        })\r\n    }\r\n    _createExtremeRecurrenceDates() {\r\n        var startViewDate = this.appointmentTakesAllDay ? dateUtils.trimTime(this.dateRange[0]) : this.dateRange[0];\r\n        var endViewDateByEndDayHour = this.dateRange[1];\r\n        if (this.timeZone) {\r\n            startViewDate = this.timeZoneCalculator.createDate(startViewDate, {\r\n                path: \"fromGrid\"\r\n            });\r\n            endViewDateByEndDayHour = this.timeZoneCalculator.createDate(endViewDateByEndDayHour, {\r\n                path: \"fromGrid\"\r\n            });\r\n            var daylightOffset = timeZoneUtils.getDaylightOffsetInMs(startViewDate, endViewDateByEndDayHour);\r\n            if (daylightOffset) {\r\n                endViewDateByEndDayHour = new Date(endViewDateByEndDayHour.getTime() + daylightOffset)\r\n            }\r\n        }\r\n        return [startViewDate, endViewDateByEndDayHour]\r\n    }\r\n    _createRecurrenceOptions(appointment, groupIndex) {\r\n        var [minRecurrenceDate, maxRecurrenceDate] = this._createExtremeRecurrenceDates(groupIndex);\r\n        return {\r\n            rule: appointment.recurrenceRule,\r\n            exception: appointment.recurrenceException,\r\n            min: minRecurrenceDate,\r\n            max: maxRecurrenceDate,\r\n            firstDayOfWeek: this.firstDayOfWeek,\r\n            start: appointment.startDate,\r\n            end: appointment.endDate,\r\n            appointmentTimezoneOffset: this.timeZoneCalculator.getOriginStartDateOffsetInMs(appointment.startDate, appointment.rawAppointment.startDateTimeZone, true),\r\n            getPostProcessedException: date => {\r\n                if (isEmptyObject(this.timeZone) || timeZoneUtils.isEqualLocalTimeZone(this.timeZone, date)) {\r\n                    return date\r\n                }\r\n                var appointmentOffset = this.timeZoneCalculator.getOffsets(appointment.startDate).common;\r\n                var exceptionAppointmentOffset = this.timeZoneCalculator.getOffsets(date).common;\r\n                var diff = appointmentOffset - exceptionAppointmentOffset;\r\n                diff = this._getProcessedNotNativeDateIfCrossDST(date, diff);\r\n                return new Date(date.getTime() - diff * dateUtils.dateToMilliseconds(\"hour\"))\r\n            }\r\n        }\r\n    }\r\n    _createRecurrenceAppointments(appointment, groupIndices) {\r\n        var {\r\n            duration: duration\r\n        } = appointment;\r\n        var option = this._createRecurrenceOptions(appointment);\r\n        var generatedStartDates = getRecurrenceProcessor().generateDates(option);\r\n        return generatedStartDates.map(date => {\r\n            var utcDate = timeZoneUtils.createUTCDateWithLocalOffset(date);\r\n            utcDate.setTime(utcDate.getTime() + duration);\r\n            var endDate = timeZoneUtils.createDateFromUTCWithLocalOffset(utcDate);\r\n            return {\r\n                startDate: new Date(date),\r\n                endDate: endDate\r\n            }\r\n        })\r\n    }\r\n    _getAppointmentsFirstViewDate(appointments) {\r\n        return appointments.map(appointment => this._getAppointmentFirstViewDate(appointment))\r\n    }\r\n    _fillNormalizedStartDate(appointments, firstViewDates, rawAppointment) {\r\n        appointments.forEach((appointment, idx) => {\r\n            appointment.startDate = this._getAppointmentResultDate({\r\n                appointment: appointment,\r\n                rawAppointment: rawAppointment,\r\n                startDate: new Date(appointment.startDate),\r\n                startDayHour: this.viewStartDayHour,\r\n                firstViewDate: firstViewDates[idx]\r\n            })\r\n        })\r\n    }\r\n    _cropAppointmentsByStartDayHour(appointments, firstViewDates) {\r\n        return appointments.filter((appointment, idx) => {\r\n            if (!firstViewDates[idx]) {\r\n                return false\r\n            } else if (this.appointmentTakesAllDay) {\r\n                return true\r\n            }\r\n            return appointment.endDate > appointment.startDate\r\n        })\r\n    }\r\n    _getAppointmentResultDate(options) {\r\n        var {\r\n            appointment: appointment,\r\n            startDayHour: startDayHour,\r\n            firstViewDate: firstViewDate\r\n        } = options;\r\n        var {\r\n            startDate: startDate\r\n        } = options;\r\n        var resultDate;\r\n        if (this.appointmentTakesAllDay) {\r\n            resultDate = dateUtils.normalizeDate(startDate, firstViewDate)\r\n        } else {\r\n            if (startDate < firstViewDate) {\r\n                startDate = firstViewDate\r\n            }\r\n            resultDate = dateUtils.normalizeDate(appointment.startDate, startDate)\r\n        }\r\n        return !this.isDateAppointment ? dateUtils.roundDateByStartDayHour(resultDate, startDayHour) : resultDate\r\n    }\r\n    _getAppointmentFirstViewDate(appointment) {\r\n        var groupIndex = appointment.source.groupIndex || 0;\r\n        var {\r\n            startDate: startDate,\r\n            endDate: endDate\r\n        } = appointment;\r\n        if (this.isAllDayRowAppointment || appointment.allDay) {\r\n            return this.viewDataProvider.findAllDayGroupCellStartDate(groupIndex, startDate)\r\n        }\r\n        return this.viewDataProvider.findGroupCellStartDate(groupIndex, startDate, endDate, this.isDateAppointment)\r\n    }\r\n    _getGroupIndices(rawAppointment) {\r\n        var result = [];\r\n        if (rawAppointment && this.loadedResources.length) {\r\n            var tree = createResourcesTree(this.loadedResources);\r\n            result = getResourceTreeLeaves((field, action) => getDataAccessors(this.options.dataAccessors.resources, field, action), tree, rawAppointment)\r\n        }\r\n        return result\r\n    }\r\n}\r\nexport class DateGeneratorVirtualStrategy extends DateGeneratorBaseStrategy {\r\n    get groupCount() {\r\n        return getGroupCount(this.loadedResources)\r\n    }\r\n    _createRecurrenceAppointments(appointment, groupIndices) {\r\n        var {\r\n            duration: duration\r\n        } = appointment;\r\n        var result = [];\r\n        var validGroupIndices = this.groupCount ? groupIndices : [0];\r\n        validGroupIndices.forEach(groupIndex => {\r\n            var option = this._createRecurrenceOptions(appointment, groupIndex);\r\n            var generatedStartDates = getRecurrenceProcessor().generateDates(option);\r\n            var recurrentInfo = generatedStartDates.map(date => {\r\n                var startDate = new Date(date);\r\n                var utcDate = timeZoneUtils.createUTCDateWithLocalOffset(date);\r\n                utcDate.setTime(utcDate.getTime() + duration);\r\n                var endDate = timeZoneUtils.createDateFromUTCWithLocalOffset(utcDate);\r\n                return {\r\n                    startDate: startDate,\r\n                    endDate: endDate,\r\n                    groupIndex: groupIndex\r\n                }\r\n            });\r\n            result.push(...recurrentInfo)\r\n        });\r\n        return result\r\n    }\r\n    _updateGroupIndices(appointments, groupIndices) {\r\n        var result = [];\r\n        groupIndices.forEach(groupIndex => {\r\n            var groupStartDate = this.viewDataProvider.getGroupStartDate(groupIndex);\r\n            if (groupStartDate) {\r\n                appointments.forEach(appointment => {\r\n                    var appointmentCopy = extend({}, appointment);\r\n                    appointmentCopy.groupIndex = groupIndex;\r\n                    result.push(appointmentCopy)\r\n                })\r\n            }\r\n        });\r\n        return result\r\n    }\r\n    _getGroupIndices(resources) {\r\n        var _groupIndices;\r\n        var groupIndices = super._getGroupIndices(resources);\r\n        var viewDataGroupIndices = this.viewDataProvider.getGroupIndices();\r\n        if (!(null !== (_groupIndices = groupIndices) && void 0 !== _groupIndices && _groupIndices.length)) {\r\n            groupIndices = [0]\r\n        }\r\n        return groupIndices.filter(groupIndex => -1 !== viewDataGroupIndices.indexOf(groupIndex))\r\n    }\r\n    _createAppointments(appointment, groupIndices) {\r\n        var appointments = super._createAppointments(appointment, groupIndices);\r\n        return !appointment.isRecurrent ? this._updateGroupIndices(appointments, groupIndices) : appointments\r\n    }\r\n}\r\nexport class AppointmentSettingsGenerator {\r\n    constructor(options) {\r\n        this.options = options;\r\n        this.appointmentAdapter = createAppointmentAdapter(this.rawAppointment, this.dataAccessors, this.timeZoneCalculator)\r\n    }\r\n    get rawAppointment() {\r\n        return this.options.rawAppointment\r\n    }\r\n    get dataAccessors() {\r\n        return this.options.dataAccessors\r\n    }\r\n    get timeZoneCalculator() {\r\n        return this.options.timeZoneCalculator\r\n    }\r\n    get isAllDayRowAppointment() {\r\n        return this.options.appointmentTakesAllDay && this.options.supportAllDayRow\r\n    }\r\n    get groups() {\r\n        return this.options.groups\r\n    }\r\n    get dateSettingsStrategy() {\r\n        var options = _extends({}, this.options, {\r\n            isAllDayRowAppointment: this.isAllDayRowAppointment\r\n        });\r\n        return this.options.isVirtualScrolling ? new DateGeneratorVirtualStrategy(options) : new DateGeneratorBaseStrategy(options)\r\n    }\r\n    create() {\r\n        var {\r\n            dateSettings: dateSettings,\r\n            itemGroupIndices: itemGroupIndices,\r\n            isRecurrent: isRecurrent\r\n        } = this._generateDateSettings();\r\n        var cellPositions = this._calculateCellPositions(dateSettings, itemGroupIndices);\r\n        var result = this._prepareAppointmentInfos(dateSettings, cellPositions, isRecurrent);\r\n        return result\r\n    }\r\n    _generateDateSettings() {\r\n        return this.dateSettingsStrategy.generate(this.appointmentAdapter)\r\n    }\r\n    _calculateCellPositions(dateSettings, itemGroupIndices) {\r\n        var cellPositionCalculator = new CellPositionCalculator(_extends({}, this.options, {\r\n            dateSettings: dateSettings\r\n        }));\r\n        return cellPositionCalculator.calculateCellPositions(itemGroupIndices, this.isAllDayRowAppointment, this.appointmentAdapter.isRecurrent)\r\n    }\r\n    _prepareAppointmentInfos(dateSettings, cellPositions, isRecurrent) {\r\n        var infos = [];\r\n        cellPositions.forEach(_ref => {\r\n            var {\r\n                coordinates: coordinates,\r\n                dateSettingIndex: dateSettingIndex\r\n            } = _ref;\r\n            var dateSetting = dateSettings[dateSettingIndex];\r\n            var dateText = this._getAppointmentDateText(dateSetting);\r\n            var info = {\r\n                appointment: dateSetting,\r\n                sourceAppointment: dateSetting.source,\r\n                dateText: dateText,\r\n                isRecurrent: isRecurrent\r\n            };\r\n            infos.push(_extends({}, coordinates, {\r\n                info: info\r\n            }))\r\n        });\r\n        return infos\r\n    }\r\n    _getAppointmentDateText(sourceAppointment) {\r\n        var {\r\n            startDate: startDate,\r\n            endDate: endDate,\r\n            allDay: allDay\r\n        } = sourceAppointment;\r\n        return createFormattedDateText({\r\n            startDate: startDate,\r\n            endDate: endDate,\r\n            allDay: allDay,\r\n            format: APPOINTMENT_DATE_TEXT_FORMAT\r\n        })\r\n    }\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}