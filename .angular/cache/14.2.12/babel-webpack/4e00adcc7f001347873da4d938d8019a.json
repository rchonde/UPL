{"ast":null,"code":"/**\r\n * Module contains functionality related to [[Sprite]] states.\r\n */\nimport { __extends } from \"tslib\";\n/**\r\n * ============================================================================\r\n * IMPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\n\nimport { BaseObject } from \"./Base\";\nimport { registry } from \"./Registry\";\nimport { Adapter } from \"./utils/Adapter\";\nimport { List, ListDisposer } from \"./utils/List\";\nimport { toColor } from \"./utils/Color\";\nimport { percent } from \"./utils/Percent\";\nimport * as $utils from \"./utils/Utils\";\nimport * as $ease from \"./utils/Ease\";\nimport * as $object from \"./utils/Object\";\nimport * as $type from \"./utils/Type\";\n/**\r\n * Defines a state for [[Sprite]].\r\n *\r\n * A \"state\" is a special object that has all the same properties as the\r\n * [[Sprite]] of the same type, and which can be used to quickly apply a set\r\n * of property values. (set state)\r\n *\r\n * When [[Sprite]] (or any object that extends Sprite) is created it creates a\r\n * \"default\" state. You can modify the \"default\" state so that when the Sprite\r\n * returns to default state certain properties are added.\r\n *\r\n * Default state can be accessed using Sprite's `defaultState` getter.\r\n *\r\n * ```TypeScript\r\n * sprite.defaultState.properties.fillOpacity = 0.5;\r\n * ```\r\n * ```JavaScript\r\n * sprite.defaultState.properties.fillOpacity = 0.5;\r\n * ```\r\n * ```JSON\r\n * {\r\n *   // ...\r\n *   \"defaultState\": {\r\n *     \"properties\": {\r\n *       \"fillOpacity\": 0.5\r\n *     }\r\n *   }\r\n * }\r\n * ```\r\n *\r\n * If Sprite is \"hoverable\", it automatically adds a \"hover\" state, which is\r\n * applied when it has a cursor over it.\r\n *\r\n * ```TypeScript\r\n * let hoverstate = sprite.states.create(\"hover\");\r\n * hoverstate.properties.fillOpacity = 1;\r\n * ```\r\n * ```JavaScript\r\n * var hoverstate = sprite.states.create(\"hover\");\r\n * hoverstate.properties.fillOpacity = 1;\r\n * ```\r\n * ```JSON\r\n * {\r\n *   // ...\r\n *   \"states\": {\r\n *     \"hover\": {\r\n *       \"properties\": {\r\n *         \"fillOpacity\": 0.5\r\n *       }\r\n *     }\r\n *   }\r\n * }\r\n * ```\r\n *\r\n * The above will automatically apply \"hover\" state when the Sprite is hovered,\r\n * thus will set its `fillOpacity` property to 1, and will reset it to 0.5 when\r\n * it's no longer hovered.\r\n *\r\n * Every object that inherits from [[Sprite]] can and will add their own\r\n * properties to the available list.\r\n *\r\n * User can create their own states, and apply them as needed:\r\n *\r\n * ```TypeScript\r\n * let myCustomState = sprite.states.create(\"mystate\");\r\n * myCustomState.properties.fillOpacity = 0.5;\r\n * myCustomState.properties.strokeOpacity = 0.8;\r\n * sprite.setState(\"mystate\");\r\n * ```\r\n * ```JavaScript\r\n * var myCustomState = sprite.states.create(\"mystate\");\r\n * myCustomState.properties.fillOpacity = 0.5;\r\n * myCustomState.properties.strokeOpacity = 0.8;\r\n * sprite.setState(\"mystate\");\r\n * ```\r\n *\r\n * @see {@link https://www.amcharts.com/docs/v4/concepts/states/}\r\n * @important\r\n */\n\nvar SpriteState =\n/** @class */\nfunction (_super) {\n  __extends(SpriteState, _super);\n  /**\r\n   * Constructor\r\n   */\n\n\n  function SpriteState() {\n    var _this = // Init\n    _super.call(this) || this;\n    /**\r\n     * Duration of the transition to this state. 0 means instantenous transition.\r\n     * Any number means the [[Sprite]] will transit smoothly to this state,\r\n     * animating all animatable properties.\r\n     *\r\n     * @default 0\r\n     * @see {@link https://www.amcharts.com/docs/v4/concepts/animations/} for more info about animations\r\n     */\n\n\n    _this.transitionDuration = 0;\n    /**\r\n     * Easing function to use when transitioning to this state.\r\n     *\r\n     * @default cubicOut\r\n     * @see {@link Ease}\r\n     * @see {@link https://www.amcharts.com/docs/v4/concepts/animations/} for more info about animations\r\n     */\n\n    _this.transitionEasing = $ease.cubicOut;\n    /**\r\n     * Collection of properties and their values that should be applied to [[Sprite]]\r\n     * when switching to this State.\r\n     *\r\n     * The property values set on a [[SpriteState]] will override the ones set\r\n     * directly on a [[Sprite]].\r\n     */\n\n    _this.properties = {};\n    /**\r\n     * A collection of key/value pairs that can be used to bind specific Sprite\r\n     * properties to [[DataItem]].\r\n     *\r\n     * For example: `fill` property can be bound to `myCustomColor` field in\r\n     * DataItem. The Sprite will automatically get the value for `fill` from its\r\n     * DataItem.\r\n     *\r\n     * SpriteState-specific binding will override binding set directly on\r\n     * [[Sprite]]. I.e. you can make Sprite use different fill color on hover by\r\n     * adding a `fill` binding to a different DataItem key for Sprite's \"hover\"\r\n     * state object.\r\n     *\r\n     * @see {@link Sprite}\r\n     */\n\n    _this.propertyFields = {}; //public propertyFields: Dictionary<keyof this[\"_properties\"], string> = new Dictionary<keyof this[\"_properties\"], string>();;\n\n    /**\r\n     * A list of [[Filter]] elements to be applied to the relative [[Sprite]]\r\n     * when switching to this State.\r\n     *\r\n     * @param {List}\r\n     */\n\n    _this.filters = new List();\n    /**\r\n     * Identifies if this object is a \"template\" and should not be treated as\r\n     * real object that is drawn or actually used in the chart.\r\n     */\n\n    _this.isTemplate = false;\n    _this.className = \"SpriteState\"; // Make filter list disposable\n\n    _this._disposers.push(new ListDisposer(_this.filters)); // Apply theme\n\n\n    _this.applyTheme();\n\n    return _this;\n  }\n\n  Object.defineProperty(SpriteState.prototype, \"adapter\", {\n    /**\r\n     * Holds Adapter.\r\n     */\n    get: function () {\n      var _this = this;\n\n      if (!this._adapterO) {\n        this._adapterO = new Adapter(this); // Decorate adapter with events so that we can apply its settings whenever\n        // it is modified\n\n        this._adapterO.events.on(\"inserted\", function (ev) {\n          _this[ev.newValue.key] = _this[ev.newValue.key];\n        }, undefined, false);\n\n        this._adapterO.events.on(\"removed\", function (ev) {\n          _this[ev.newValue.key] = _this[ev.newValue.key];\n        }, undefined, false);\n      }\n\n      return this._adapterO;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\r\n   * Returns [[Sprite]] element's property value.\r\n   *\r\n   * Will check if there are any bindings with [[DataItem]] and if there are\r\n   * any method callbacks set up for the specific property.\r\n   *\r\n   * @param propertyName  Property name\r\n   * @return Property value\r\n   */\n\n  SpriteState.prototype.getPropertyValue = function (propertyName) {\n    var propValue = this.properties[propertyName];\n    var sprite = this.sprite;\n\n    if (sprite) {\n      var fieldName = this.propertyFields[propertyName];\n\n      if ($type.hasValue(fieldName)) {\n        if (sprite.dataItem) {\n          propValue = sprite.dataItem.dataContext[fieldName];\n        }\n\n        if (propValue == undefined) {\n          propValue = \"__unset\";\n        }\n      } // Apply adapters\n      // If the value itself is undefined, we're going to pass in Sprite's\n      // value to adapters\n      // @todo get rid of <any>\n\n\n      if (!$type.hasValue(propValue)) {\n        var spriteValue = sprite.getPropertyValue(propertyName);\n\n        if (this._adapterO) {\n          propValue = this._adapterO.apply(propertyName, spriteValue);\n        } else {\n          propValue = spriteValue;\n        }\n\n        if (propValue == spriteValue) {\n          propValue = undefined;\n        }\n      } else {\n        if (this._adapterO) {\n          propValue = this._adapterO.apply(propertyName, propValue);\n        }\n      }\n      /*let method = this.propertyMethods.getKey(propertyName);\r\n      if (method) {\r\n          propValue = method(sprite, propertyName);\r\n      }*/\n\n    }\n\n    return propValue;\n  };\n  /**\r\n   * Copies all property and style values from another [[SpriteState]] object.\r\n   *\r\n   * @param source  Source [[SpriteState]]\r\n   */\n\n\n  SpriteState.prototype.copyFrom = function (source) {\n    if (source && source != this) {\n      this.transitionDuration = source.transitionDuration;\n      this.transitionEasing = source.transitionEasing;\n      $utils.copyProperties(source.properties, this.properties);\n      $utils.copyProperties(source.propertyFields, this.propertyFields);\n      this.filters.copyFrom(source.filters);\n\n      if (source._adapterO) {\n        this.adapter.copyFrom(source._adapterO);\n      }\n    }\n  };\n\n  Object.defineProperty(SpriteState.prototype, \"allValues\", {\n    /**\r\n     * Returns all values that should be applied by the SpriteState.\r\n     *\r\n     * It takes adapters into account.\r\n     *\r\n     * @ignore Exclude from docs\r\n     * @return Properties\r\n     * @todo Add adapter values\r\n     * @todo proper type this[\"_properties\"]\r\n     */\n    get: function () {\n      var _this = this; // Init return value\n\n\n      var res = {}; // Apply adapters to all values\n\n      $object.each(this.properties, function (prop, value) {\n        res[prop] = _this.getPropertyValue(prop);\n      }); // Cycle through all adapters and add values for missing properties\n\n      if (this._adapterO) {\n        var keys = this._adapterO.keys();\n\n        $object.each(keys, function (_x, prop) {\n          var value = _this.getPropertyValue(prop);\n\n          res[prop] = value;\n        });\n      } // Cycle through all property fileds and add values for missing properties\n\n\n      var propertyFields = this.propertyFields;\n      $object.each(propertyFields, function (prop) {\n        var value = _this.getPropertyValue(prop);\n\n        res[prop] = value;\n      });\n      return res;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\r\n   * Resets the State to initial state - no values or Filters applied.\r\n   */\n\n  SpriteState.prototype.reset = function () {\n    this.properties = {};\n    this.filters.clear();\n  };\n  /**\r\n   * Processes JSON-based config before it is applied to the object.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param config  Config\r\n   */\n\n\n  SpriteState.prototype.processConfig = function (config) {\n    if ($type.hasValue(config) && $type.hasValue(config[\"properties\"])) {\n      $object.each(config[\"properties\"], function (key, value) {\n        if ($type.isString(value)) {\n          if (value.match(/^[0-9.\\-]+\\%$/)) {\n            config[\"properties\"][key] = percent($type.toNumber(value));\n          } else if (value.match(/^\\#[0-9abcdef]{3,}$/i)) {\n            config[\"properties\"][key] = toColor(value);\n          }\n        }\n      });\n    }\n\n    _super.prototype.processConfig.call(this, config);\n  };\n  /**\r\n   * Adds easing functions to \"function\" fields.\r\n   *\r\n   * @param field  Field name\r\n   * @return Assign as function?\r\n   */\n\n\n  SpriteState.prototype.asFunction = function (field) {\n    return field == \"transitionEasing\" || _super.prototype.asIs.call(this, field);\n  };\n\n  return SpriteState;\n}(BaseObject);\n\nexport { SpriteState };\n/**\r\n * Register class in system, so that it can be instantiated using its name from\r\n * anywhere.\r\n *\r\n * @ignore\r\n */\n\nregistry.registeredClasses[\"SpriteState\"] = SpriteState;","map":{"version":3,"names":["__extends","BaseObject","registry","Adapter","List","ListDisposer","toColor","percent","$utils","$ease","$object","$type","SpriteState","_super","_this","call","transitionDuration","transitionEasing","cubicOut","properties","propertyFields","filters","isTemplate","className","_disposers","push","applyTheme","Object","defineProperty","prototype","get","_adapterO","events","on","ev","newValue","key","undefined","enumerable","configurable","getPropertyValue","propertyName","propValue","sprite","fieldName","hasValue","dataItem","dataContext","spriteValue","apply","copyFrom","source","copyProperties","adapter","res","each","prop","value","keys","_x","reset","clear","processConfig","config","isString","match","toNumber","asFunction","field","asIs","registeredClasses"],"sources":["D:/APPLICATION/UI/UPL/NEW/node_modules/@amcharts/amcharts4/.internal/core/SpriteState.js"],"sourcesContent":["/**\r\n * Module contains functionality related to [[Sprite]] states.\r\n */\r\nimport { __extends } from \"tslib\";\r\n/**\r\n * ============================================================================\r\n * IMPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\r\nimport { BaseObject } from \"./Base\";\r\nimport { registry } from \"./Registry\";\r\nimport { Adapter } from \"./utils/Adapter\";\r\nimport { List, ListDisposer } from \"./utils/List\";\r\nimport { toColor } from \"./utils/Color\";\r\nimport { percent } from \"./utils/Percent\";\r\nimport * as $utils from \"./utils/Utils\";\r\nimport * as $ease from \"./utils/Ease\";\r\nimport * as $object from \"./utils/Object\";\r\nimport * as $type from \"./utils/Type\";\r\n/**\r\n * Defines a state for [[Sprite]].\r\n *\r\n * A \"state\" is a special object that has all the same properties as the\r\n * [[Sprite]] of the same type, and which can be used to quickly apply a set\r\n * of property values. (set state)\r\n *\r\n * When [[Sprite]] (or any object that extends Sprite) is created it creates a\r\n * \"default\" state. You can modify the \"default\" state so that when the Sprite\r\n * returns to default state certain properties are added.\r\n *\r\n * Default state can be accessed using Sprite's `defaultState` getter.\r\n *\r\n * ```TypeScript\r\n * sprite.defaultState.properties.fillOpacity = 0.5;\r\n * ```\r\n * ```JavaScript\r\n * sprite.defaultState.properties.fillOpacity = 0.5;\r\n * ```\r\n * ```JSON\r\n * {\r\n *   // ...\r\n *   \"defaultState\": {\r\n *     \"properties\": {\r\n *       \"fillOpacity\": 0.5\r\n *     }\r\n *   }\r\n * }\r\n * ```\r\n *\r\n * If Sprite is \"hoverable\", it automatically adds a \"hover\" state, which is\r\n * applied when it has a cursor over it.\r\n *\r\n * ```TypeScript\r\n * let hoverstate = sprite.states.create(\"hover\");\r\n * hoverstate.properties.fillOpacity = 1;\r\n * ```\r\n * ```JavaScript\r\n * var hoverstate = sprite.states.create(\"hover\");\r\n * hoverstate.properties.fillOpacity = 1;\r\n * ```\r\n * ```JSON\r\n * {\r\n *   // ...\r\n *   \"states\": {\r\n *     \"hover\": {\r\n *       \"properties\": {\r\n *         \"fillOpacity\": 0.5\r\n *       }\r\n *     }\r\n *   }\r\n * }\r\n * ```\r\n *\r\n * The above will automatically apply \"hover\" state when the Sprite is hovered,\r\n * thus will set its `fillOpacity` property to 1, and will reset it to 0.5 when\r\n * it's no longer hovered.\r\n *\r\n * Every object that inherits from [[Sprite]] can and will add their own\r\n * properties to the available list.\r\n *\r\n * User can create their own states, and apply them as needed:\r\n *\r\n * ```TypeScript\r\n * let myCustomState = sprite.states.create(\"mystate\");\r\n * myCustomState.properties.fillOpacity = 0.5;\r\n * myCustomState.properties.strokeOpacity = 0.8;\r\n * sprite.setState(\"mystate\");\r\n * ```\r\n * ```JavaScript\r\n * var myCustomState = sprite.states.create(\"mystate\");\r\n * myCustomState.properties.fillOpacity = 0.5;\r\n * myCustomState.properties.strokeOpacity = 0.8;\r\n * sprite.setState(\"mystate\");\r\n * ```\r\n *\r\n * @see {@link https://www.amcharts.com/docs/v4/concepts/states/}\r\n * @important\r\n */\r\nvar SpriteState = /** @class */ (function (_super) {\r\n    __extends(SpriteState, _super);\r\n    /**\r\n     * Constructor\r\n     */\r\n    function SpriteState() {\r\n        var _this = \r\n        // Init\r\n        _super.call(this) || this;\r\n        /**\r\n         * Duration of the transition to this state. 0 means instantenous transition.\r\n         * Any number means the [[Sprite]] will transit smoothly to this state,\r\n         * animating all animatable properties.\r\n         *\r\n         * @default 0\r\n         * @see {@link https://www.amcharts.com/docs/v4/concepts/animations/} for more info about animations\r\n         */\r\n        _this.transitionDuration = 0;\r\n        /**\r\n         * Easing function to use when transitioning to this state.\r\n         *\r\n         * @default cubicOut\r\n         * @see {@link Ease}\r\n         * @see {@link https://www.amcharts.com/docs/v4/concepts/animations/} for more info about animations\r\n         */\r\n        _this.transitionEasing = $ease.cubicOut;\r\n        /**\r\n         * Collection of properties and their values that should be applied to [[Sprite]]\r\n         * when switching to this State.\r\n         *\r\n         * The property values set on a [[SpriteState]] will override the ones set\r\n         * directly on a [[Sprite]].\r\n         */\r\n        _this.properties = {};\r\n        /**\r\n         * A collection of key/value pairs that can be used to bind specific Sprite\r\n         * properties to [[DataItem]].\r\n         *\r\n         * For example: `fill` property can be bound to `myCustomColor` field in\r\n         * DataItem. The Sprite will automatically get the value for `fill` from its\r\n         * DataItem.\r\n         *\r\n         * SpriteState-specific binding will override binding set directly on\r\n         * [[Sprite]]. I.e. you can make Sprite use different fill color on hover by\r\n         * adding a `fill` binding to a different DataItem key for Sprite's \"hover\"\r\n         * state object.\r\n         *\r\n         * @see {@link Sprite}\r\n         */\r\n        _this.propertyFields = {};\r\n        //public propertyFields: Dictionary<keyof this[\"_properties\"], string> = new Dictionary<keyof this[\"_properties\"], string>();;\r\n        /**\r\n         * A list of [[Filter]] elements to be applied to the relative [[Sprite]]\r\n         * when switching to this State.\r\n         *\r\n         * @param {List}\r\n         */\r\n        _this.filters = new List();\r\n        /**\r\n         * Identifies if this object is a \"template\" and should not be treated as\r\n         * real object that is drawn or actually used in the chart.\r\n         */\r\n        _this.isTemplate = false;\r\n        _this.className = \"SpriteState\";\r\n        // Make filter list disposable\r\n        _this._disposers.push(new ListDisposer(_this.filters));\r\n        // Apply theme\r\n        _this.applyTheme();\r\n        return _this;\r\n    }\r\n    Object.defineProperty(SpriteState.prototype, \"adapter\", {\r\n        /**\r\n         * Holds Adapter.\r\n         */\r\n        get: function () {\r\n            var _this = this;\r\n            if (!this._adapterO) {\r\n                this._adapterO = new Adapter(this);\r\n                // Decorate adapter with events so that we can apply its settings whenever\r\n                // it is modified\r\n                this._adapterO.events.on(\"inserted\", function (ev) {\r\n                    _this[ev.newValue.key] = _this[ev.newValue.key];\r\n                }, undefined, false);\r\n                this._adapterO.events.on(\"removed\", function (ev) {\r\n                    _this[ev.newValue.key] = _this[ev.newValue.key];\r\n                }, undefined, false);\r\n            }\r\n            return this._adapterO;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    /**\r\n     * Returns [[Sprite]] element's property value.\r\n     *\r\n     * Will check if there are any bindings with [[DataItem]] and if there are\r\n     * any method callbacks set up for the specific property.\r\n     *\r\n     * @param propertyName  Property name\r\n     * @return Property value\r\n     */\r\n    SpriteState.prototype.getPropertyValue = function (propertyName) {\r\n        var propValue = this.properties[propertyName];\r\n        var sprite = this.sprite;\r\n        if (sprite) {\r\n            var fieldName = this.propertyFields[propertyName];\r\n            if ($type.hasValue(fieldName)) {\r\n                if (sprite.dataItem) {\r\n                    propValue = sprite.dataItem.dataContext[fieldName];\r\n                }\r\n                if (propValue == undefined) {\r\n                    propValue = \"__unset\";\r\n                }\r\n            }\r\n            // Apply adapters\r\n            // If the value itself is undefined, we're going to pass in Sprite's\r\n            // value to adapters\r\n            // @todo get rid of <any>\r\n            if (!$type.hasValue(propValue)) {\r\n                var spriteValue = sprite.getPropertyValue(propertyName);\r\n                if (this._adapterO) {\r\n                    propValue = this._adapterO.apply(propertyName, spriteValue);\r\n                }\r\n                else {\r\n                    propValue = spriteValue;\r\n                }\r\n                if (propValue == spriteValue) {\r\n                    propValue = undefined;\r\n                }\r\n            }\r\n            else {\r\n                if (this._adapterO) {\r\n                    propValue = this._adapterO.apply(propertyName, propValue);\r\n                }\r\n            }\r\n            /*let method = this.propertyMethods.getKey(propertyName);\r\n            if (method) {\r\n                propValue = method(sprite, propertyName);\r\n            }*/\r\n        }\r\n        return propValue;\r\n    };\r\n    /**\r\n     * Copies all property and style values from another [[SpriteState]] object.\r\n     *\r\n     * @param source  Source [[SpriteState]]\r\n     */\r\n    SpriteState.prototype.copyFrom = function (source) {\r\n        if (source && source != this) {\r\n            this.transitionDuration = source.transitionDuration;\r\n            this.transitionEasing = source.transitionEasing;\r\n            $utils.copyProperties(source.properties, this.properties);\r\n            $utils.copyProperties(source.propertyFields, this.propertyFields);\r\n            this.filters.copyFrom(source.filters);\r\n            if (source._adapterO) {\r\n                this.adapter.copyFrom(source._adapterO);\r\n            }\r\n        }\r\n    };\r\n    Object.defineProperty(SpriteState.prototype, \"allValues\", {\r\n        /**\r\n         * Returns all values that should be applied by the SpriteState.\r\n         *\r\n         * It takes adapters into account.\r\n         *\r\n         * @ignore Exclude from docs\r\n         * @return Properties\r\n         * @todo Add adapter values\r\n         * @todo proper type this[\"_properties\"]\r\n         */\r\n        get: function () {\r\n            var _this = this;\r\n            // Init return value\r\n            var res = {};\r\n            // Apply adapters to all values\r\n            $object.each(this.properties, function (prop, value) {\r\n                res[prop] = _this.getPropertyValue(prop);\r\n            });\r\n            // Cycle through all adapters and add values for missing properties\r\n            if (this._adapterO) {\r\n                var keys = this._adapterO.keys();\r\n                $object.each(keys, function (_x, prop) {\r\n                    var value = _this.getPropertyValue(prop);\r\n                    res[prop] = value;\r\n                });\r\n            }\r\n            // Cycle through all property fileds and add values for missing properties\r\n            var propertyFields = this.propertyFields;\r\n            $object.each(propertyFields, function (prop) {\r\n                var value = _this.getPropertyValue(prop);\r\n                res[prop] = value;\r\n            });\r\n            return res;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    /**\r\n     * Resets the State to initial state - no values or Filters applied.\r\n     */\r\n    SpriteState.prototype.reset = function () {\r\n        this.properties = {};\r\n        this.filters.clear();\r\n    };\r\n    /**\r\n     * Processes JSON-based config before it is applied to the object.\r\n     *\r\n     * @ignore Exclude from docs\r\n     * @param config  Config\r\n     */\r\n    SpriteState.prototype.processConfig = function (config) {\r\n        if ($type.hasValue(config) && $type.hasValue(config[\"properties\"])) {\r\n            $object.each(config[\"properties\"], function (key, value) {\r\n                if ($type.isString(value)) {\r\n                    if (value.match(/^[0-9.\\-]+\\%$/)) {\r\n                        config[\"properties\"][key] = percent($type.toNumber(value));\r\n                    }\r\n                    else if (value.match(/^\\#[0-9abcdef]{3,}$/i)) {\r\n                        config[\"properties\"][key] = toColor(value);\r\n                    }\r\n                }\r\n            });\r\n        }\r\n        _super.prototype.processConfig.call(this, config);\r\n    };\r\n    /**\r\n     * Adds easing functions to \"function\" fields.\r\n     *\r\n     * @param field  Field name\r\n     * @return Assign as function?\r\n     */\r\n    SpriteState.prototype.asFunction = function (field) {\r\n        return field == \"transitionEasing\" || _super.prototype.asIs.call(this, field);\r\n    };\r\n    return SpriteState;\r\n}(BaseObject));\r\nexport { SpriteState };\r\n/**\r\n * Register class in system, so that it can be instantiated using its name from\r\n * anywhere.\r\n *\r\n * @ignore\r\n */\r\nregistry.registeredClasses[\"SpriteState\"] = SpriteState;\r\n"],"mappings":"AAAA;AACA;AACA;AACA,SAASA,SAAT,QAA0B,OAA1B;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,SAASC,UAAT,QAA2B,QAA3B;AACA,SAASC,QAAT,QAAyB,YAAzB;AACA,SAASC,OAAT,QAAwB,iBAAxB;AACA,SAASC,IAAT,EAAeC,YAAf,QAAmC,cAAnC;AACA,SAASC,OAAT,QAAwB,eAAxB;AACA,SAASC,OAAT,QAAwB,iBAAxB;AACA,OAAO,KAAKC,MAAZ,MAAwB,eAAxB;AACA,OAAO,KAAKC,KAAZ,MAAuB,cAAvB;AACA,OAAO,KAAKC,OAAZ,MAAyB,gBAAzB;AACA,OAAO,KAAKC,KAAZ,MAAuB,cAAvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,IAAIC,WAAW;AAAG;AAAe,UAAUC,MAAV,EAAkB;EAC/Cb,SAAS,CAACY,WAAD,EAAcC,MAAd,CAAT;EACA;AACJ;AACA;;;EACI,SAASD,WAAT,GAAuB;IACnB,IAAIE,KAAK,GACT;IACAD,MAAM,CAACE,IAAP,CAAY,IAAZ,KAAqB,IAFrB;IAGA;AACR;AACA;AACA;AACA;AACA;AACA;AACA;;;IACQD,KAAK,CAACE,kBAAN,GAA2B,CAA3B;IACA;AACR;AACA;AACA;AACA;AACA;AACA;;IACQF,KAAK,CAACG,gBAAN,GAAyBR,KAAK,CAACS,QAA/B;IACA;AACR;AACA;AACA;AACA;AACA;AACA;;IACQJ,KAAK,CAACK,UAAN,GAAmB,EAAnB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"},"metadata":{},"sourceType":"module"}