{"ast":null,"code":"/**\r\n * Number formatting-related functionality.\r\n */\nimport { __extends } from \"tslib\";\nimport { Language } from \"../utils/Language\";\nimport { BaseObject } from \"../Base\";\nimport { getTextFormatter } from \"../formatters/TextFormatter\";\nimport { registry } from \"../Registry\";\nimport * as $strings from \"../utils/Strings\";\nimport * as $object from \"../utils/Object\";\nimport * as $utils from \"../utils/Utils\";\nimport * as $type from \"../utils/Type\";\nimport * as $math from \"../utils/Math\";\n/**\r\n * NumberFormatter class. Formats numbers according to specified formats.\r\n *\r\n * @todo Apply translations to suffixes/prefixes\r\n */\n\nvar NumberFormatter =\n/** @class */\nfunction (_super) {\n  __extends(NumberFormatter, _super);\n  /**\r\n   * Constructor\r\n   */\n\n\n  function NumberFormatter() {\n    var _this = _super.call(this) || this;\n    /**\r\n     * A base value for negative numbers. Will treat all numbers below this value\r\n     * as negative numbers.\r\n     */\n\n\n    _this._negativeBase = 0;\n    /**\r\n     * Holds number format.\r\n     *\r\n     * @default #,###.#####\r\n     */\n\n    _this._numberFormat = \"#,###.#####\";\n    /**\r\n     * Output format to produce. If the format calls for applying color to the\r\n     * formatted value, this setting will determine what markup to use: SVG or\r\n     * HTML.\r\n     *\r\n     * Available options: svg, html.\r\n     *\r\n     * @default \"svg\"\r\n     */\n\n    _this._outputFormat = \"svg\";\n    /**\r\n     * Any number smaller than this will be considered \"small\" number, which will\r\n     * trigger special formatting if \"a\" format modifier is used.\r\n     */\n\n    _this._smallNumberThreshold = 1.00;\n    _this._forceLTR = false;\n    _this.className = \"NumberFormatter\";\n\n    _this.applyTheme();\n\n    return _this;\n  }\n\n  NumberFormatter.prototype.dispose = function () {\n    _super.prototype.dispose.call(this);\n\n    if (this.language) {\n      this.language.dispose();\n    }\n  };\n\n  Object.defineProperty(NumberFormatter.prototype, \"language\", {\n    /**\r\n     * @return Language\r\n     */\n    get: function () {\n      if (!this._language) {\n        if (this.sprite) {\n          this._language = this.sprite.language;\n        } else {\n          this._language = new Language();\n        }\n      }\n\n      return this._language;\n    },\n\n    /**\r\n     * A reference to [[Language]] instance.\r\n     *\r\n     * Formatter will use language to translate various items, like number\r\n     * suffixes, etc.\r\n     *\r\n     * @param value  Language\r\n     */\n    set: function (value) {\n      this._language = value;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\r\n   * Formats the number according to specific format.\r\n   *\r\n   * @param value   Value to format\r\n   * @param format  Format to apply\r\n   * @return Formatted number\r\n   */\n\n  NumberFormatter.prototype.format = function (value, format, precision) {\n    // no format passed in or \"Number\"\n    if (typeof format === \"undefined\" || $type.isString(format) && format.toLowerCase() === \"number\") {\n      format = this._numberFormat;\n    } // Init return value\n\n\n    var formatted; // Cast to number just in case\n    // TODO: maybe use better casting\n\n    var source = Number(value); // Is it a built-in format or Intl.NumberFormatOptions\n\n    if ($type.isObject(format)) {\n      try {\n        if (this.intlLocales) {\n          return new Intl.NumberFormat(this.intlLocales, format).format(source);\n        } else {\n          return new Intl.NumberFormat(undefined, format).format(source);\n        }\n      } catch (e) {\n        return \"Invalid\";\n      }\n    } else {\n      // Clean format\n      format = $utils.cleanFormat(format); // Get format info (it will also deal with parser caching)\n\n      var info = this.parseFormat(format, this.language); // format and replace the number\n\n      var details = void 0;\n\n      if (source > this._negativeBase) {\n        details = info.positive;\n      } else if (source < this._negativeBase) {\n        details = info.negative;\n      } else {\n        details = info.zero;\n      } // Adjust precision\n\n\n      if ($type.hasValue(precision) && !details.mod) {\n        details = $object.clone(details);\n        details.decimals.active = source == 0 ? 0 : precision;\n      } // Format\n\n\n      formatted = details.template.split($strings.PLACEHOLDER).join(this.applyFormat(source, details));\n    }\n\n    if (this.forceLTR) {\n      formatted = \"‎\" + formatted;\n    }\n\n    return formatted;\n  };\n  /**\r\n   * Parses supplied format into structured object which can be used to format\r\n   * the number.\r\n   *\r\n   * @param format Format string, i.e. \"#,###.00\"\r\n   * @param language Language\r\n   */\n\n\n  NumberFormatter.prototype.parseFormat = function (format, language) {\n    var _this = this; // Check cache\n\n\n    var cached = this.getCache(format);\n\n    if ($type.hasValue(cached)) {\n      return cached;\n    } // init format parse info holder\n\n\n    var info = {\n      \"positive\": {\n        \"thousands\": {\n          \"active\": -1,\n          \"passive\": -1,\n          \"interval\": -1,\n          \"separator\": language.translateEmpty(\"_thousandSeparator\")\n        },\n        \"decimals\": {\n          \"active\": -1,\n          \"passive\": -1,\n          \"separator\": language.translateEmpty(\"_decimalSeparator\")\n        },\n        \"template\": \"\",\n        \"source\": \"\",\n        \"parsed\": false\n      },\n      \"negative\": {\n        \"thousands\": {\n          \"active\": -1,\n          \"passive\": -1,\n          \"interval\": -1,\n          \"separator\": language.translateEmpty(\"_thousandSeparator\")\n        },\n        \"decimals\": {\n          \"active\": -1,\n          \"passive\": -1,\n          \"separator\": language.translateEmpty(\"_decimalSeparator\")\n        },\n        \"template\": \"\",\n        \"source\": \"\",\n        \"parsed\": false\n      },\n      \"zero\": {\n        \"thousands\": {\n          \"active\": -1,\n          \"passive\": -1,\n          \"interval\": -1,\n          \"separator\": language.translateEmpty(\"_thousandSeparator\")\n        },\n        \"decimals\": {\n          \"active\": -1,\n          \"passive\": -1,\n          \"separator\": language.translateEmpty(\"_decimalSeparator\")\n        },\n        \"template\": \"\",\n        \"source\": \"\",\n        \"parsed\": false\n      }\n    }; // Escape double vertical bars (that mean display one vertical bar)\n\n    format = format.replace(\"||\", $strings.PLACEHOLDER2); // Split it up and deal with different formats\n\n    var parts = format.split(\"|\");\n    info.positive.source = parts[0];\n\n    if (typeof parts[2] === \"undefined\") {\n      info.zero = info.positive;\n    } else {\n      info.zero.source = parts[2];\n    }\n\n    if (typeof parts[1] === \"undefined\") {\n      info.negative = info.positive;\n    } else {\n      info.negative.source = parts[1];\n    } // Parse each\n\n\n    $object.each(info, function (part, item) {\n      // Already parsed\n      if (item.parsed) {\n        return;\n      } // Check cached\n\n\n      if (typeof _this.getCache(item.source) !== \"undefined\") {\n        info[part] = _this.getCache(item.source);\n        return;\n      } // Begin parsing\n\n\n      var partFormat = item.source; // Just \"Number\"?\n\n      if (partFormat.toLowerCase() === \"number\") {\n        partFormat = $type.isString(_this._numberFormat) ? _this._numberFormat : \"#,###.#####\";\n      } // Let TextFormatter split into chunks\n\n\n      var chunks = getTextFormatter().chunk(partFormat, true);\n\n      for (var i = 0; i < chunks.length; i++) {\n        var chunk = chunks[i]; // replace back double vertical bar\n\n        chunk.text = chunk.text.replace($strings.PLACEHOLDER2, \"|\");\n\n        if (chunk.type === \"value\") {\n          // Parse format\n          // Look for codes\n          var matches = chunk.text.match(/[#0.,]+[ ]?[abespABESP%!]?[abespABESP‰!]?/);\n\n          if (matches) {\n            if (matches === null || matches[0] === \"\") {\n              // no codes here - assume string\n              // nothing to do here\n              item.template += chunk.text;\n            } else {\n              // look for the format modifiers at the end\n              var mods = matches[0].match(/[abespABESP%‰!]{2}|[abespABESP%‰]{1}$/);\n\n              if (mods) {\n                item.mod = mods[0].toLowerCase();\n                item.modSpacing = matches[0].match(/[ ]{1}[abespABESP%‰!]{1}$/) ? true : false;\n              } // break the format up\n\n\n              var a = matches[0].split(\".\"); // Deal with thousands\n\n              if (a[0] === \"\") {// No directives for thousands\n                // Leave default settings (no formatting)\n              } else {\n                // Counts\n                item.thousands.active = (a[0].match(/0/g) || []).length;\n                item.thousands.passive = (a[0].match(/\\#/g) || []).length + item.thousands.active; // Separator interval\n\n                var b = a[0].split(\",\");\n\n                if (b.length === 1) {// No thousands separators\n                  // Do nothing\n                } else {\n                  // Use length fo the last chunk as thousands length\n                  item.thousands.interval = $type.getValue(b.pop()).length;\n\n                  if (item.thousands.interval === 0) {\n                    item.thousands.interval = -1;\n                  }\n                }\n              } // Deal with decimals\n\n\n              if (typeof a[1] === \"undefined\") {// No directives for decimals\n                // Leave at defaults (no formatting)\n              } else {\n                // Counts\n                item.decimals.active = (a[1].match(/0/g) || []).length;\n                item.decimals.passive = (a[1].match(/\\#/g) || []).length + item.decimals.active;\n              } // Add special code to template\n\n\n              item.template += chunk.text.split(matches[0]).join($strings.PLACEHOLDER);\n            }\n          }\n        } else {\n          // Quoted string - take it as it is\n          item.template += chunk.text;\n        }\n      } // Apply style formatting\n      //item.template = getTextFormatter().format(item.template, this.outputFormat);\n      // Save cache\n\n\n      _this.setCache(item.source, item); // Mark this as parsed\n\n\n      item.parsed = true;\n    }); // Save cache (the whole thing)\n\n    this.setCache(format, info);\n    return info;\n  };\n  /**\r\n   * Applies parsed format to a numeric value.\r\n   *\r\n   * @param value    Value\r\n   * @param details  Parsed format as returned by parseFormat()\r\n   * @return Formatted number\r\n   */\n\n\n  NumberFormatter.prototype.applyFormat = function (value, details) {\n    // Use absolute values\n    var negative = value < 0;\n    value = Math.abs(value); // Recalculate according to modifier\n\n    var prefix = \"\",\n        suffix = \"\";\n    var mods = details.mod ? details.mod.split(\"\") : [];\n\n    if (mods.indexOf(\"b\") !== -1) {\n      var a_1 = this.applyPrefix(value, this.bytePrefixes, mods.indexOf(\"!\") !== -1);\n      value = a_1[0];\n      prefix = a_1[1];\n      suffix = a_1[2];\n\n      if (details.modSpacing) {\n        suffix = \" \" + suffix;\n      }\n    } else if (mods.indexOf(\"a\") !== -1) {\n      var a_2 = this.applyPrefix(value, value < this.smallNumberThreshold ? this.smallNumberPrefixes : this.bigNumberPrefixes, mods.indexOf(\"!\") !== -1);\n      value = a_2[0];\n      prefix = a_2[1];\n      suffix = a_2[2];\n\n      if (details.modSpacing) {\n        suffix = \" \" + suffix;\n      }\n    } else if (mods.indexOf(\"p\") !== -1) {\n      var ol = Math.min(value.toString().length + 2, 21); //value *= 100;\n\n      value = parseFloat(value.toPrecision(ol));\n      prefix = this.language.translate(\"_percentPrefix\") || \"\";\n      suffix = this.language.translate(\"_percentSuffix\") || \"\";\n\n      if (prefix == \"\" && suffix == \"\") {\n        suffix = \"%\";\n      }\n    } else if (mods.indexOf(\"%\") !== -1) {\n      var ol = $math.min(value.toString().length + 2, 21);\n      value *= 100;\n      value = parseFloat(value.toPrecision(ol));\n      suffix = \"%\";\n    } else if (mods.indexOf(\"‰\") !== -1) {\n      var ol = $math.min(value.toString().length + 3, 21);\n      value *= 1000;\n      value = parseFloat(value.toPrecision(ol));\n      suffix = \"‰\";\n    } // Round to passive\n\n\n    if (mods.indexOf(\"e\") !== -1) {\n      // convert the value to exponential\n      var exp = void 0;\n\n      if (details.decimals.passive >= 0) {\n        exp = value.toExponential(details.decimals.passive).split(\"e\");\n      } else {\n        exp = value.toExponential().split(\"e\");\n      }\n\n      value = Number(exp[0]);\n      suffix = \"e\" + exp[1];\n\n      if (details.modSpacing) {\n        suffix = \" \" + suffix;\n      }\n    } else if (details.decimals.passive === 0) {\n      value = Math.round(value);\n    } else if (details.decimals.passive > 0) {\n      var d = Math.pow(10, details.decimals.passive);\n      value = Math.round(value * d) / d;\n    } // Init return value\n\n\n    var res = \"\"; // Calc integer and decimal parts\n\n    var a = $utils.numberToString(value).split(\".\"); // Format integers\n\n    var ints = a[0]; // Pad integers to active length\n\n    if (ints.length < details.thousands.active) {\n      ints = Array(details.thousands.active - ints.length + 1).join(\"0\") + ints;\n    } // Insert thousands separators\n\n\n    if (details.thousands.interval > 0) {\n      var ip = [];\n      var intsr = ints.split(\"\").reverse().join(\"\");\n\n      for (var i = 0, len = ints.length; i <= len; i += details.thousands.interval) {\n        var c = intsr.substr(i, details.thousands.interval).split(\"\").reverse().join(\"\");\n\n        if (c !== \"\") {\n          ip.unshift(c);\n        }\n      }\n\n      ints = ip.join(details.thousands.separator);\n    } // Add integers\n\n\n    res += ints; // Add decimals\n\n    if (a.length === 1) {\n      a.push(\"\");\n    }\n\n    var decs = a[1]; // Fill zeros?\n\n    if (decs.length < details.decimals.active) {\n      decs += Array(details.decimals.active - decs.length + 1).join(\"0\");\n    }\n\n    if (decs !== \"\") {\n      res += details.decimals.separator + decs;\n    } // Can't have empty return value\n\n\n    if (res === \"\") {\n      res = \"0\";\n    } // Add minus sign back\n\n\n    if (value !== 0 && negative && mods.indexOf(\"s\") === -1) {\n      res = \"-\" + res;\n    } // Add suffixes/prefixes\n\n\n    if (prefix) {\n      res = prefix + res;\n    }\n\n    if (suffix) {\n      res += suffix;\n    }\n\n    return res;\n  };\n  /**\r\n   * Chooses appropriate prefix and suffix based on the passed in rules.\r\n   *\r\n   * @param  value     Value\r\n   * @param  prefixes  Prefix array\r\n   * @param  force     Force application of a first prefix (@sice 4.5.4)\r\n   * @return Result\r\n   */\n\n\n  NumberFormatter.prototype.applyPrefix = function (value, prefixes, force) {\n    if (force === void 0) {\n      force = false;\n    }\n\n    var newvalue = value;\n    var prefix = \"\";\n    var suffix = \"\";\n    var applied = false;\n    var k = 1;\n\n    for (var i = 0, len = prefixes.length; i < len; i++) {\n      if (prefixes[i].number <= value) {\n        if (prefixes[i].number === 0) {\n          newvalue = 0;\n        } else {\n          newvalue = value / prefixes[i].number;\n          k = prefixes[i].number;\n        }\n\n        prefix = prefixes[i].prefix;\n        suffix = prefixes[i].suffix;\n        applied = true;\n      }\n    }\n\n    if (!applied && force && prefixes.length && value != 0) {\n      // Prefix was not applied. Use the first prefix.\n      newvalue = value / prefixes[0].number;\n      prefix = prefixes[0].prefix;\n      suffix = prefixes[0].suffix;\n      applied = true;\n    }\n\n    if (applied) {\n      newvalue = parseFloat(newvalue.toPrecision($math.min(k.toString().length + Math.floor(newvalue).toString().replace(/[^0-9]*/g, \"\").length, 21)));\n    }\n\n    return [newvalue, prefix, suffix];\n  };\n  /**\r\n   * Invalidates the parent [[Sprite]] object.\r\n   */\n\n\n  NumberFormatter.prototype.invalidateSprite = function () {\n    if (this.sprite) {\n      this.sprite.invalidate();\n    }\n  };\n\n  Object.defineProperty(NumberFormatter.prototype, \"numberFormat\", {\n    /**\r\n     * @return A format to use for number formatting\r\n     */\n    get: function () {\n      return this._numberFormat;\n    },\n\n    /**\r\n     * Number format.\r\n     *\r\n     * @default \"#,###.#####\"\r\n     * @see {@link https://www.amcharts.com/docs/v4/concepts/formatters/formatting-numbers/} Tutorial on number formatting\r\n     * @param format  A format to use for number formatting\r\n     */\n    set: function (format) {\n      this._numberFormat = format;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(NumberFormatter.prototype, \"intlLocales\", {\n    /**\r\n     * @return Date format\r\n     */\n    get: function () {\n      return this._intlLocales;\n    },\n\n    /**\r\n     * Locales if you are using date formats in `Intl.NumberFormatOptions` syntax.\r\n     *\r\n     * @see (@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/NumberFormat) about using Intl for number formatting\r\n     * @param value Locales\r\n     */\n    set: function (value) {\n      this._intlLocales = value;\n      this.invalidateSprite();\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(NumberFormatter.prototype, \"negativeBase\", {\n    /**\r\n     * @return A format to use for number formatting\r\n     */\n    get: function () {\n      return this._negativeBase;\n    },\n\n    /**\r\n     * Negative base for negative numbers.\r\n     *\r\n     * @default 0\r\n     * @see {@link https://www.amcharts.com/docs/v4/concepts/formatters/formatting-numbers/} Tutorial on number formatting\r\n     * @param format  A format to use for number formatting\r\n     */\n    set: function (value) {\n      this._negativeBase = value;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(NumberFormatter.prototype, \"bigNumberPrefixes\", {\n    /**\r\n     * @return Prefixes for big numbers\r\n     */\n    get: function () {\n      if (!$type.hasValue(this._bigNumberPrefixes)) {\n        this._bigNumberPrefixes = [{\n          \"number\": 1e+3,\n          \"suffix\": this.language.translate(\"_big_number_suffix_3\")\n        }, {\n          \"number\": 1e+6,\n          \"suffix\": this.language.translate(\"_big_number_suffix_6\")\n        }, {\n          \"number\": 1e+9,\n          \"suffix\": this.language.translate(\"_big_number_suffix_9\")\n        }, {\n          \"number\": 1e+12,\n          \"suffix\": this.language.translate(\"_big_number_suffix_12\")\n        }, {\n          \"number\": 1e+15,\n          \"suffix\": this.language.translate(\"_big_number_suffix_15\")\n        }, {\n          \"number\": 1e+18,\n          \"suffix\": this.language.translate(\"_big_number_suffix_18\")\n        }, {\n          \"number\": 1e+21,\n          \"suffix\": this.language.translate(\"_big_number_suffix_21\")\n        }, {\n          \"number\": 1e+24,\n          \"suffix\": this.language.translate(\"_big_number_suffix_24\")\n        }];\n      }\n\n      return this._bigNumberPrefixes;\n    },\n\n    /**\r\n     * Prefixes for big numbers.\r\n     *\r\n     * It's an array of objects of number/prefix pairs.\r\n     *\r\n     * ```JSON\r\n     * [\r\n     *   { \"number\": 1e+3, \"suffix\": \"K\" },\r\n     *   { \"number\": 1e+6, \"suffix\": \"M\" },\r\n     *   { \"number\": 1e+9, \"suffix\": \"G\" },\r\n     *   { \"number\": 1e+12, \"suffix\": \"T\" },\r\n     *   { \"number\": 1e+15, \"suffix\": \"P\" },\r\n     *   { \"number\": 1e+18, \"suffix\": \"E\" },\r\n     *   { \"number\": 1e+21, \"suffix\": \"Z\" },\r\n     *   { \"number\": 1e+24, \"suffix\": \"Y\" }\r\n     * ]\r\n     * ```\r\n     *\r\n     * If the number is bigger than the `number` ir will be converted to the\r\n     * appropriate bigger number with prefix.\r\n     *\r\n     * E.g. as per above `1500` will be converted to `1.5K`.\r\n     *\r\n     * Please note that for this transformation to be enabled, you need to\r\n     * enable it specific modifier in your format setting.\r\n     *\r\n     * The modifier for big/small number modification is \"a\":\r\n     *\r\n     * ```Text\r\n     * {myfield.formatNumber(\"#,###.00a\")}\r\n     * ```\r\n     *\r\n     * @see {@link https://www.amcharts.com/docs/v4/concepts/formatters/formatting-numbers/} Tutorial on number formatting\r\n     * @param prefixes  Prefixes for big numbers\r\n     */\n    set: function (prefixes) {\n      this._bigNumberPrefixes = prefixes;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(NumberFormatter.prototype, \"smallNumberPrefixes\", {\n    /**\r\n     * @return Prefixes for small numbers\r\n     */\n    get: function () {\n      if (!$type.hasValue(this._smallNumberPrefixes)) {\n        this._smallNumberPrefixes = [{\n          \"number\": 1e-24,\n          \"suffix\": this.language.translate(\"_small_number_suffix_24\")\n        }, {\n          \"number\": 1e-21,\n          \"suffix\": this.language.translate(\"_small_number_suffix_21\")\n        }, {\n          \"number\": 1e-18,\n          \"suffix\": this.language.translate(\"_small_number_suffix_18\")\n        }, {\n          \"number\": 1e-15,\n          \"suffix\": this.language.translate(\"_small_number_suffix_15\")\n        }, {\n          \"number\": 1e-12,\n          \"suffix\": this.language.translate(\"_small_number_suffix_12\")\n        }, {\n          \"number\": 1e-9,\n          \"suffix\": this.language.translate(\"_small_number_suffix_9\")\n        }, {\n          \"number\": 1e-6,\n          \"suffix\": this.language.translate(\"_small_number_suffix_6\")\n        }, {\n          \"number\": 1e-3,\n          \"suffix\": this.language.translate(\"_small_number_suffix_3\")\n        }];\n      }\n\n      return this._smallNumberPrefixes;\n    },\n\n    /**\r\n     * Prefixes for big numbers.\r\n     *\r\n     * It's an array of objects of number/prefix pairs.\r\n     *\r\n     * ```JSON\r\n     * [\r\n     *   { \"number\": 1e-24, \"suffix\": \"y\" },\r\n     *   { \"number\": 1e-21, \"suffix\": \"z\" },\r\n     *   { \"number\": 1e-18, \"suffix\": \"a\" },\r\n     *   { \"number\": 1e-15, \"suffix\": \"f\" },\r\n     *   { \"number\": 1e-12, \"suffix\": \"p\" },\r\n     *   { \"number\": 1e-9, \"suffix\": \"n\" },\r\n     *   { \"number\": 1e-6, \"suffix\": \"μ\" },\r\n     *   { \"number\": 1e-3, \"suffix\": \"m\" }\r\n     * ]\r\n     * ```\r\n     *\r\n     * If the number is smaller than the `number` ir will be converted to the\r\n     * appropriate smaller number with prefix.\r\n     *\r\n     * E.g. as per above `0.0015` will be converted to `1.5m`.\r\n     *\r\n     * Please note that for this transformation to be enabled, you need to\r\n     * enable it specific modifier in your format setting.\r\n     *\r\n     * The modifier for big/small number modification is \"a\":\r\n     *\r\n     * ```Text\r\n     * {myfield.formatNumber(\"#,###.00a\")}\r\n     * ```\r\n     *\r\n     * IMPORTANT: The order of the suffixes is important. The list must start\r\n     * from the smallest number and work towards bigger ones.\r\n     *\r\n     * @see {@link https://www.amcharts.com/docs/v4/concepts/formatters/formatting-numbers/} Tutorial on number formatting\r\n     * @param prefixes  Prefixes for small numbers\r\n     */\n    set: function (prefixes) {\n      this._smallNumberPrefixes = prefixes;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(NumberFormatter.prototype, \"smallNumberThreshold\", {\n    /**\r\n     * @return Small number threshold\r\n     */\n    get: function () {\n      return this._smallNumberThreshold;\n    },\n\n    /**\r\n     * Any number smaller than this will be considered \"small\" number, which will\r\n     * trigger special formatting if \"a\" format modifier is used.\r\n     *\r\n     * @since 4.6.8\r\n     * @param  value  Small number threshold\r\n     */\n    set: function (value) {\n      this._smallNumberThreshold = value;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(NumberFormatter.prototype, \"bytePrefixes\", {\n    /**\r\n     * @return Prefixes for byte-size formatting\r\n     */\n    get: function () {\n      if (!$type.hasValue(this._bytePrefixes)) {\n        this._bytePrefixes = [{\n          \"number\": 1,\n          suffix: this.language.translate(\"_byte_suffix_B\")\n        }, {\n          \"number\": 1024,\n          suffix: this.language.translate(\"_byte_suffix_KB\")\n        }, {\n          \"number\": 1048576,\n          suffix: this.language.translate(\"_byte_suffix_MB\")\n        }, {\n          \"number\": 1073741824,\n          suffix: this.language.translate(\"_byte_suffix_GB\")\n        }, {\n          \"number\": 1099511627776,\n          suffix: this.language.translate(\"_byte_suffix_TB\")\n        }, {\n          \"number\": 1125899906842624,\n          suffix: this.language.translate(\"_byte_suffix_PB\")\n        }];\n      }\n\n      return this._bytePrefixes;\n    },\n\n    /**\r\n     * Basically the same as `bigNumberPrefixes`, except base for calculation\r\n     * is not thousand but byte (1024).\r\n     *\r\n     * The modifier is \"b\".\r\n     *\r\n     *  ```Text\r\n     * {myfield.formatNumber(\"#,###.00b\")}\r\n     * ```\r\n     *\r\n     * The above `2048` will change to `2K`.\r\n     *\r\n     * @see {@link https://www.amcharts.com/docs/v4/concepts/formatters/formatting-numbers/} Tutorial on number formatting\r\n     * @param prefixes  Prefixes for byte-size formatting\r\n     */\n    set: function (prefixes) {\n      this._bytePrefixes = prefixes;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(NumberFormatter.prototype, \"outputFormat\", {\n    /**\r\n     * @ignore Exclude from docs\r\n     * @return Output format\r\n     */\n    get: function () {\n      return this._outputFormat;\n    },\n\n    /**\r\n     * Ooutput format: \"svg\" or \"html\".\r\n     *\r\n     * @ignore Exclude from docs\r\n     * @param value  Output format\r\n     */\n    set: function (outputFormat) {\n      this._outputFormat = outputFormat.toLowerCase();\n      this.invalidateSprite();\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(NumberFormatter.prototype, \"forceLTR\", {\n    get: function () {\n      return this._forceLTR;\n    },\n    set: function (value) {\n      this._forceLTR = value;\n      this.invalidateSprite();\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\r\n   * Replaces brackets with temporary placeholders.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param text  Input text\r\n   * @return Escaped text\r\n   */\n\n  NumberFormatter.prototype.escape = function (text) {\n    return text.replace(\"||\", $strings.PLACEHOLDER2);\n  };\n  /**\r\n   * Replaces placeholders back to brackets.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param text  Escaped text\r\n   * @return Unescaped text\r\n   */\n\n\n  NumberFormatter.prototype.unescape = function (text) {\n    return text.replace($strings.PLACEHOLDER2, \"|\");\n  };\n\n  return NumberFormatter;\n}(BaseObject);\n\nexport { NumberFormatter };\n/**\r\n * Register class in system, so that it can be instantiated using its name from\r\n * anywhere.\r\n *\r\n * @ignore\r\n */\n\nregistry.registeredClasses[\"NumberFormatter\"] = NumberFormatter;","map":{"version":3,"names":["__extends","Language","BaseObject","getTextFormatter","registry","$strings","$object","$utils","$type","$math","NumberFormatter","_super","_this","call","_negativeBase","_numberFormat","_outputFormat","_smallNumberThreshold","_forceLTR","className","applyTheme","prototype","dispose","language","Object","defineProperty","get","_language","sprite","set","value","enumerable","configurable","format","precision","isString","toLowerCase","formatted","source","Number","isObject","intlLocales","Intl","NumberFormat","undefined","e","cleanFormat","info","parseFormat","details","positive","negative","zero","hasValue","mod","clone","decimals","active","template","split","PLACEHOLDER","join","applyFormat","forceLTR","cached","getCache","translateEmpty","replace","PLACEHOLDER2","parts","each","part","item","parsed","partFormat","chunks","chunk","i","length","text","type","matches","match","mods","modSpacing","a","thousands","passive","b","interval","getValue","pop","setCache","Math","abs","prefix","suffix","indexOf","a_1","applyPrefix","bytePrefixes","a_2","smallNumberThreshold","smallNumberPrefixes","bigNumberPrefixes","ol","min","toString","parseFloat","toPrecision","translate","exp","toExponential","round","d","pow","res","numberToString","ints","Array","ip","intsr","reverse","len","c","substr","unshift","separator","push","decs","prefixes","force","newvalue","applied","k","number","floor","invalidateSprite","invalidate","_intlLocales","_bigNumberPrefixes","_smallNumberPrefixes","_bytePrefixes","outputFormat","escape","unescape","registeredClasses"],"sources":["D:/APPLICATION/UI/UPL/NEW/node_modules/@amcharts/amcharts4/.internal/core/formatters/NumberFormatter.js"],"sourcesContent":["/**\r\n * Number formatting-related functionality.\r\n */\r\nimport { __extends } from \"tslib\";\r\nimport { Language } from \"../utils/Language\";\r\nimport { BaseObject } from \"../Base\";\r\nimport { getTextFormatter } from \"../formatters/TextFormatter\";\r\nimport { registry } from \"../Registry\";\r\nimport * as $strings from \"../utils/Strings\";\r\nimport * as $object from \"../utils/Object\";\r\nimport * as $utils from \"../utils/Utils\";\r\nimport * as $type from \"../utils/Type\";\r\nimport * as $math from \"../utils/Math\";\r\n/**\r\n * NumberFormatter class. Formats numbers according to specified formats.\r\n *\r\n * @todo Apply translations to suffixes/prefixes\r\n */\r\nvar NumberFormatter = /** @class */ (function (_super) {\r\n    __extends(NumberFormatter, _super);\r\n    /**\r\n     * Constructor\r\n     */\r\n    function NumberFormatter() {\r\n        var _this = _super.call(this) || this;\r\n        /**\r\n         * A base value for negative numbers. Will treat all numbers below this value\r\n         * as negative numbers.\r\n         */\r\n        _this._negativeBase = 0;\r\n        /**\r\n         * Holds number format.\r\n         *\r\n         * @default #,###.#####\r\n         */\r\n        _this._numberFormat = \"#,###.#####\";\r\n        /**\r\n         * Output format to produce. If the format calls for applying color to the\r\n         * formatted value, this setting will determine what markup to use: SVG or\r\n         * HTML.\r\n         *\r\n         * Available options: svg, html.\r\n         *\r\n         * @default \"svg\"\r\n         */\r\n        _this._outputFormat = \"svg\";\r\n        /**\r\n         * Any number smaller than this will be considered \"small\" number, which will\r\n         * trigger special formatting if \"a\" format modifier is used.\r\n         */\r\n        _this._smallNumberThreshold = 1.00;\r\n        _this._forceLTR = false;\r\n        _this.className = \"NumberFormatter\";\r\n        _this.applyTheme();\r\n        return _this;\r\n    }\r\n    NumberFormatter.prototype.dispose = function () {\r\n        _super.prototype.dispose.call(this);\r\n        if (this.language) {\r\n            this.language.dispose();\r\n        }\r\n    };\r\n    Object.defineProperty(NumberFormatter.prototype, \"language\", {\r\n        /**\r\n         * @return Language\r\n         */\r\n        get: function () {\r\n            if (!this._language) {\r\n                if (this.sprite) {\r\n                    this._language = this.sprite.language;\r\n                }\r\n                else {\r\n                    this._language = new Language;\r\n                }\r\n            }\r\n            return this._language;\r\n        },\r\n        /**\r\n         * A reference to [[Language]] instance.\r\n         *\r\n         * Formatter will use language to translate various items, like number\r\n         * suffixes, etc.\r\n         *\r\n         * @param value  Language\r\n         */\r\n        set: function (value) {\r\n            this._language = value;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    /**\r\n     * Formats the number according to specific format.\r\n     *\r\n     * @param value   Value to format\r\n     * @param format  Format to apply\r\n     * @return Formatted number\r\n     */\r\n    NumberFormatter.prototype.format = function (value, format, precision) {\r\n        // no format passed in or \"Number\"\r\n        if (typeof format === \"undefined\" || ($type.isString(format) && format.toLowerCase() === \"number\")) {\r\n            format = this._numberFormat;\r\n        }\r\n        // Init return value\r\n        var formatted;\r\n        // Cast to number just in case\r\n        // TODO: maybe use better casting\r\n        var source = Number(value);\r\n        // Is it a built-in format or Intl.NumberFormatOptions\r\n        if ($type.isObject(format)) {\r\n            try {\r\n                if (this.intlLocales) {\r\n                    return new Intl.NumberFormat(this.intlLocales, format).format(source);\r\n                }\r\n                else {\r\n                    return new Intl.NumberFormat(undefined, format).format(source);\r\n                }\r\n            }\r\n            catch (e) {\r\n                return \"Invalid\";\r\n            }\r\n        }\r\n        else {\r\n            // Clean format\r\n            format = $utils.cleanFormat(format);\r\n            // Get format info (it will also deal with parser caching)\r\n            var info = this.parseFormat(format, this.language);\r\n            // format and replace the number\r\n            var details = void 0;\r\n            if (source > this._negativeBase) {\r\n                details = info.positive;\r\n            }\r\n            else if (source < this._negativeBase) {\r\n                details = info.negative;\r\n            }\r\n            else {\r\n                details = info.zero;\r\n            }\r\n            // Adjust precision\r\n            if ($type.hasValue(precision) && !details.mod) {\r\n                details = $object.clone(details);\r\n                details.decimals.active = source == 0 ? 0 : precision;\r\n            }\r\n            // Format\r\n            formatted = details.template.split($strings.PLACEHOLDER).join(this.applyFormat(source, details));\r\n        }\r\n        if (this.forceLTR) {\r\n            formatted = \"‎\" + formatted;\r\n        }\r\n        return formatted;\r\n    };\r\n    /**\r\n     * Parses supplied format into structured object which can be used to format\r\n     * the number.\r\n     *\r\n     * @param format Format string, i.e. \"#,###.00\"\r\n     * @param language Language\r\n     */\r\n    NumberFormatter.prototype.parseFormat = function (format, language) {\r\n        var _this = this;\r\n        // Check cache\r\n        var cached = this.getCache(format);\r\n        if ($type.hasValue(cached)) {\r\n            return cached;\r\n        }\r\n        // init format parse info holder\r\n        var info = {\r\n            \"positive\": {\r\n                \"thousands\": {\r\n                    \"active\": -1,\r\n                    \"passive\": -1,\r\n                    \"interval\": -1,\r\n                    \"separator\": language.translateEmpty(\"_thousandSeparator\")\r\n                },\r\n                \"decimals\": {\r\n                    \"active\": -1,\r\n                    \"passive\": -1,\r\n                    \"separator\": language.translateEmpty(\"_decimalSeparator\")\r\n                },\r\n                \"template\": \"\",\r\n                \"source\": \"\",\r\n                \"parsed\": false\r\n            },\r\n            \"negative\": {\r\n                \"thousands\": {\r\n                    \"active\": -1,\r\n                    \"passive\": -1,\r\n                    \"interval\": -1,\r\n                    \"separator\": language.translateEmpty(\"_thousandSeparator\")\r\n                },\r\n                \"decimals\": {\r\n                    \"active\": -1,\r\n                    \"passive\": -1,\r\n                    \"separator\": language.translateEmpty(\"_decimalSeparator\")\r\n                },\r\n                \"template\": \"\",\r\n                \"source\": \"\",\r\n                \"parsed\": false\r\n            },\r\n            \"zero\": {\r\n                \"thousands\": {\r\n                    \"active\": -1,\r\n                    \"passive\": -1,\r\n                    \"interval\": -1,\r\n                    \"separator\": language.translateEmpty(\"_thousandSeparator\")\r\n                },\r\n                \"decimals\": {\r\n                    \"active\": -1,\r\n                    \"passive\": -1,\r\n                    \"separator\": language.translateEmpty(\"_decimalSeparator\")\r\n                },\r\n                \"template\": \"\",\r\n                \"source\": \"\",\r\n                \"parsed\": false\r\n            }\r\n        };\r\n        // Escape double vertical bars (that mean display one vertical bar)\r\n        format = format.replace(\"||\", $strings.PLACEHOLDER2);\r\n        // Split it up and deal with different formats\r\n        var parts = format.split(\"|\");\r\n        info.positive.source = parts[0];\r\n        if (typeof parts[2] === \"undefined\") {\r\n            info.zero = info.positive;\r\n        }\r\n        else {\r\n            info.zero.source = parts[2];\r\n        }\r\n        if (typeof parts[1] === \"undefined\") {\r\n            info.negative = info.positive;\r\n        }\r\n        else {\r\n            info.negative.source = parts[1];\r\n        }\r\n        // Parse each\r\n        $object.each(info, function (part, item) {\r\n            // Already parsed\r\n            if (item.parsed) {\r\n                return;\r\n            }\r\n            // Check cached\r\n            if (typeof _this.getCache(item.source) !== \"undefined\") {\r\n                info[part] = _this.getCache(item.source);\r\n                return;\r\n            }\r\n            // Begin parsing\r\n            var partFormat = item.source;\r\n            // Just \"Number\"?\r\n            if (partFormat.toLowerCase() === \"number\") {\r\n                partFormat = $type.isString(_this._numberFormat) ? _this._numberFormat : \"#,###.#####\";\r\n            }\r\n            // Let TextFormatter split into chunks\r\n            var chunks = getTextFormatter().chunk(partFormat, true);\r\n            for (var i = 0; i < chunks.length; i++) {\r\n                var chunk = chunks[i];\r\n                // replace back double vertical bar\r\n                chunk.text = chunk.text.replace($strings.PLACEHOLDER2, \"|\");\r\n                if (chunk.type === \"value\") {\r\n                    // Parse format\r\n                    // Look for codes\r\n                    var matches = chunk.text.match(/[#0.,]+[ ]?[abespABESP%!]?[abespABESP‰!]?/);\r\n                    if (matches) {\r\n                        if (matches === null || matches[0] === \"\") {\r\n                            // no codes here - assume string\r\n                            // nothing to do here\r\n                            item.template += chunk.text;\r\n                        }\r\n                        else {\r\n                            // look for the format modifiers at the end\r\n                            var mods = matches[0].match(/[abespABESP%‰!]{2}|[abespABESP%‰]{1}$/);\r\n                            if (mods) {\r\n                                item.mod = mods[0].toLowerCase();\r\n                                item.modSpacing = matches[0].match(/[ ]{1}[abespABESP%‰!]{1}$/) ? true : false;\r\n                            }\r\n                            // break the format up\r\n                            var a = matches[0].split(\".\");\r\n                            // Deal with thousands\r\n                            if (a[0] === \"\") {\r\n                                // No directives for thousands\r\n                                // Leave default settings (no formatting)\r\n                            }\r\n                            else {\r\n                                // Counts\r\n                                item.thousands.active = (a[0].match(/0/g) || []).length;\r\n                                item.thousands.passive = (a[0].match(/\\#/g) || []).length + item.thousands.active;\r\n                                // Separator interval\r\n                                var b = a[0].split(\",\");\r\n                                if (b.length === 1) {\r\n                                    // No thousands separators\r\n                                    // Do nothing\r\n                                }\r\n                                else {\r\n                                    // Use length fo the last chunk as thousands length\r\n                                    item.thousands.interval = $type.getValue(b.pop()).length;\r\n                                    if (item.thousands.interval === 0) {\r\n                                        item.thousands.interval = -1;\r\n                                    }\r\n                                }\r\n                            }\r\n                            // Deal with decimals\r\n                            if (typeof (a[1]) === \"undefined\") {\r\n                                // No directives for decimals\r\n                                // Leave at defaults (no formatting)\r\n                            }\r\n                            else {\r\n                                // Counts\r\n                                item.decimals.active = (a[1].match(/0/g) || []).length;\r\n                                item.decimals.passive = (a[1].match(/\\#/g) || []).length + item.decimals.active;\r\n                            }\r\n                            // Add special code to template\r\n                            item.template += chunk.text.split(matches[0]).join($strings.PLACEHOLDER);\r\n                        }\r\n                    }\r\n                }\r\n                else {\r\n                    // Quoted string - take it as it is\r\n                    item.template += chunk.text;\r\n                }\r\n            }\r\n            // Apply style formatting\r\n            //item.template = getTextFormatter().format(item.template, this.outputFormat);\r\n            // Save cache\r\n            _this.setCache(item.source, item);\r\n            // Mark this as parsed\r\n            item.parsed = true;\r\n        });\r\n        // Save cache (the whole thing)\r\n        this.setCache(format, info);\r\n        return info;\r\n    };\r\n    /**\r\n     * Applies parsed format to a numeric value.\r\n     *\r\n     * @param value    Value\r\n     * @param details  Parsed format as returned by parseFormat()\r\n     * @return Formatted number\r\n     */\r\n    NumberFormatter.prototype.applyFormat = function (value, details) {\r\n        // Use absolute values\r\n        var negative = value < 0;\r\n        value = Math.abs(value);\r\n        // Recalculate according to modifier\r\n        var prefix = \"\", suffix = \"\";\r\n        var mods = details.mod ? details.mod.split(\"\") : [];\r\n        if (mods.indexOf(\"b\") !== -1) {\r\n            var a_1 = this.applyPrefix(value, this.bytePrefixes, mods.indexOf(\"!\") !== -1);\r\n            value = a_1[0];\r\n            prefix = a_1[1];\r\n            suffix = a_1[2];\r\n            if (details.modSpacing) {\r\n                suffix = \" \" + suffix;\r\n            }\r\n        }\r\n        else if (mods.indexOf(\"a\") !== -1) {\r\n            var a_2 = this.applyPrefix(value, value < this.smallNumberThreshold ? this.smallNumberPrefixes : this.bigNumberPrefixes, mods.indexOf(\"!\") !== -1);\r\n            value = a_2[0];\r\n            prefix = a_2[1];\r\n            suffix = a_2[2];\r\n            if (details.modSpacing) {\r\n                suffix = \" \" + suffix;\r\n            }\r\n        }\r\n        else if (mods.indexOf(\"p\") !== -1) {\r\n            var ol = Math.min(value.toString().length + 2, 21);\r\n            //value *= 100;\r\n            value = parseFloat(value.toPrecision(ol));\r\n            prefix = this.language.translate(\"_percentPrefix\") || \"\";\r\n            suffix = this.language.translate(\"_percentSuffix\") || \"\";\r\n            if (prefix == \"\" && suffix == \"\") {\r\n                suffix = \"%\";\r\n            }\r\n        }\r\n        else if (mods.indexOf(\"%\") !== -1) {\r\n            var ol = $math.min(value.toString().length + 2, 21);\r\n            value *= 100;\r\n            value = parseFloat(value.toPrecision(ol));\r\n            suffix = \"%\";\r\n        }\r\n        else if (mods.indexOf(\"‰\") !== -1) {\r\n            var ol = $math.min(value.toString().length + 3, 21);\r\n            value *= 1000;\r\n            value = parseFloat(value.toPrecision(ol));\r\n            suffix = \"‰\";\r\n        }\r\n        // Round to passive\r\n        if (mods.indexOf(\"e\") !== -1) {\r\n            // convert the value to exponential\r\n            var exp = void 0;\r\n            if (details.decimals.passive >= 0) {\r\n                exp = value.toExponential(details.decimals.passive).split(\"e\");\r\n            }\r\n            else {\r\n                exp = value.toExponential().split(\"e\");\r\n            }\r\n            value = Number(exp[0]);\r\n            suffix = \"e\" + exp[1];\r\n            if (details.modSpacing) {\r\n                suffix = \" \" + suffix;\r\n            }\r\n        }\r\n        else if (details.decimals.passive === 0) {\r\n            value = Math.round(value);\r\n        }\r\n        else if (details.decimals.passive > 0) {\r\n            var d = Math.pow(10, details.decimals.passive);\r\n            value = Math.round(value * d) / d;\r\n        }\r\n        // Init return value\r\n        var res = \"\";\r\n        // Calc integer and decimal parts\r\n        var a = $utils.numberToString(value).split(\".\");\r\n        // Format integers\r\n        var ints = a[0];\r\n        // Pad integers to active length\r\n        if (ints.length < details.thousands.active) {\r\n            ints = Array(details.thousands.active - ints.length + 1).join(\"0\") + ints;\r\n        }\r\n        // Insert thousands separators\r\n        if (details.thousands.interval > 0) {\r\n            var ip = [];\r\n            var intsr = ints.split(\"\").reverse().join(\"\");\r\n            for (var i = 0, len = ints.length; i <= len; i += details.thousands.interval) {\r\n                var c = intsr.substr(i, details.thousands.interval).split(\"\").reverse().join(\"\");\r\n                if (c !== \"\") {\r\n                    ip.unshift(c);\r\n                }\r\n            }\r\n            ints = ip.join(details.thousands.separator);\r\n        }\r\n        // Add integers\r\n        res += ints;\r\n        // Add decimals\r\n        if (a.length === 1) {\r\n            a.push(\"\");\r\n        }\r\n        var decs = a[1];\r\n        // Fill zeros?\r\n        if (decs.length < details.decimals.active) {\r\n            decs += Array(details.decimals.active - decs.length + 1).join(\"0\");\r\n        }\r\n        if (decs !== \"\") {\r\n            res += details.decimals.separator + decs;\r\n        }\r\n        // Can't have empty return value\r\n        if (res === \"\") {\r\n            res = \"0\";\r\n        }\r\n        // Add minus sign back\r\n        if (value !== 0 && negative && (mods.indexOf(\"s\") === -1)) {\r\n            res = \"-\" + res;\r\n        }\r\n        // Add suffixes/prefixes\r\n        if (prefix) {\r\n            res = prefix + res;\r\n        }\r\n        if (suffix) {\r\n            res += suffix;\r\n        }\r\n        return res;\r\n    };\r\n    /**\r\n     * Chooses appropriate prefix and suffix based on the passed in rules.\r\n     *\r\n     * @param  value     Value\r\n     * @param  prefixes  Prefix array\r\n     * @param  force     Force application of a first prefix (@sice 4.5.4)\r\n     * @return Result\r\n     */\r\n    NumberFormatter.prototype.applyPrefix = function (value, prefixes, force) {\r\n        if (force === void 0) { force = false; }\r\n        var newvalue = value;\r\n        var prefix = \"\";\r\n        var suffix = \"\";\r\n        var applied = false;\r\n        var k = 1;\r\n        for (var i = 0, len = prefixes.length; i < len; i++) {\r\n            if (prefixes[i].number <= value) {\r\n                if (prefixes[i].number === 0) {\r\n                    newvalue = 0;\r\n                }\r\n                else {\r\n                    newvalue = value / prefixes[i].number;\r\n                    k = prefixes[i].number;\r\n                }\r\n                prefix = prefixes[i].prefix;\r\n                suffix = prefixes[i].suffix;\r\n                applied = true;\r\n            }\r\n        }\r\n        if (!applied && force && prefixes.length && value != 0) {\r\n            // Prefix was not applied. Use the first prefix.\r\n            newvalue = value / prefixes[0].number;\r\n            prefix = prefixes[0].prefix;\r\n            suffix = prefixes[0].suffix;\r\n            applied = true;\r\n        }\r\n        if (applied) {\r\n            newvalue = parseFloat(newvalue.toPrecision($math.min(k.toString().length + Math.floor(newvalue).toString().replace(/[^0-9]*/g, \"\").length, 21)));\r\n        }\r\n        return [newvalue, prefix, suffix];\r\n    };\r\n    /**\r\n     * Invalidates the parent [[Sprite]] object.\r\n     */\r\n    NumberFormatter.prototype.invalidateSprite = function () {\r\n        if (this.sprite) {\r\n            this.sprite.invalidate();\r\n        }\r\n    };\r\n    Object.defineProperty(NumberFormatter.prototype, \"numberFormat\", {\r\n        /**\r\n         * @return A format to use for number formatting\r\n         */\r\n        get: function () {\r\n            return this._numberFormat;\r\n        },\r\n        /**\r\n         * Number format.\r\n         *\r\n         * @default \"#,###.#####\"\r\n         * @see {@link https://www.amcharts.com/docs/v4/concepts/formatters/formatting-numbers/} Tutorial on number formatting\r\n         * @param format  A format to use for number formatting\r\n         */\r\n        set: function (format) {\r\n            this._numberFormat = format;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(NumberFormatter.prototype, \"intlLocales\", {\r\n        /**\r\n         * @return Date format\r\n         */\r\n        get: function () {\r\n            return this._intlLocales;\r\n        },\r\n        /**\r\n         * Locales if you are using date formats in `Intl.NumberFormatOptions` syntax.\r\n         *\r\n         * @see (@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/NumberFormat) about using Intl for number formatting\r\n         * @param value Locales\r\n         */\r\n        set: function (value) {\r\n            this._intlLocales = value;\r\n            this.invalidateSprite();\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(NumberFormatter.prototype, \"negativeBase\", {\r\n        /**\r\n         * @return A format to use for number formatting\r\n         */\r\n        get: function () {\r\n            return this._negativeBase;\r\n        },\r\n        /**\r\n         * Negative base for negative numbers.\r\n         *\r\n         * @default 0\r\n         * @see {@link https://www.amcharts.com/docs/v4/concepts/formatters/formatting-numbers/} Tutorial on number formatting\r\n         * @param format  A format to use for number formatting\r\n         */\r\n        set: function (value) {\r\n            this._negativeBase = value;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(NumberFormatter.prototype, \"bigNumberPrefixes\", {\r\n        /**\r\n         * @return Prefixes for big numbers\r\n         */\r\n        get: function () {\r\n            if (!$type.hasValue(this._bigNumberPrefixes)) {\r\n                this._bigNumberPrefixes = [\r\n                    { \"number\": 1e+3, \"suffix\": this.language.translate(\"_big_number_suffix_3\") },\r\n                    { \"number\": 1e+6, \"suffix\": this.language.translate(\"_big_number_suffix_6\") },\r\n                    { \"number\": 1e+9, \"suffix\": this.language.translate(\"_big_number_suffix_9\") },\r\n                    { \"number\": 1e+12, \"suffix\": this.language.translate(\"_big_number_suffix_12\") },\r\n                    { \"number\": 1e+15, \"suffix\": this.language.translate(\"_big_number_suffix_15\") },\r\n                    { \"number\": 1e+18, \"suffix\": this.language.translate(\"_big_number_suffix_18\") },\r\n                    { \"number\": 1e+21, \"suffix\": this.language.translate(\"_big_number_suffix_21\") },\r\n                    { \"number\": 1e+24, \"suffix\": this.language.translate(\"_big_number_suffix_24\") }\r\n                ];\r\n            }\r\n            return this._bigNumberPrefixes;\r\n        },\r\n        /**\r\n         * Prefixes for big numbers.\r\n         *\r\n         * It's an array of objects of number/prefix pairs.\r\n         *\r\n         * ```JSON\r\n         * [\r\n         *   { \"number\": 1e+3, \"suffix\": \"K\" },\r\n         *   { \"number\": 1e+6, \"suffix\": \"M\" },\r\n         *   { \"number\": 1e+9, \"suffix\": \"G\" },\r\n         *   { \"number\": 1e+12, \"suffix\": \"T\" },\r\n         *   { \"number\": 1e+15, \"suffix\": \"P\" },\r\n         *   { \"number\": 1e+18, \"suffix\": \"E\" },\r\n         *   { \"number\": 1e+21, \"suffix\": \"Z\" },\r\n         *   { \"number\": 1e+24, \"suffix\": \"Y\" }\r\n         * ]\r\n         * ```\r\n         *\r\n         * If the number is bigger than the `number` ir will be converted to the\r\n         * appropriate bigger number with prefix.\r\n         *\r\n         * E.g. as per above `1500` will be converted to `1.5K`.\r\n         *\r\n         * Please note that for this transformation to be enabled, you need to\r\n         * enable it specific modifier in your format setting.\r\n         *\r\n         * The modifier for big/small number modification is \"a\":\r\n         *\r\n         * ```Text\r\n         * {myfield.formatNumber(\"#,###.00a\")}\r\n         * ```\r\n         *\r\n         * @see {@link https://www.amcharts.com/docs/v4/concepts/formatters/formatting-numbers/} Tutorial on number formatting\r\n         * @param prefixes  Prefixes for big numbers\r\n         */\r\n        set: function (prefixes) {\r\n            this._bigNumberPrefixes = prefixes;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(NumberFormatter.prototype, \"smallNumberPrefixes\", {\r\n        /**\r\n         * @return Prefixes for small numbers\r\n         */\r\n        get: function () {\r\n            if (!$type.hasValue(this._smallNumberPrefixes)) {\r\n                this._smallNumberPrefixes = [\r\n                    { \"number\": 1e-24, \"suffix\": this.language.translate(\"_small_number_suffix_24\") },\r\n                    { \"number\": 1e-21, \"suffix\": this.language.translate(\"_small_number_suffix_21\") },\r\n                    { \"number\": 1e-18, \"suffix\": this.language.translate(\"_small_number_suffix_18\") },\r\n                    { \"number\": 1e-15, \"suffix\": this.language.translate(\"_small_number_suffix_15\") },\r\n                    { \"number\": 1e-12, \"suffix\": this.language.translate(\"_small_number_suffix_12\") },\r\n                    { \"number\": 1e-9, \"suffix\": this.language.translate(\"_small_number_suffix_9\") },\r\n                    { \"number\": 1e-6, \"suffix\": this.language.translate(\"_small_number_suffix_6\") },\r\n                    { \"number\": 1e-3, \"suffix\": this.language.translate(\"_small_number_suffix_3\") }\r\n                ];\r\n            }\r\n            return this._smallNumberPrefixes;\r\n        },\r\n        /**\r\n         * Prefixes for big numbers.\r\n         *\r\n         * It's an array of objects of number/prefix pairs.\r\n         *\r\n         * ```JSON\r\n         * [\r\n         *   { \"number\": 1e-24, \"suffix\": \"y\" },\r\n         *   { \"number\": 1e-21, \"suffix\": \"z\" },\r\n         *   { \"number\": 1e-18, \"suffix\": \"a\" },\r\n         *   { \"number\": 1e-15, \"suffix\": \"f\" },\r\n         *   { \"number\": 1e-12, \"suffix\": \"p\" },\r\n         *   { \"number\": 1e-9, \"suffix\": \"n\" },\r\n         *   { \"number\": 1e-6, \"suffix\": \"μ\" },\r\n         *   { \"number\": 1e-3, \"suffix\": \"m\" }\r\n         * ]\r\n         * ```\r\n         *\r\n         * If the number is smaller than the `number` ir will be converted to the\r\n         * appropriate smaller number with prefix.\r\n         *\r\n         * E.g. as per above `0.0015` will be converted to `1.5m`.\r\n         *\r\n         * Please note that for this transformation to be enabled, you need to\r\n         * enable it specific modifier in your format setting.\r\n         *\r\n         * The modifier for big/small number modification is \"a\":\r\n         *\r\n         * ```Text\r\n         * {myfield.formatNumber(\"#,###.00a\")}\r\n         * ```\r\n         *\r\n         * IMPORTANT: The order of the suffixes is important. The list must start\r\n         * from the smallest number and work towards bigger ones.\r\n         *\r\n         * @see {@link https://www.amcharts.com/docs/v4/concepts/formatters/formatting-numbers/} Tutorial on number formatting\r\n         * @param prefixes  Prefixes for small numbers\r\n         */\r\n        set: function (prefixes) {\r\n            this._smallNumberPrefixes = prefixes;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(NumberFormatter.prototype, \"smallNumberThreshold\", {\r\n        /**\r\n         * @return Small number threshold\r\n         */\r\n        get: function () {\r\n            return this._smallNumberThreshold;\r\n        },\r\n        /**\r\n         * Any number smaller than this will be considered \"small\" number, which will\r\n         * trigger special formatting if \"a\" format modifier is used.\r\n         *\r\n         * @since 4.6.8\r\n         * @param  value  Small number threshold\r\n         */\r\n        set: function (value) {\r\n            this._smallNumberThreshold = value;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(NumberFormatter.prototype, \"bytePrefixes\", {\r\n        /**\r\n         * @return Prefixes for byte-size formatting\r\n         */\r\n        get: function () {\r\n            if (!$type.hasValue(this._bytePrefixes)) {\r\n                this._bytePrefixes = [\r\n                    { \"number\": 1, suffix: this.language.translate(\"_byte_suffix_B\") },\r\n                    { \"number\": 1024, suffix: this.language.translate(\"_byte_suffix_KB\") },\r\n                    { \"number\": 1048576, suffix: this.language.translate(\"_byte_suffix_MB\") },\r\n                    { \"number\": 1073741824, suffix: this.language.translate(\"_byte_suffix_GB\") },\r\n                    { \"number\": 1099511627776, suffix: this.language.translate(\"_byte_suffix_TB\") },\r\n                    { \"number\": 1125899906842624, suffix: this.language.translate(\"_byte_suffix_PB\") }\r\n                ];\r\n            }\r\n            return this._bytePrefixes;\r\n        },\r\n        /**\r\n         * Basically the same as `bigNumberPrefixes`, except base for calculation\r\n         * is not thousand but byte (1024).\r\n         *\r\n         * The modifier is \"b\".\r\n         *\r\n         *  ```Text\r\n         * {myfield.formatNumber(\"#,###.00b\")}\r\n         * ```\r\n         *\r\n         * The above `2048` will change to `2K`.\r\n         *\r\n         * @see {@link https://www.amcharts.com/docs/v4/concepts/formatters/formatting-numbers/} Tutorial on number formatting\r\n         * @param prefixes  Prefixes for byte-size formatting\r\n         */\r\n        set: function (prefixes) {\r\n            this._bytePrefixes = prefixes;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(NumberFormatter.prototype, \"outputFormat\", {\r\n        /**\r\n         * @ignore Exclude from docs\r\n         * @return Output format\r\n         */\r\n        get: function () {\r\n            return this._outputFormat;\r\n        },\r\n        /**\r\n         * Ooutput format: \"svg\" or \"html\".\r\n         *\r\n         * @ignore Exclude from docs\r\n         * @param value  Output format\r\n         */\r\n        set: function (outputFormat) {\r\n            this._outputFormat = outputFormat.toLowerCase();\r\n            this.invalidateSprite();\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(NumberFormatter.prototype, \"forceLTR\", {\r\n        get: function () {\r\n            return this._forceLTR;\r\n        },\r\n        set: function (value) {\r\n            this._forceLTR = value;\r\n            this.invalidateSprite();\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    /**\r\n     * Replaces brackets with temporary placeholders.\r\n     *\r\n     * @ignore Exclude from docs\r\n     * @param text  Input text\r\n     * @return Escaped text\r\n     */\r\n    NumberFormatter.prototype.escape = function (text) {\r\n        return text.replace(\"||\", $strings.PLACEHOLDER2);\r\n    };\r\n    /**\r\n     * Replaces placeholders back to brackets.\r\n     *\r\n     * @ignore Exclude from docs\r\n     * @param text  Escaped text\r\n     * @return Unescaped text\r\n     */\r\n    NumberFormatter.prototype.unescape = function (text) {\r\n        return text.replace($strings.PLACEHOLDER2, \"|\");\r\n    };\r\n    return NumberFormatter;\r\n}(BaseObject));\r\nexport { NumberFormatter };\r\n/**\r\n * Register class in system, so that it can be instantiated using its name from\r\n * anywhere.\r\n *\r\n * @ignore\r\n */\r\nregistry.registeredClasses[\"NumberFormatter\"] = NumberFormatter;\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}