{"ast":null,"code":"/**\r\n * A collection of Math-related functions\r\n *\r\n * @todo Comment trigonometric functions?\r\n */\nimport * as $type from \"./Type\";\n/**\r\n * ============================================================================\r\n * CONSTANTS\r\n * ============================================================================\r\n * @hidden\r\n */\n\nexport var PI = Math.PI;\nexport var HALFPI = PI / 2;\nexport var RADIANS = PI / 180;\nexport var DEGREES = 180 / PI;\n/**\r\n * Converts any value and fits it into a specific value range.\r\n *\r\n * @param value  Source value\r\n * @param min    Minimum allowable value\r\n * @param max    Maximum allowable value\r\n * @return Number\r\n */\n\nexport function toNumberRange(value, min, max) {\n  if ($type.hasValue(value)) {\n    value = $type.toNumber(value);\n    return fitToRange(value, min, max);\n  }\n\n  return value;\n}\n/**\r\n * Rounds the numeric value to whole number or specific precision of set.\r\n *\r\n * @param value      Value\r\n * @param precision  Precision (number of decimal points)\r\n * @param floor  In case value ends with 0.5 and precision is 0, we might need to floor the value instead of ceiling it.\r\n * @return Rounded value\r\n */\n\nexport function round(value, precision, floor) {\n  if (!$type.isNumber(precision) || precision <= 0) {\n    var rounded = Math.round(value);\n\n    if (floor) {\n      if (rounded - value == 0.5) {\n        rounded--;\n      }\n    }\n\n    return rounded;\n  } else {\n    var d = Math.pow(10, precision);\n    return Math.round(value * d) / d;\n  }\n}\n/**\r\n * Ceils the numeric value to whole number or specific precision of set.\r\n *\r\n * @param value      Value\r\n * @param precision  Precision (number of decimal points)\r\n * @return Rounded value\r\n */\n\nexport function ceil(value, precision) {\n  if (!$type.isNumber(precision) || precision <= 0) {\n    return Math.ceil(value);\n  } else {\n    var d = Math.pow(10, precision);\n    return Math.ceil(value * d) / d;\n  }\n}\n/**\r\n * Stretches `t` so that it will always be between `from` and `to`.\r\n *\r\n * @param t     Number from 0 to 1\r\n * @param from  Lowest possible value\r\n * @param to    Highest possible value\r\n * @return Adjusted value\r\n */\n\nexport function stretch(t, from, to) {\n  return t * (to - from) + from;\n}\n/**\r\n * Adjust numeric value so it fits to specific value range.\r\n *\r\n * @param value     Value\r\n * @param minValue  Lowest possible value\r\n * @param maxValue  Highest possible value\r\n * @return Adjusted value\r\n */\n\nexport function fitToRange(value, minValue, maxValue) {\n  if ($type.isNumber(minValue)) {\n    if ($type.isNumber(maxValue) && maxValue < minValue) {\n      var temp = maxValue;\n      maxValue = minValue;\n      minValue = temp;\n    }\n\n    if (value < minValue) {\n      value = minValue;\n    }\n  }\n\n  if ($type.isNumber(maxValue)) {\n    if (value > maxValue) {\n      value = maxValue;\n    }\n  }\n\n  return value;\n}\n/**\r\n * Returns sine of a number.\r\n *\r\n * @param value  Value\r\n * @return Sine\r\n */\n\nexport function sin(value) {\n  return round(Math.sin(RADIANS * value), 10);\n}\n/**\r\n * Returns tan of a number.\r\n *\r\n * @param value  Value\r\n * @return Sine\r\n */\n\nexport function tan(value) {\n  return round(Math.tan(RADIANS * value), 10);\n}\n/**\r\n * Returns cosine of a number.\r\n *\r\n * @param value  Value\r\n * @return Cosine\r\n */\n\nexport function cos(value) {\n  return round(Math.cos(RADIANS * value), 10);\n}\nexport function max(left, right) {\n  if ($type.isNumber(left)) {\n    if ($type.isNumber(right)) {\n      if (right > left) {\n        return right;\n      } else {\n        return left;\n      }\n    } else {\n      return left;\n    }\n  } else if ($type.isNumber(right)) {\n    return right;\n  } else {\n    return null;\n  }\n}\nexport function min(left, right) {\n  if ($type.isNumber(left)) {\n    if ($type.isNumber(right)) {\n      if (right < left) {\n        return right;\n      } else {\n        return left;\n      }\n    } else {\n      return left;\n    }\n  } else if ($type.isNumber(right)) {\n    return right;\n  } else {\n    return null;\n  }\n}\n/**\r\n * Returns the closest value from the array of values to the reference value.\r\n *\r\n * @param values  Array of values\r\n * @param value   Reference value\r\n * @return Closes value from the array\r\n */\n\nexport function closest(values, referenceValue) {\n  return values.reduce(function (prev, curr) {\n    return Math.abs(curr - referenceValue) < Math.abs(prev - referenceValue) ? curr : prev;\n  });\n}\n/**\r\n * Checks whether two ranges of values intersect.\r\n *\r\n * @param range1  Range 1\r\n * @param range2  Range 2\r\n * @return Any intersecting numbers?\r\n */\n\nexport function intersect(range1, range2) {\n  var start1 = $type.getValue(range1.start);\n  var start2 = $type.getValue(range2.start);\n  var end1 = $type.getValue(range1.end);\n  var end2 = $type.getValue(range2.end);\n  return Math.max(start1, start2) <= Math.min(end1, end2);\n}\n/**\r\n * Inverts the range of values.\r\n *\r\n * @param range  Range\r\n */\n\nexport function invertRange(range) {\n  var start = $type.getValue(range.start);\n  var end = $type.getValue(range.end);\n  return {\n    start: 1 - end,\n    end: 1 - start\n  };\n}\n/**\r\n * Returns an intersection range between two ranges of values.\r\n *\r\n * @param range1  Range 1\r\n * @param range2  Range 2\r\n * @return Intersecting value range\r\n */\n\nexport function intersection(range1, range2) {\n  var start1 = $type.getValue(range1.start);\n  var start2 = $type.getValue(range2.start);\n  var end1 = $type.getValue(range1.end);\n  var end2 = $type.getValue(range2.end);\n  var startMax = Math.max(start1, start2);\n  var endMin = Math.min(end1, end2);\n\n  if (endMin < startMax) {\n    return undefined;\n  } else {\n    return {\n      start: startMax,\n      end: endMin\n    };\n  }\n}\n/**\r\n * Returns pixel \"distance\" between two points.\r\n *\r\n * If second point is not specified, distance from {x:0, y:0} point is\r\n * calculated.\r\n *\r\n * @param point1  Point 1\r\n * @param point2  Point 2\r\n * @return Distance in relative pixels\r\n */\n\nexport function getDistance(point1, point2) {\n  if (!point1) {\n    return 0;\n  }\n\n  if (!point2) {\n    point2 = {\n      x: 0,\n      y: 0\n    };\n  }\n\n  return Math.sqrt(Math.pow(Math.abs(point1.x - point2.x), 2) + Math.pow(Math.abs(point1.y - point2.y), 2));\n}\n/**\r\n * Returns pixel \"horizontal distance\" between two points.\r\n *\r\n * If second point is not specified, distance from {x:0, y:0} point is\r\n * calculated.\r\n *\r\n * @param point1  Point 1\r\n * @param point2  Point 2\r\n * @return Distance in relative pixels\r\n */\n\nexport function getHorizontalDistance(point1, point2) {\n  if (!point1) {\n    return 0;\n  }\n\n  if (!point2) {\n    point2 = {\n      x: 0,\n      y: 0\n    };\n  }\n\n  return Math.abs(point1.x - point2.x);\n}\n/**\r\n * Returns pixel \"vertical distance\" between two points.\r\n *\r\n * If second point is not specified, distance from {x:0, y:0} point is\r\n * calculated.\r\n *\r\n * @param point1  Point 1\r\n * @param point2  Point 2\r\n * @return Distance in relative pixels\r\n */\n\nexport function getVerticalDistance(point1, point2) {\n  if (!point1) {\n    return 0;\n  }\n\n  if (!point2) {\n    point2 = {\n      x: 0,\n      y: 0\n    };\n  }\n\n  return Math.abs(point1.y - point2.y);\n}\n/**\r\n * Returns approximate pixel \"distance\" between two points of cubic curve\r\n *\r\n * If second point is not specified, distance from {x:0, y:0} point is\r\n * calculated.\r\n *\r\n * @param point1  Point 1\r\n * @param point2  Point 2\r\n * @param controlPointA  Control Point 1\r\n * @param controlPointB  Control Point 2\r\n * @param stepCount  number of steps (the more, the more accurate result)\r\n * @return Distance in relative pixels\r\n */\n\nexport function getCubicCurveDistance(point1, point2, controlPointA, controlPointB, stepCount) {\n  if (!point1) {\n    return 0;\n  }\n\n  if (!point2) {\n    point2 = {\n      x: 0,\n      y: 0\n    };\n  }\n\n  var distance = 0;\n  var prevPoint = point1;\n\n  if (stepCount > 0) {\n    for (var s = 0; s <= stepCount; s++) {\n      var point = getPointOnCubicCurve(point1, point2, controlPointA, controlPointB, s / stepCount);\n      distance += getDistance(prevPoint, point);\n      prevPoint = point;\n    }\n  }\n\n  return distance;\n}\n/**\r\n * Returns scale based on original and end position of the two points.\r\n *\r\n * @param point1       Current position of point 1\r\n * @param startPoint1  Start position of point 1\r\n * @param point2       Current position of point 1\r\n * @param startPoint2  Start position of point 2\r\n * @return Scale        Calculated scale\r\n */\n\nexport function getScale(point1, startPoint1, point2, startPoint2) {\n  var initialDistance = getDistance(startPoint1, startPoint2);\n  var currentDistance = getDistance(point1, point2);\n  return Math.abs(currentDistance / initialDistance);\n}\n/**\r\n * Returns an exact mid point between two points.\r\n *\r\n * @param point1     Position of point 1\r\n * @param point2     Position of point 2\r\n * @return Mid point  Position of mid-point\r\n */\n\nexport function getMidPoint(point1, point2, position) {\n  if (!$type.isNumber(position)) {\n    position = 0.5;\n  }\n\n  return {\n    \"x\": point1.x + (point2.x - point1.x) * position,\n    \"y\": point1.y + (point2.y - point1.y) * position\n  };\n}\n/**\r\n * Returns difference in angles between starting and ending position of two\r\n * vectors.\r\n *\r\n * @param point1       Current position of point 1\r\n * @param startPoint1  Start position of point 1\r\n * @param point2       Current position of point 1\r\n * @param startPoint2  Start position of point 2\r\n * @return Angle difference in degrees\r\n */\n\nexport function getRotation(point1, startPoint1, point2, startPoint2) {\n  // Get start and end angles\n  var startAngle = getAngle(startPoint1, startPoint2);\n  var angle = getAngle(point1, point2); // Calculate angle\n\n  var diff = startAngle - angle;\n\n  if (diff < 0) {\n    diff += 360;\n  }\n\n  return diff;\n}\n/**\r\n * Calculates angle of the vector based on two or one point.\r\n *\r\n * @param point1  Point 1\r\n * @param point2  Point 2\r\n * @return Angle in degrees\r\n */\n\nexport function getAngle(point1, point2) {\n  if (!point2) {\n    point2 = {\n      x: point1.x * 2,\n      y: point1.y * 2\n    };\n  }\n\n  var diffX = point2.x - point1.x;\n  var diffY = point2.y - point1.y;\n  var angle = Math.atan2(diffY, diffX) * DEGREES;\n\n  if (angle < 0) {\n    angle += 360;\n  }\n\n  return normalizeAngle(angle);\n}\n/**\r\n * Returns the shift in coordinates of the center when item is rotated, moved\r\n * and scaled at the same time.\r\n *\r\n * @param center       Current center\r\n * @param point1       Frst reference point\r\n * @param startPoint1  Original position of the first reference point\r\n * @param point2       Second reference point\r\n * @param startPoint2  Original position of the first reference point\r\n * @return Shift in center point coordinates\r\n */\n\nexport function getCenterShift(center, point1, startPoint1, point2, startPoint2) {\n  // Get angle\n  var angle = getRotation(point1, startPoint1, point2, startPoint2) - 90;\n\n  if (angle < 0) {\n    angle += 360;\n  } // Get distance between new position\n\n\n  var distance = getDistance(point1, point2); // Calculate new X\n\n  var x = Math.cos(angle) / distance + point1.x;\n  var y = Math.cos(angle) / distance + point1.y;\n  var shift = {\n    \"x\": x - center.x,\n    \"y\": y - center.y\n  };\n  return shift;\n}\n/**\r\n * Converts an array of points into a bounding box rectangle.\r\n *\r\n * Array can contain any number of points.\r\n *\r\n * @param points  Points\r\n * @return Bounding box rectangle\r\n */\n\nexport function getBBox(points) {\n  if (points) {\n    var length_1 = points.length;\n\n    if (length_1 !== 0) {\n      var left = void 0;\n      var right = void 0;\n      var top_1;\n      var bottom = void 0;\n\n      for (var i = 0; i < length_1; i++) {\n        var point = points[i];\n\n        if (!$type.isNumber(right) || point.x > right) {\n          right = point.x;\n        }\n\n        if (!$type.isNumber(left) || point.x < left) {\n          left = point.x;\n        }\n\n        if (!$type.isNumber(top_1) || point.y < top_1) {\n          top_1 = point.y;\n        }\n\n        if (!$type.isNumber(bottom) || point.y > bottom) {\n          bottom = point.y;\n        }\n      }\n\n      return {\n        x: left,\n        y: top_1,\n        width: right - left,\n        height: bottom - top_1\n      };\n    }\n  }\n\n  return {\n    x: 0,\n    y: 0,\n    width: 0,\n    height: 0\n  };\n}\n/**\r\n * Returns a [[IRectangle]] object representing a common rectangle that fits\r\n * all passed in rectangles in it.\r\n *\r\n * @param rectangles  An array of rectangles\r\n * @return Common rectangle\r\n */\n\nexport function getCommonRectangle(rectangles) {\n  var length = rectangles.length;\n\n  if (length !== 0) {\n    var minX = void 0;\n    var minY = void 0;\n    var maxX = void 0;\n    var maxY = void 0;\n\n    for (var i = 0; i < length; i++) {\n      var rectangle = rectangles[i];\n      minX = min(rectangle.x, minX);\n      minY = min(rectangle.y, minY);\n      maxX = max(rectangle.x + rectangle.width, maxX);\n      maxY = max(rectangle.y + rectangle.height, maxY);\n    }\n\n    return {\n      x: minX,\n      y: minY,\n      width: maxX - minX,\n      height: maxY - minY\n    };\n  }\n}\n/**\r\n * [getPointOnQuadraticCurve description]\r\n *\r\n * @ignore Exclude from docs\r\n * @todo Description\r\n * @param pointA        [description]\r\n * @param pointB        [description]\r\n * @param controlPoint  [description]\r\n * @param position      [description]\r\n * @return [description]\r\n */\n\nexport function getPointOnQuadraticCurve(pointA, pointB, controlPoint, position) {\n  var x = (1 - position) * (1 - position) * pointA.x + 2 * (1 - position) * position * controlPoint.x + position * position * pointB.x;\n  var y = (1 - position) * (1 - position) * pointA.y + 2 * (1 - position) * position * controlPoint.y + position * position * pointB.y;\n  return {\n    x: x,\n    y: y\n  };\n}\n/**\r\n * [getPointOnCubicCurve description]\r\n *\r\n * @ignore Exclude from docs\r\n * @todo Description\r\n * @param pointA         [description]\r\n * @param pointB         [description]\r\n * @param controlPointA  [description]\r\n * @param controlPointB  [description]\r\n * @param position       [description]\r\n * @return [description]\r\n */\n\nexport function getPointOnCubicCurve(pointA, pointB, controlPointA, controlPointB, position) {\n  var point = {\n    x: 0,\n    y: 0\n  };\n  var mt1 = 1 - position;\n  var mt2 = mt1 * mt1;\n  var mt3 = mt2 * mt1;\n  point.x = pointA.x * mt3 + controlPointA.x * 3 * mt2 * position + controlPointB.x * 3 * mt1 * position * position + pointB.x * position * position * position;\n  point.y = pointA.y * mt3 + controlPointA.y * 3 * mt2 * position + controlPointB.y * 3 * mt1 * position * position + pointB.y * position * position * position;\n  return point;\n}\n/**\r\n * [getCubicControlPointA description]\r\n *\r\n * @ignore Exclude from docs\r\n * @todo Description\r\n * @param p0        [description]\r\n * @param p1        [description]\r\n * @param p2        [description]\r\n * @param p3        [description]\r\n * @param tensionX  [description]\r\n * @param tensionY  [description]\r\n * @return [description]\r\n */\n\nexport function getCubicControlPointA(p0, p1, p2, p3, tensionX, tensionY) {\n  tensionX = adjustTension(tensionX);\n  tensionY = adjustTension(tensionY);\n  return {\n    x: (-p0.x + p1.x / tensionX + p2.x) * tensionX,\n    y: (-p0.y + p1.y / tensionY + p2.y) * tensionY\n  };\n}\n/**\r\n * [getCubicControlPointB description]\r\n *\r\n * @ignore Exclude from docs\r\n * @todo Description\r\n * @param p0        [description]\r\n * @param p1        [description]\r\n * @param p2        [description]\r\n * @param p3        [description]\r\n * @param tensionX  [description]\r\n * @param tensionY  [description]\r\n * @return [description]\r\n */\n\nexport function getCubicControlPointB(p0, p1, p2, p3, tensionX, tensionY) {\n  tensionX = adjustTension(tensionX);\n  tensionY = adjustTension(tensionY);\n  return {\n    x: (p1.x + p2.x / tensionX - p3.x) * tensionX,\n    y: (p1.y + p2.y / tensionY - p3.y) * tensionY\n  };\n}\n/**\r\n * [adjustTension description]\r\n *\r\n * @ignore Exclude from docs\r\n * @todo Description\r\n * @param tension  [description]\r\n * @return [description]\r\n */\n\nexport function adjustTension(tension) {\n  return 1 - tension + 0.00001;\n}\n/**\r\n * [normalizeAngle description]\r\n *\r\n * @ignore Exclude from docs\r\n * @todo Description\r\n * @param value  [description]\r\n * @return [description]\r\n */\n\nexport function normalizeAngle(value) {\n  if (value == 360) {\n    return 360;\n  }\n\n  return value % 360;\n}\n/**\r\n * [normalizeAngleToRange description]\r\n *\r\n * @ignore Exclude from docs\r\n * @todo Description\r\n * @todo review this with various angles, can be tested on radar chart with custom start/end angles\r\n * @param value       [description]\r\n * @param startAngle  [description]\r\n * @param endAngle    [description]\r\n * @return [description]\r\n */\n\nexport function fitAngleToRange(value, startAngle, endAngle) {\n  if (startAngle > endAngle) {\n    var temp = startAngle;\n    startAngle = endAngle;\n    endAngle = temp;\n  }\n\n  value = normalizeAngle(value);\n  var count = (startAngle - normalizeAngle(startAngle)) / 360;\n\n  if (value < startAngle) {\n    value += 360 * (count + 1);\n  }\n\n  var maxEnd = startAngle + (endAngle - startAngle) / 2 + 180;\n  var maxStart = startAngle + (endAngle - startAngle) / 2 - 180;\n\n  if (value > endAngle) {\n    if (value - 360 > startAngle) {\n      value -= 360;\n    } else {\n      if (value < maxEnd) {\n        value = endAngle;\n      } else {\n        value = startAngle;\n      }\n    }\n  }\n\n  if (value < startAngle) {\n    if (value > maxStart) {\n      value = startAngle;\n    } else {\n      value = endAngle;\n    }\n  }\n\n  return value;\n}\n/**\r\n * Returns [[IRectangle]] of an arc in relative values, assuming that the\r\n * center is at the circle center.\r\n *\r\n * Used to find out max radius of an arc.\r\n *\r\n * @ignore Exclude from docs\r\n * @param startAngle  Start angle\r\n * @param endAngle    End angle\r\n * @param radius    \t Relative radius\r\n * @return Rectangle\r\n */\n\nexport function getArcRect(startAngle, endAngle, radius) {\n  var minX = Number.MAX_VALUE;\n  var minY = Number.MAX_VALUE;\n  var maxX = -Number.MAX_VALUE;\n  var maxY = -Number.MAX_VALUE;\n  var bpoints = [];\n\n  if (!$type.isNumber(radius)) {\n    radius = 1;\n  }\n\n  bpoints.push(getArcPoint(radius, startAngle));\n  bpoints.push(getArcPoint(radius, endAngle));\n  var fromAngle = Math.min(Math.floor(startAngle / 90) * 90, Math.floor(endAngle / 90) * 90);\n  var toAngle = Math.max(Math.ceil(startAngle / 90) * 90, Math.ceil(endAngle / 90) * 90);\n\n  for (var angle = fromAngle; angle <= toAngle; angle += 90) {\n    if (angle >= startAngle && angle <= endAngle) {\n      bpoints.push(getArcPoint(radius, angle));\n    }\n  }\n\n  for (var i = 0; i < bpoints.length; i++) {\n    var pt = bpoints[i];\n\n    if (pt.x < minX) {\n      minX = pt.x;\n    }\n\n    if (pt.y < minY) {\n      minY = pt.y;\n    }\n\n    if (pt.x > maxX) {\n      maxX = pt.x;\n    }\n\n    if (pt.y > maxY) {\n      maxY = pt.y;\n    }\n  }\n\n  return {\n    x: minX,\n    y: minY,\n    width: maxX - minX,\n    height: maxY - minY\n  };\n}\n/**\r\n * Returns point on arc\r\n *\r\n * @param center point\r\n * @param radius\r\n * @param arc\r\n * @return {boolean}\r\n */\n\nexport function getArcPoint(radius, arc) {\n  return {\n    x: radius * cos(arc),\n    y: radius * sin(arc)\n  };\n}\n/**\r\n * Returns true if a point is within rectangle\r\n *\r\n * @param point\r\n * @param rectangle\r\n * @return {boolean}\r\n */\n\nexport function isInRectangle(point, rectangle) {\n  if (point.x >= rectangle.x && point.x <= rectangle.x + rectangle.width && point.y >= rectangle.y && point.y <= rectangle.y + rectangle.height) {\n    return true;\n  }\n\n  return false;\n}\nexport function getLineIntersection(pointA1, pointA2, pointB1, pointB2) {\n  var x = ((pointA1.x * pointA2.y - pointA2.x * pointA1.y) * (pointB1.x - pointB2.x) - (pointA1.x - pointA2.x) * (pointB1.x * pointB2.y - pointB1.y * pointB2.x)) / ((pointA1.x - pointA2.x) * (pointB1.y - pointB2.y) - (pointA1.y - pointA2.y) * (pointB1.x - pointB2.x));\n  var y = ((pointA1.x * pointA2.y - pointA2.x * pointA1.y) * (pointB1.y - pointB2.y) - (pointA1.y - pointA2.y) * (pointB1.x * pointB2.y - pointB1.y * pointB2.x)) / ((pointA1.x - pointA2.x) * (pointB1.y - pointB2.y) - (pointA1.y - pointA2.y) * (pointB1.x - pointB2.x));\n  return {\n    x: x,\n    y: y\n  };\n}","map":{"version":3,"names":["$type","PI","Math","HALFPI","RADIANS","DEGREES","toNumberRange","value","min","max","hasValue","toNumber","fitToRange","round","precision","floor","isNumber","rounded","d","pow","ceil","stretch","t","from","to","minValue","maxValue","temp","sin","tan","cos","left","right","closest","values","referenceValue","reduce","prev","curr","abs","intersect","range1","range2","start1","getValue","start","start2","end1","end","end2","invertRange","range","intersection","startMax","endMin","undefined","getDistance","point1","point2","x","y","sqrt","getHorizontalDistance","getVerticalDistance","getCubicCurveDistance","controlPointA","controlPointB","stepCount","distance","prevPoint","s","point","getPointOnCubicCurve","getScale","startPoint1","startPoint2","initialDistance","currentDistance","getMidPoint","position","getRotation","startAngle","getAngle","angle","diff","diffX","diffY","atan2","normalizeAngle","getCenterShift","center","shift","getBBox","points","length_1","length","top_1","bottom","i","width","height","getCommonRectangle","rectangles","minX","minY","maxX","maxY","rectangle","getPointOnQuadraticCurve","pointA","pointB","controlPoint","mt1","mt2","mt3","getCubicControlPointA","p0","p1","p2","p3","tensionX","tensionY","adjustTension","getCubicControlPointB","tension","fitAngleToRange","endAngle","count","maxEnd","maxStart","getArcRect","radius","Number","MAX_VALUE","bpoints","push","getArcPoint","fromAngle","toAngle","pt","arc","isInRectangle","getLineIntersection","pointA1","pointA2","pointB1","pointB2"],"sources":["D:/APPLICATION/UI/UPL/NEW/node_modules/@amcharts/amcharts4/.internal/core/utils/Math.js"],"sourcesContent":["/**\r\n * A collection of Math-related functions\r\n *\r\n * @todo Comment trigonometric functions?\r\n */\r\nimport * as $type from \"./Type\";\r\n/**\r\n * ============================================================================\r\n * CONSTANTS\r\n * ============================================================================\r\n * @hidden\r\n */\r\nexport var PI = Math.PI;\r\nexport var HALFPI = PI / 2;\r\nexport var RADIANS = PI / 180;\r\nexport var DEGREES = 180 / PI;\r\n/**\r\n * Converts any value and fits it into a specific value range.\r\n *\r\n * @param value  Source value\r\n * @param min    Minimum allowable value\r\n * @param max    Maximum allowable value\r\n * @return Number\r\n */\r\nexport function toNumberRange(value, min, max) {\r\n    if ($type.hasValue(value)) {\r\n        value = $type.toNumber(value);\r\n        return fitToRange(value, min, max);\r\n    }\r\n    return value;\r\n}\r\n/**\r\n * Rounds the numeric value to whole number or specific precision of set.\r\n *\r\n * @param value      Value\r\n * @param precision  Precision (number of decimal points)\r\n * @param floor  In case value ends with 0.5 and precision is 0, we might need to floor the value instead of ceiling it.\r\n * @return Rounded value\r\n */\r\nexport function round(value, precision, floor) {\r\n    if (!$type.isNumber(precision) || precision <= 0) {\r\n        var rounded = Math.round(value);\r\n        if (floor) {\r\n            if (rounded - value == 0.5) {\r\n                rounded--;\r\n            }\r\n        }\r\n        return rounded;\r\n    }\r\n    else {\r\n        var d = Math.pow(10, precision);\r\n        return Math.round(value * d) / d;\r\n    }\r\n}\r\n/**\r\n * Ceils the numeric value to whole number or specific precision of set.\r\n *\r\n * @param value      Value\r\n * @param precision  Precision (number of decimal points)\r\n * @return Rounded value\r\n */\r\nexport function ceil(value, precision) {\r\n    if (!$type.isNumber(precision) || precision <= 0) {\r\n        return Math.ceil(value);\r\n    }\r\n    else {\r\n        var d = Math.pow(10, precision);\r\n        return Math.ceil(value * d) / d;\r\n    }\r\n}\r\n/**\r\n * Stretches `t` so that it will always be between `from` and `to`.\r\n *\r\n * @param t     Number from 0 to 1\r\n * @param from  Lowest possible value\r\n * @param to    Highest possible value\r\n * @return Adjusted value\r\n */\r\nexport function stretch(t, from, to) {\r\n    return (t * (to - from)) + from;\r\n}\r\n/**\r\n * Adjust numeric value so it fits to specific value range.\r\n *\r\n * @param value     Value\r\n * @param minValue  Lowest possible value\r\n * @param maxValue  Highest possible value\r\n * @return Adjusted value\r\n */\r\nexport function fitToRange(value, minValue, maxValue) {\r\n    if ($type.isNumber(minValue)) {\r\n        if ($type.isNumber(maxValue) && maxValue < minValue) {\r\n            var temp = maxValue;\r\n            maxValue = minValue;\r\n            minValue = temp;\r\n        }\r\n        if (value < minValue) {\r\n            value = minValue;\r\n        }\r\n    }\r\n    if ($type.isNumber(maxValue)) {\r\n        if (value > maxValue) {\r\n            value = maxValue;\r\n        }\r\n    }\r\n    return value;\r\n}\r\n/**\r\n * Returns sine of a number.\r\n *\r\n * @param value  Value\r\n * @return Sine\r\n */\r\nexport function sin(value) {\r\n    return round(Math.sin(RADIANS * value), 10);\r\n}\r\n/**\r\n * Returns tan of a number.\r\n *\r\n * @param value  Value\r\n * @return Sine\r\n */\r\nexport function tan(value) {\r\n    return round(Math.tan(RADIANS * value), 10);\r\n}\r\n/**\r\n * Returns cosine of a number.\r\n *\r\n * @param value  Value\r\n * @return Cosine\r\n */\r\nexport function cos(value) {\r\n    return round(Math.cos(RADIANS * value), 10);\r\n}\r\nexport function max(left, right) {\r\n    if ($type.isNumber(left)) {\r\n        if ($type.isNumber(right)) {\r\n            if (right > left) {\r\n                return right;\r\n            }\r\n            else {\r\n                return left;\r\n            }\r\n        }\r\n        else {\r\n            return left;\r\n        }\r\n    }\r\n    else if ($type.isNumber(right)) {\r\n        return right;\r\n    }\r\n    else {\r\n        return null;\r\n    }\r\n}\r\nexport function min(left, right) {\r\n    if ($type.isNumber(left)) {\r\n        if ($type.isNumber(right)) {\r\n            if (right < left) {\r\n                return right;\r\n            }\r\n            else {\r\n                return left;\r\n            }\r\n        }\r\n        else {\r\n            return left;\r\n        }\r\n    }\r\n    else if ($type.isNumber(right)) {\r\n        return right;\r\n    }\r\n    else {\r\n        return null;\r\n    }\r\n}\r\n/**\r\n * Returns the closest value from the array of values to the reference value.\r\n *\r\n * @param values  Array of values\r\n * @param value   Reference value\r\n * @return Closes value from the array\r\n */\r\nexport function closest(values, referenceValue) {\r\n    return values.reduce(function (prev, curr) {\r\n        return (Math.abs(curr - referenceValue) < Math.abs(prev - referenceValue) ? curr : prev);\r\n    });\r\n}\r\n/**\r\n * Checks whether two ranges of values intersect.\r\n *\r\n * @param range1  Range 1\r\n * @param range2  Range 2\r\n * @return Any intersecting numbers?\r\n */\r\nexport function intersect(range1, range2) {\r\n    var start1 = $type.getValue(range1.start);\r\n    var start2 = $type.getValue(range2.start);\r\n    var end1 = $type.getValue(range1.end);\r\n    var end2 = $type.getValue(range2.end);\r\n    return Math.max(start1, start2) <= Math.min(end1, end2);\r\n}\r\n/**\r\n * Inverts the range of values.\r\n *\r\n * @param range  Range\r\n */\r\nexport function invertRange(range) {\r\n    var start = $type.getValue(range.start);\r\n    var end = $type.getValue(range.end);\r\n    return { start: 1 - end, end: 1 - start };\r\n}\r\n/**\r\n * Returns an intersection range between two ranges of values.\r\n *\r\n * @param range1  Range 1\r\n * @param range2  Range 2\r\n * @return Intersecting value range\r\n */\r\nexport function intersection(range1, range2) {\r\n    var start1 = $type.getValue(range1.start);\r\n    var start2 = $type.getValue(range2.start);\r\n    var end1 = $type.getValue(range1.end);\r\n    var end2 = $type.getValue(range2.end);\r\n    var startMax = Math.max(start1, start2);\r\n    var endMin = Math.min(end1, end2);\r\n    if (endMin < startMax) {\r\n        return undefined;\r\n    }\r\n    else {\r\n        return { start: startMax, end: endMin };\r\n    }\r\n}\r\n/**\r\n * Returns pixel \"distance\" between two points.\r\n *\r\n * If second point is not specified, distance from {x:0, y:0} point is\r\n * calculated.\r\n *\r\n * @param point1  Point 1\r\n * @param point2  Point 2\r\n * @return Distance in relative pixels\r\n */\r\nexport function getDistance(point1, point2) {\r\n    if (!point1) {\r\n        return 0;\r\n    }\r\n    if (!point2) {\r\n        point2 = { x: 0, y: 0 };\r\n    }\r\n    return Math.sqrt(Math.pow(Math.abs(point1.x - point2.x), 2) + Math.pow(Math.abs(point1.y - point2.y), 2));\r\n}\r\n/**\r\n * Returns pixel \"horizontal distance\" between two points.\r\n *\r\n * If second point is not specified, distance from {x:0, y:0} point is\r\n * calculated.\r\n *\r\n * @param point1  Point 1\r\n * @param point2  Point 2\r\n * @return Distance in relative pixels\r\n */\r\nexport function getHorizontalDistance(point1, point2) {\r\n    if (!point1) {\r\n        return 0;\r\n    }\r\n    if (!point2) {\r\n        point2 = { x: 0, y: 0 };\r\n    }\r\n    return Math.abs(point1.x - point2.x);\r\n}\r\n/**\r\n * Returns pixel \"vertical distance\" between two points.\r\n *\r\n * If second point is not specified, distance from {x:0, y:0} point is\r\n * calculated.\r\n *\r\n * @param point1  Point 1\r\n * @param point2  Point 2\r\n * @return Distance in relative pixels\r\n */\r\nexport function getVerticalDistance(point1, point2) {\r\n    if (!point1) {\r\n        return 0;\r\n    }\r\n    if (!point2) {\r\n        point2 = { x: 0, y: 0 };\r\n    }\r\n    return Math.abs(point1.y - point2.y);\r\n}\r\n/**\r\n * Returns approximate pixel \"distance\" between two points of cubic curve\r\n *\r\n * If second point is not specified, distance from {x:0, y:0} point is\r\n * calculated.\r\n *\r\n * @param point1  Point 1\r\n * @param point2  Point 2\r\n * @param controlPointA  Control Point 1\r\n * @param controlPointB  Control Point 2\r\n * @param stepCount  number of steps (the more, the more accurate result)\r\n * @return Distance in relative pixels\r\n */\r\nexport function getCubicCurveDistance(point1, point2, controlPointA, controlPointB, stepCount) {\r\n    if (!point1) {\r\n        return 0;\r\n    }\r\n    if (!point2) {\r\n        point2 = { x: 0, y: 0 };\r\n    }\r\n    var distance = 0;\r\n    var prevPoint = point1;\r\n    if (stepCount > 0) {\r\n        for (var s = 0; s <= stepCount; s++) {\r\n            var point = getPointOnCubicCurve(point1, point2, controlPointA, controlPointB, s / stepCount);\r\n            distance += getDistance(prevPoint, point);\r\n            prevPoint = point;\r\n        }\r\n    }\r\n    return distance;\r\n}\r\n/**\r\n * Returns scale based on original and end position of the two points.\r\n *\r\n * @param point1       Current position of point 1\r\n * @param startPoint1  Start position of point 1\r\n * @param point2       Current position of point 1\r\n * @param startPoint2  Start position of point 2\r\n * @return Scale        Calculated scale\r\n */\r\nexport function getScale(point1, startPoint1, point2, startPoint2) {\r\n    var initialDistance = getDistance(startPoint1, startPoint2);\r\n    var currentDistance = getDistance(point1, point2);\r\n    return Math.abs(currentDistance / initialDistance);\r\n}\r\n/**\r\n * Returns an exact mid point between two points.\r\n *\r\n * @param point1     Position of point 1\r\n * @param point2     Position of point 2\r\n * @return Mid point  Position of mid-point\r\n */\r\nexport function getMidPoint(point1, point2, position) {\r\n    if (!$type.isNumber(position)) {\r\n        position = 0.5;\r\n    }\r\n    return {\r\n        \"x\": (point1.x + (point2.x - point1.x) * position),\r\n        \"y\": (point1.y + (point2.y - point1.y) * position)\r\n    };\r\n}\r\n/**\r\n * Returns difference in angles between starting and ending position of two\r\n * vectors.\r\n *\r\n * @param point1       Current position of point 1\r\n * @param startPoint1  Start position of point 1\r\n * @param point2       Current position of point 1\r\n * @param startPoint2  Start position of point 2\r\n * @return Angle difference in degrees\r\n */\r\nexport function getRotation(point1, startPoint1, point2, startPoint2) {\r\n    // Get start and end angles\r\n    var startAngle = getAngle(startPoint1, startPoint2);\r\n    var angle = getAngle(point1, point2);\r\n    // Calculate angle\r\n    var diff = startAngle - angle;\r\n    if (diff < 0) {\r\n        diff += 360;\r\n    }\r\n    return diff;\r\n}\r\n/**\r\n * Calculates angle of the vector based on two or one point.\r\n *\r\n * @param point1  Point 1\r\n * @param point2  Point 2\r\n * @return Angle in degrees\r\n */\r\nexport function getAngle(point1, point2) {\r\n    if (!point2) {\r\n        point2 = { x: point1.x * 2, y: point1.y * 2 };\r\n    }\r\n    var diffX = point2.x - point1.x;\r\n    var diffY = point2.y - point1.y;\r\n    var angle = Math.atan2(diffY, diffX) * DEGREES;\r\n    if (angle < 0) {\r\n        angle += 360;\r\n    }\r\n    return normalizeAngle(angle);\r\n}\r\n/**\r\n * Returns the shift in coordinates of the center when item is rotated, moved\r\n * and scaled at the same time.\r\n *\r\n * @param center       Current center\r\n * @param point1       Frst reference point\r\n * @param startPoint1  Original position of the first reference point\r\n * @param point2       Second reference point\r\n * @param startPoint2  Original position of the first reference point\r\n * @return Shift in center point coordinates\r\n */\r\nexport function getCenterShift(center, point1, startPoint1, point2, startPoint2) {\r\n    // Get angle\r\n    var angle = getRotation(point1, startPoint1, point2, startPoint2) - 90;\r\n    if (angle < 0) {\r\n        angle += 360;\r\n    }\r\n    // Get distance between new position\r\n    var distance = getDistance(point1, point2);\r\n    // Calculate new X\r\n    var x = Math.cos(angle) / distance + point1.x;\r\n    var y = Math.cos(angle) / distance + point1.y;\r\n    var shift = {\r\n        \"x\": x - center.x,\r\n        \"y\": y - center.y\r\n    };\r\n    return shift;\r\n}\r\n/**\r\n * Converts an array of points into a bounding box rectangle.\r\n *\r\n * Array can contain any number of points.\r\n *\r\n * @param points  Points\r\n * @return Bounding box rectangle\r\n */\r\nexport function getBBox(points) {\r\n    if (points) {\r\n        var length_1 = points.length;\r\n        if (length_1 !== 0) {\r\n            var left = void 0;\r\n            var right = void 0;\r\n            var top_1;\r\n            var bottom = void 0;\r\n            for (var i = 0; i < length_1; i++) {\r\n                var point = points[i];\r\n                if (!$type.isNumber(right) || (point.x > right)) {\r\n                    right = point.x;\r\n                }\r\n                if (!$type.isNumber(left) || (point.x < left)) {\r\n                    left = point.x;\r\n                }\r\n                if (!$type.isNumber(top_1) || (point.y < top_1)) {\r\n                    top_1 = point.y;\r\n                }\r\n                if (!$type.isNumber(bottom) || (point.y > bottom)) {\r\n                    bottom = point.y;\r\n                }\r\n            }\r\n            return { x: left, y: top_1, width: right - left, height: bottom - top_1 };\r\n        }\r\n    }\r\n    return { x: 0, y: 0, width: 0, height: 0 };\r\n}\r\n/**\r\n * Returns a [[IRectangle]] object representing a common rectangle that fits\r\n * all passed in rectangles in it.\r\n *\r\n * @param rectangles  An array of rectangles\r\n * @return Common rectangle\r\n */\r\nexport function getCommonRectangle(rectangles) {\r\n    var length = rectangles.length;\r\n    if (length !== 0) {\r\n        var minX = void 0;\r\n        var minY = void 0;\r\n        var maxX = void 0;\r\n        var maxY = void 0;\r\n        for (var i = 0; i < length; i++) {\r\n            var rectangle = rectangles[i];\r\n            minX = min(rectangle.x, minX);\r\n            minY = min(rectangle.y, minY);\r\n            maxX = max(rectangle.x + rectangle.width, maxX);\r\n            maxY = max(rectangle.y + rectangle.height, maxY);\r\n        }\r\n        return { x: minX, y: minY, width: maxX - minX, height: maxY - minY };\r\n    }\r\n}\r\n/**\r\n * [getPointOnQuadraticCurve description]\r\n *\r\n * @ignore Exclude from docs\r\n * @todo Description\r\n * @param pointA        [description]\r\n * @param pointB        [description]\r\n * @param controlPoint  [description]\r\n * @param position      [description]\r\n * @return [description]\r\n */\r\nexport function getPointOnQuadraticCurve(pointA, pointB, controlPoint, position) {\r\n    var x = (1 - position) * (1 - position) * pointA.x + 2 * (1 - position) * position * controlPoint.x + position * position * pointB.x;\r\n    var y = (1 - position) * (1 - position) * pointA.y + 2 * (1 - position) * position * controlPoint.y + position * position * pointB.y;\r\n    return { x: x, y: y };\r\n}\r\n/**\r\n * [getPointOnCubicCurve description]\r\n *\r\n * @ignore Exclude from docs\r\n * @todo Description\r\n * @param pointA         [description]\r\n * @param pointB         [description]\r\n * @param controlPointA  [description]\r\n * @param controlPointB  [description]\r\n * @param position       [description]\r\n * @return [description]\r\n */\r\nexport function getPointOnCubicCurve(pointA, pointB, controlPointA, controlPointB, position) {\r\n    var point = { x: 0, y: 0 };\r\n    var mt1 = 1 - position;\r\n    var mt2 = mt1 * mt1;\r\n    var mt3 = mt2 * mt1;\r\n    point.x = pointA.x * mt3 + controlPointA.x * 3 * mt2 * position + controlPointB.x * 3 * mt1 * position * position + pointB.x * position * position * position;\r\n    point.y = pointA.y * mt3 + controlPointA.y * 3 * mt2 * position + controlPointB.y * 3 * mt1 * position * position + pointB.y * position * position * position;\r\n    return point;\r\n}\r\n/**\r\n * [getCubicControlPointA description]\r\n *\r\n * @ignore Exclude from docs\r\n * @todo Description\r\n * @param p0        [description]\r\n * @param p1        [description]\r\n * @param p2        [description]\r\n * @param p3        [description]\r\n * @param tensionX  [description]\r\n * @param tensionY  [description]\r\n * @return [description]\r\n */\r\nexport function getCubicControlPointA(p0, p1, p2, p3, tensionX, tensionY) {\r\n    tensionX = adjustTension(tensionX);\r\n    tensionY = adjustTension(tensionY);\r\n    return { x: ((-p0.x + p1.x / tensionX + p2.x) * tensionX), y: ((-p0.y + p1.y / tensionY + p2.y) * tensionY) };\r\n}\r\n/**\r\n * [getCubicControlPointB description]\r\n *\r\n * @ignore Exclude from docs\r\n * @todo Description\r\n * @param p0        [description]\r\n * @param p1        [description]\r\n * @param p2        [description]\r\n * @param p3        [description]\r\n * @param tensionX  [description]\r\n * @param tensionY  [description]\r\n * @return [description]\r\n */\r\nexport function getCubicControlPointB(p0, p1, p2, p3, tensionX, tensionY) {\r\n    tensionX = adjustTension(tensionX);\r\n    tensionY = adjustTension(tensionY);\r\n    return { x: ((p1.x + p2.x / tensionX - p3.x) * tensionX), y: ((p1.y + p2.y / tensionY - p3.y) * tensionY) };\r\n}\r\n/**\r\n * [adjustTension description]\r\n *\r\n * @ignore Exclude from docs\r\n * @todo Description\r\n * @param tension  [description]\r\n * @return [description]\r\n */\r\nexport function adjustTension(tension) {\r\n    return 1 - tension + 0.00001;\r\n}\r\n/**\r\n * [normalizeAngle description]\r\n *\r\n * @ignore Exclude from docs\r\n * @todo Description\r\n * @param value  [description]\r\n * @return [description]\r\n */\r\nexport function normalizeAngle(value) {\r\n    if (value == 360) {\r\n        return 360;\r\n    }\r\n    return value % 360;\r\n}\r\n/**\r\n * [normalizeAngleToRange description]\r\n *\r\n * @ignore Exclude from docs\r\n * @todo Description\r\n * @todo review this with various angles, can be tested on radar chart with custom start/end angles\r\n * @param value       [description]\r\n * @param startAngle  [description]\r\n * @param endAngle    [description]\r\n * @return [description]\r\n */\r\nexport function fitAngleToRange(value, startAngle, endAngle) {\r\n    if (startAngle > endAngle) {\r\n        var temp = startAngle;\r\n        startAngle = endAngle;\r\n        endAngle = temp;\r\n    }\r\n    value = normalizeAngle(value);\r\n    var count = (startAngle - normalizeAngle(startAngle)) / 360;\r\n    if (value < startAngle) {\r\n        value += 360 * (count + 1);\r\n    }\r\n    var maxEnd = startAngle + (endAngle - startAngle) / 2 + 180;\r\n    var maxStart = startAngle + (endAngle - startAngle) / 2 - 180;\r\n    if (value > endAngle) {\r\n        if (value - 360 > startAngle) {\r\n            value -= 360;\r\n        }\r\n        else {\r\n            if (value < maxEnd) {\r\n                value = endAngle;\r\n            }\r\n            else {\r\n                value = startAngle;\r\n            }\r\n        }\r\n    }\r\n    if (value < startAngle) {\r\n        if (value > maxStart) {\r\n            value = startAngle;\r\n        }\r\n        else {\r\n            value = endAngle;\r\n        }\r\n    }\r\n    return value;\r\n}\r\n/**\r\n * Returns [[IRectangle]] of an arc in relative values, assuming that the\r\n * center is at the circle center.\r\n *\r\n * Used to find out max radius of an arc.\r\n *\r\n * @ignore Exclude from docs\r\n * @param startAngle  Start angle\r\n * @param endAngle    End angle\r\n * @param radius    \t Relative radius\r\n * @return Rectangle\r\n */\r\nexport function getArcRect(startAngle, endAngle, radius) {\r\n    var minX = Number.MAX_VALUE;\r\n    var minY = Number.MAX_VALUE;\r\n    var maxX = -Number.MAX_VALUE;\r\n    var maxY = -Number.MAX_VALUE;\r\n    var bpoints = [];\r\n    if (!$type.isNumber(radius)) {\r\n        radius = 1;\r\n    }\r\n    bpoints.push(getArcPoint(radius, startAngle));\r\n    bpoints.push(getArcPoint(radius, endAngle));\r\n    var fromAngle = Math.min(Math.floor(startAngle / 90) * 90, Math.floor(endAngle / 90) * 90);\r\n    var toAngle = Math.max(Math.ceil(startAngle / 90) * 90, Math.ceil(endAngle / 90) * 90);\r\n    for (var angle = fromAngle; angle <= toAngle; angle += 90) {\r\n        if (angle >= startAngle && angle <= endAngle) {\r\n            bpoints.push(getArcPoint(radius, angle));\r\n        }\r\n    }\r\n    for (var i = 0; i < bpoints.length; i++) {\r\n        var pt = bpoints[i];\r\n        if (pt.x < minX) {\r\n            minX = pt.x;\r\n        }\r\n        if (pt.y < minY) {\r\n            minY = pt.y;\r\n        }\r\n        if (pt.x > maxX) {\r\n            maxX = pt.x;\r\n        }\r\n        if (pt.y > maxY) {\r\n            maxY = pt.y;\r\n        }\r\n    }\r\n    return ({ x: minX, y: minY, width: maxX - minX, height: maxY - minY });\r\n}\r\n/**\r\n * Returns point on arc\r\n *\r\n * @param center point\r\n * @param radius\r\n * @param arc\r\n * @return {boolean}\r\n */\r\nexport function getArcPoint(radius, arc) {\r\n    return ({ x: radius * cos(arc), y: radius * sin(arc) });\r\n}\r\n/**\r\n * Returns true if a point is within rectangle\r\n *\r\n * @param point\r\n * @param rectangle\r\n * @return {boolean}\r\n */\r\nexport function isInRectangle(point, rectangle) {\r\n    if (point.x >= rectangle.x && point.x <= rectangle.x + rectangle.width && point.y >= rectangle.y && point.y <= rectangle.y + rectangle.height) {\r\n        return true;\r\n    }\r\n    return false;\r\n}\r\nexport function getLineIntersection(pointA1, pointA2, pointB1, pointB2) {\r\n    var x = ((pointA1.x * pointA2.y - pointA2.x * pointA1.y) * (pointB1.x - pointB2.x) - (pointA1.x - pointA2.x) * (pointB1.x * pointB2.y - pointB1.y * pointB2.x)) / ((pointA1.x - pointA2.x) * (pointB1.y - pointB2.y) - (pointA1.y - pointA2.y) * (pointB1.x - pointB2.x));\r\n    var y = ((pointA1.x * pointA2.y - pointA2.x * pointA1.y) * (pointB1.y - pointB2.y) - (pointA1.y - pointA2.y) * (pointB1.x * pointB2.y - pointB1.y * pointB2.x)) / ((pointA1.x - pointA2.x) * (pointB1.y - pointB2.y) - (pointA1.y - pointA2.y) * (pointB1.x - pointB2.x));\r\n    return { x: x, y: y };\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}