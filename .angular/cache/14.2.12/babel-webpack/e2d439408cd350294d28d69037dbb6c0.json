{"ast":null,"code":"import { EventDispatcher } from \"./utils/EventDispatcher\";\nimport { Dictionary } from \"./utils/Dictionary\";\nimport { cache } from \"./utils/Cache\";\nimport * as $type from \"./utils/Type\";\nimport * as $string from \"./utils/String\";\nimport * as $array from \"./utils/Array\";\n/**\r\n * ============================================================================\r\n * MAIN CLASS\r\n * ============================================================================\r\n * @hidden\r\n */\n\n/**\r\n * Registry is used to store miscellaneous system-wide information, like ids,\r\n * maps, themes, and registered classes.\r\n *\r\n * @ignore Exclude from docs\r\n */\n\nvar Registry =\n/** @class */\nfunction () {\n  function Registry() {\n    var _this = this;\n    /**\r\n     * Event dispacther.\r\n     */\n\n\n    this.events = new EventDispatcher();\n    /**\r\n     * All currently applied themes. All new chart instances created will\r\n     * automatically inherit and retain System's themes.\r\n     */\n\n    this.themes = [];\n    /**\r\n     * List of all loaded available themes.\r\n     *\r\n     * Whenever a theme loads, it registers itself in System's `loadedThemes`\r\n     * collection.\r\n     */\n\n    this.loadedThemes = {};\n    /**\r\n     * An indeternal counter used to generate unique IDs.\r\n     *\r\n     * @ignore Exclude from docs\r\n     */\n\n    this._uidCount = 0;\n    /**\r\n     * Keeps register of class references so that they can be instnatiated using\r\n     * string key.\r\n     *\r\n     * @ignore Exclude from docs\r\n     */\n\n    this.registeredClasses = {};\n    /**\r\n     * Holds all generated placeholders.\r\n     */\n\n    this._placeholders = {};\n    /**\r\n     * A list of invalid(ated) [[Sprite]] objects that need to be re-validated\r\n     * during next cycle.\r\n     *\r\n     * @ignore Exclude from docs\r\n     */\n\n    this.invalidSprites = {};\n    /**\r\n     * Components are added to this list when their data provider changes to\r\n     * a new one or data is added/removed from their data provider.\r\n     *\r\n     * @ignore Exclude from docs\r\n     */\n\n    this.invalidDatas = {};\n    /**\r\n     * Components are added to this list when values of their raw data change.\r\n     * Used when we want a smooth animation from one set of values to another.\r\n     *\r\n     * @ignore Exclude from docs\r\n     */\n\n    this.invalidRawDatas = [];\n    /**\r\n     * Components are added to this list when values of their data changes\r\n     * (but not data provider itself).\r\n     *\r\n     * @ignore Exclude from docs\r\n     */\n\n    this.invalidDataItems = [];\n    /**\r\n     * Components are added to this list when their data range (selection) is\r\n     * changed, e.g. zoomed.\r\n     *\r\n     * @ignore Exclude from docs\r\n     */\n\n    this.invalidDataRange = [];\n    /**\r\n     * A list of [[Sprite]] objects that have invalid(ated) positions, that need\r\n     * to be recalculated.\r\n     *\r\n     * @ignore Exclude from docs\r\n     */\n\n    this.invalidPositions = {};\n    /**\r\n     * A list of [[Container]] objects with invalid(ated) layouts.\r\n     *\r\n     * @ignore Exclude from docs\r\n     */\n\n    this.invalidLayouts = {};\n    /**\r\n     * An array holding all active (non-disposed) top level elemens.\r\n     *\r\n     * When, for example, a new chart is created, its instance will be added to\r\n     * this array, and will be removed when the chart is disposed.\r\n     */\n\n    this.baseSprites = [];\n    /**\r\n     * An UID-based map of base sprites (top-level charts).\r\n     */\n\n    this.baseSpritesByUid = {};\n    /**\r\n     * Queued charts (waiting for their turn) to initialize.\r\n     *\r\n     * @see {@link https://www.amcharts.com/docs/v4/concepts/performance/#Daisy_chaining_multiple_charts} for more information\r\n     */\n\n    this.queue = [];\n    /**\r\n     * An array of deferred charts that haven't been created yet.\r\n     *\r\n     * @see {@link https://www.amcharts.com/docs/v4/concepts/performance/#Deferred_daisy_chained_instantiation} for more information\r\n     * @since 4.10.0\r\n     */\n\n    this.deferred = [];\n    this.uid = this.getUniqueId();\n    this.invalidSprites.noBase = [];\n    this.invalidDatas.noBase = [];\n    this.invalidLayouts.noBase = [];\n    this.invalidPositions.noBase = []; // This is needed for Angular Universal SSR\n\n    if (typeof addEventListener !== \"undefined\") {\n      // This is needed to prevent charts from being cut off when printing\n      addEventListener(\"beforeprint\", function () {\n        $array.each(_this.baseSprites, function (sprite) {\n          var svg = sprite.paper.svg;\n          svg.setAttribute(\"viewBox\", \"0 0 \" + svg.clientWidth + \" \" + svg.clientHeight);\n        });\n      });\n      addEventListener(\"afterprint\", function () {\n        $array.each(_this.baseSprites, function (sprite) {\n          var svg = sprite.paper.svg;\n          svg.removeAttribute(\"viewBox\");\n        });\n      });\n    }\n  }\n  /**\r\n   * Generates a unique chart system-wide ID.\r\n   *\r\n   * @return Generated ID\r\n   */\n\n\n  Registry.prototype.getUniqueId = function () {\n    var uid = this._uidCount;\n    this._uidCount += 1;\n    return \"id-\" + uid;\n  };\n\n  Object.defineProperty(Registry.prototype, \"map\", {\n    /**\r\n     * Returns a universal collection for mapping ids with objects.\r\n     *\r\n     * @ignore Exclude from docs\r\n     * @return Map collection\r\n     */\n    get: function () {\n      if (!this._map) {\n        this._map = new Dictionary();\n      }\n\n      return this._map;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\r\n   * Caches value in object's cache.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param key    Key\r\n   * @param value  Value\r\n   * @param ttl    TTL in seconds\r\n   */\n\n  Registry.prototype.setCache = function (key, value, ttl) {\n    cache.set(this.uid, key, value, ttl);\n  };\n  /**\r\n   * Retrieves cached value.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param key    Key\r\n   * @param value  Value to return if cache is not available\r\n   * @return Value\r\n   */\n\n\n  Registry.prototype.getCache = function (key, value) {\n    if (value === void 0) {\n      value = undefined;\n    }\n\n    return cache.get(this.uid, key, value);\n  };\n  /**\r\n   * Dispatches an event using own event dispatcher. Will automatically\r\n   * populate event data object with event type and target (this element).\r\n   * It also checks if there are any handlers registered for this sepecific\r\n   * event.\r\n   *\r\n   * @param eventType Event type (name)\r\n   * @param data      Data to pass into event handler(s)\r\n   */\n\n\n  Registry.prototype.dispatch = function (eventType, data) {\n    // @todo Implement proper type check\n    if (this.events.isEnabled(eventType)) {\n      if (data) {\n        data.type = eventType;\n        data.target = data.target || this;\n        this.events.dispatch(eventType, {\n          type: eventType,\n          target: this\n        });\n      } else {\n        this.events.dispatch(eventType, {\n          type: eventType,\n          target: this\n        });\n      }\n    }\n  };\n  /**\r\n   * Works like `dispatch`, except event is triggered immediately, without\r\n   * waiting for the next frame cycle.\r\n   *\r\n   * @param eventType Event type (name)\r\n   * @param data      Data to pass into event handler(s)\r\n   */\n\n\n  Registry.prototype.dispatchImmediately = function (eventType, data) {\n    // @todo Implement proper type check\n    if (this.events.isEnabled(eventType)) {\n      if (data) {\n        data.type = eventType;\n        data.target = data.target || this;\n        this.events.dispatchImmediately(eventType, data);\n      } else {\n        this.events.dispatchImmediately(eventType, {\n          type: eventType,\n          target: this\n        });\n      }\n    }\n  };\n  /**\r\n   * Returns a unique placeholder suitable for the key.\r\n   *\r\n   * @param key  Key\r\n   * @return Random string to be used as placeholder\r\n   */\n\n\n  Registry.prototype.getPlaceholder = function (key) {\n    if ($type.hasValue(this._placeholders[key])) {\n      return this._placeholders[key];\n    }\n\n    this._placeholders[key] = \"__amcharts_\" + key + \"_\" + $string.random(8) + \"__\";\n    return this._placeholders[key];\n  };\n  /**\r\n   * @ignore\r\n   */\n\n\n  Registry.prototype.addToInvalidComponents = function (component) {\n    if (component.baseId) {\n      $array.move(this.invalidDatas[component.baseId], component);\n    } else {\n      $array.move(this.invalidDatas[\"noBase\"], component);\n    }\n  };\n  /**\r\n   * @ignore\r\n   */\n\n\n  Registry.prototype.removeFromInvalidComponents = function (component) {\n    if (component.baseId) {\n      $array.remove(this.invalidDatas[component.baseId], component);\n    }\n\n    $array.remove(this.invalidDatas[\"noBase\"], component);\n  };\n  /**\r\n   * @ignore\r\n   */\n\n\n  Registry.prototype.addToInvalidSprites = function (sprite) {\n    if (sprite.baseId) {\n      $array.add(this.invalidSprites[sprite.baseId], sprite);\n    } else {\n      $array.add(this.invalidSprites[\"noBase\"], sprite);\n    }\n  };\n  /**\r\n   * @ignore\r\n   */\n\n\n  Registry.prototype.removeFromInvalidSprites = function (sprite) {\n    if (sprite.baseId) {\n      $array.remove(this.invalidSprites[sprite.baseId], sprite);\n    }\n\n    $array.remove(this.invalidSprites[\"noBase\"], sprite);\n  };\n  /**\r\n   * @ignore\r\n   */\n\n\n  Registry.prototype.addToInvalidPositions = function (sprite) {\n    if (sprite.baseId) {\n      $array.add(this.invalidPositions[sprite.baseId], sprite);\n    } else {\n      $array.add(this.invalidPositions[\"noBase\"], sprite);\n    }\n  };\n  /**\r\n   * @ignore\r\n   */\n\n\n  Registry.prototype.removeFromInvalidPositions = function (sprite) {\n    if (sprite.baseId) {\n      $array.remove(this.invalidPositions[sprite.baseId], sprite);\n    }\n\n    $array.remove(this.invalidPositions[\"noBase\"], sprite);\n  };\n  /**\r\n   * @ignore\r\n   */\n\n\n  Registry.prototype.addToInvalidLayouts = function (sprite) {\n    if (sprite.baseId) {\n      $array.add(this.invalidLayouts[sprite.baseId], sprite);\n    } else {\n      $array.add(this.invalidLayouts[\"noBase\"], sprite);\n    }\n  };\n  /**\r\n   * @ignore\r\n   */\n\n\n  Registry.prototype.removeFromInvalidLayouts = function (sprite) {\n    if (sprite.baseId) {\n      $array.remove(this.invalidLayouts[sprite.baseId], sprite);\n    }\n\n    $array.remove(this.invalidLayouts[\"noBase\"], sprite);\n  };\n\n  return Registry;\n}();\n\nexport { Registry };\n/**\r\n * A singleton global instance of [[Registry]].\r\n *\r\n * @ignore Exclude from docs\r\n */\n\nexport var registry = new Registry();\n/**\r\n * Returns `true` if object is an instance of the class. It's the same as `instanceof` except it doesn't need to import the class.\r\n *\r\n * @param object Object\r\n * @param name Class name\r\n * @return Is instance of class\r\n */\n\nexport function is(object, name) {\n  var x = registry.registeredClasses[name];\n  return x != null && object instanceof x;\n}","map":{"version":3,"names":["EventDispatcher","Dictionary","cache","$type","$string","$array","Registry","_this","events","themes","loadedThemes","_uidCount","registeredClasses","_placeholders","invalidSprites","invalidDatas","invalidRawDatas","invalidDataItems","invalidDataRange","invalidPositions","invalidLayouts","baseSprites","baseSpritesByUid","queue","deferred","uid","getUniqueId","noBase","addEventListener","each","sprite","svg","paper","setAttribute","clientWidth","clientHeight","removeAttribute","prototype","Object","defineProperty","get","_map","enumerable","configurable","setCache","key","value","ttl","set","getCache","undefined","dispatch","eventType","data","isEnabled","type","target","dispatchImmediately","getPlaceholder","hasValue","random","addToInvalidComponents","component","baseId","move","removeFromInvalidComponents","remove","addToInvalidSprites","add","removeFromInvalidSprites","addToInvalidPositions","removeFromInvalidPositions","addToInvalidLayouts","removeFromInvalidLayouts","registry","is","object","name","x"],"sources":["D:/APPLICATION/UI/UPL/NEW/node_modules/@amcharts/amcharts4/.internal/core/Registry.js"],"sourcesContent":["import { EventDispatcher } from \"./utils/EventDispatcher\";\r\nimport { Dictionary } from \"./utils/Dictionary\";\r\nimport { cache } from \"./utils/Cache\";\r\nimport * as $type from \"./utils/Type\";\r\nimport * as $string from \"./utils/String\";\r\nimport * as $array from \"./utils/Array\";\r\n/**\r\n * ============================================================================\r\n * MAIN CLASS\r\n * ============================================================================\r\n * @hidden\r\n */\r\n/**\r\n * Registry is used to store miscellaneous system-wide information, like ids,\r\n * maps, themes, and registered classes.\r\n *\r\n * @ignore Exclude from docs\r\n */\r\nvar Registry = /** @class */ (function () {\r\n    function Registry() {\r\n        var _this = this;\r\n        /**\r\n         * Event dispacther.\r\n         */\r\n        this.events = new EventDispatcher();\r\n        /**\r\n         * All currently applied themes. All new chart instances created will\r\n         * automatically inherit and retain System's themes.\r\n         */\r\n        this.themes = [];\r\n        /**\r\n         * List of all loaded available themes.\r\n         *\r\n         * Whenever a theme loads, it registers itself in System's `loadedThemes`\r\n         * collection.\r\n         */\r\n        this.loadedThemes = {};\r\n        /**\r\n         * An indeternal counter used to generate unique IDs.\r\n         *\r\n         * @ignore Exclude from docs\r\n         */\r\n        this._uidCount = 0;\r\n        /**\r\n         * Keeps register of class references so that they can be instnatiated using\r\n         * string key.\r\n         *\r\n         * @ignore Exclude from docs\r\n         */\r\n        this.registeredClasses = {};\r\n        /**\r\n         * Holds all generated placeholders.\r\n         */\r\n        this._placeholders = {};\r\n        /**\r\n         * A list of invalid(ated) [[Sprite]] objects that need to be re-validated\r\n         * during next cycle.\r\n         *\r\n         * @ignore Exclude from docs\r\n         */\r\n        this.invalidSprites = {};\r\n        /**\r\n         * Components are added to this list when their data provider changes to\r\n         * a new one or data is added/removed from their data provider.\r\n         *\r\n         * @ignore Exclude from docs\r\n         */\r\n        this.invalidDatas = {};\r\n        /**\r\n         * Components are added to this list when values of their raw data change.\r\n         * Used when we want a smooth animation from one set of values to another.\r\n         *\r\n         * @ignore Exclude from docs\r\n         */\r\n        this.invalidRawDatas = [];\r\n        /**\r\n         * Components are added to this list when values of their data changes\r\n         * (but not data provider itself).\r\n         *\r\n         * @ignore Exclude from docs\r\n         */\r\n        this.invalidDataItems = [];\r\n        /**\r\n         * Components are added to this list when their data range (selection) is\r\n         * changed, e.g. zoomed.\r\n         *\r\n         * @ignore Exclude from docs\r\n         */\r\n        this.invalidDataRange = [];\r\n        /**\r\n         * A list of [[Sprite]] objects that have invalid(ated) positions, that need\r\n         * to be recalculated.\r\n         *\r\n         * @ignore Exclude from docs\r\n         */\r\n        this.invalidPositions = {};\r\n        /**\r\n         * A list of [[Container]] objects with invalid(ated) layouts.\r\n         *\r\n         * @ignore Exclude from docs\r\n         */\r\n        this.invalidLayouts = {};\r\n        /**\r\n         * An array holding all active (non-disposed) top level elemens.\r\n         *\r\n         * When, for example, a new chart is created, its instance will be added to\r\n         * this array, and will be removed when the chart is disposed.\r\n         */\r\n        this.baseSprites = [];\r\n        /**\r\n         * An UID-based map of base sprites (top-level charts).\r\n         */\r\n        this.baseSpritesByUid = {};\r\n        /**\r\n         * Queued charts (waiting for their turn) to initialize.\r\n         *\r\n         * @see {@link https://www.amcharts.com/docs/v4/concepts/performance/#Daisy_chaining_multiple_charts} for more information\r\n         */\r\n        this.queue = [];\r\n        /**\r\n         * An array of deferred charts that haven't been created yet.\r\n         *\r\n         * @see {@link https://www.amcharts.com/docs/v4/concepts/performance/#Deferred_daisy_chained_instantiation} for more information\r\n         * @since 4.10.0\r\n         */\r\n        this.deferred = [];\r\n        this.uid = this.getUniqueId();\r\n        this.invalidSprites.noBase = [];\r\n        this.invalidDatas.noBase = [];\r\n        this.invalidLayouts.noBase = [];\r\n        this.invalidPositions.noBase = [];\r\n        // This is needed for Angular Universal SSR\r\n        if (typeof addEventListener !== \"undefined\") {\r\n            // This is needed to prevent charts from being cut off when printing\r\n            addEventListener(\"beforeprint\", function () {\r\n                $array.each(_this.baseSprites, function (sprite) {\r\n                    var svg = sprite.paper.svg;\r\n                    svg.setAttribute(\"viewBox\", \"0 0 \" + svg.clientWidth + \" \" + svg.clientHeight);\r\n                });\r\n            });\r\n            addEventListener(\"afterprint\", function () {\r\n                $array.each(_this.baseSprites, function (sprite) {\r\n                    var svg = sprite.paper.svg;\r\n                    svg.removeAttribute(\"viewBox\");\r\n                });\r\n            });\r\n        }\r\n    }\r\n    /**\r\n     * Generates a unique chart system-wide ID.\r\n     *\r\n     * @return Generated ID\r\n     */\r\n    Registry.prototype.getUniqueId = function () {\r\n        var uid = this._uidCount;\r\n        this._uidCount += 1;\r\n        return \"id-\" + uid;\r\n    };\r\n    Object.defineProperty(Registry.prototype, \"map\", {\r\n        /**\r\n         * Returns a universal collection for mapping ids with objects.\r\n         *\r\n         * @ignore Exclude from docs\r\n         * @return Map collection\r\n         */\r\n        get: function () {\r\n            if (!this._map) {\r\n                this._map = new Dictionary();\r\n            }\r\n            return this._map;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    /**\r\n     * Caches value in object's cache.\r\n     *\r\n     * @ignore Exclude from docs\r\n     * @param key    Key\r\n     * @param value  Value\r\n     * @param ttl    TTL in seconds\r\n     */\r\n    Registry.prototype.setCache = function (key, value, ttl) {\r\n        cache.set(this.uid, key, value, ttl);\r\n    };\r\n    /**\r\n     * Retrieves cached value.\r\n     *\r\n     * @ignore Exclude from docs\r\n     * @param key    Key\r\n     * @param value  Value to return if cache is not available\r\n     * @return Value\r\n     */\r\n    Registry.prototype.getCache = function (key, value) {\r\n        if (value === void 0) { value = undefined; }\r\n        return cache.get(this.uid, key, value);\r\n    };\r\n    /**\r\n     * Dispatches an event using own event dispatcher. Will automatically\r\n     * populate event data object with event type and target (this element).\r\n     * It also checks if there are any handlers registered for this sepecific\r\n     * event.\r\n     *\r\n     * @param eventType Event type (name)\r\n     * @param data      Data to pass into event handler(s)\r\n     */\r\n    Registry.prototype.dispatch = function (eventType, data) {\r\n        // @todo Implement proper type check\r\n        if (this.events.isEnabled(eventType)) {\r\n            if (data) {\r\n                data.type = eventType;\r\n                data.target = data.target || this;\r\n                this.events.dispatch(eventType, {\r\n                    type: eventType,\r\n                    target: this\r\n                });\r\n            }\r\n            else {\r\n                this.events.dispatch(eventType, {\r\n                    type: eventType,\r\n                    target: this\r\n                });\r\n            }\r\n        }\r\n    };\r\n    /**\r\n     * Works like `dispatch`, except event is triggered immediately, without\r\n     * waiting for the next frame cycle.\r\n     *\r\n     * @param eventType Event type (name)\r\n     * @param data      Data to pass into event handler(s)\r\n     */\r\n    Registry.prototype.dispatchImmediately = function (eventType, data) {\r\n        // @todo Implement proper type check\r\n        if (this.events.isEnabled(eventType)) {\r\n            if (data) {\r\n                data.type = eventType;\r\n                data.target = data.target || this;\r\n                this.events.dispatchImmediately(eventType, data);\r\n            }\r\n            else {\r\n                this.events.dispatchImmediately(eventType, {\r\n                    type: eventType,\r\n                    target: this\r\n                });\r\n            }\r\n        }\r\n    };\r\n    /**\r\n     * Returns a unique placeholder suitable for the key.\r\n     *\r\n     * @param key  Key\r\n     * @return Random string to be used as placeholder\r\n     */\r\n    Registry.prototype.getPlaceholder = function (key) {\r\n        if ($type.hasValue(this._placeholders[key])) {\r\n            return this._placeholders[key];\r\n        }\r\n        this._placeholders[key] = \"__amcharts_\" + key + \"_\" + $string.random(8) + \"__\";\r\n        return this._placeholders[key];\r\n    };\r\n    /**\r\n     * @ignore\r\n     */\r\n    Registry.prototype.addToInvalidComponents = function (component) {\r\n        if (component.baseId) {\r\n            $array.move(this.invalidDatas[component.baseId], component);\r\n        }\r\n        else {\r\n            $array.move(this.invalidDatas[\"noBase\"], component);\r\n        }\r\n    };\r\n    /**\r\n     * @ignore\r\n     */\r\n    Registry.prototype.removeFromInvalidComponents = function (component) {\r\n        if (component.baseId) {\r\n            $array.remove(this.invalidDatas[component.baseId], component);\r\n        }\r\n        $array.remove(this.invalidDatas[\"noBase\"], component);\r\n    };\r\n    /**\r\n     * @ignore\r\n     */\r\n    Registry.prototype.addToInvalidSprites = function (sprite) {\r\n        if (sprite.baseId) {\r\n            $array.add(this.invalidSprites[sprite.baseId], sprite);\r\n        }\r\n        else {\r\n            $array.add(this.invalidSprites[\"noBase\"], sprite);\r\n        }\r\n    };\r\n    /**\r\n     * @ignore\r\n     */\r\n    Registry.prototype.removeFromInvalidSprites = function (sprite) {\r\n        if (sprite.baseId) {\r\n            $array.remove(this.invalidSprites[sprite.baseId], sprite);\r\n        }\r\n        $array.remove(this.invalidSprites[\"noBase\"], sprite);\r\n    };\r\n    /**\r\n     * @ignore\r\n     */\r\n    Registry.prototype.addToInvalidPositions = function (sprite) {\r\n        if (sprite.baseId) {\r\n            $array.add(this.invalidPositions[sprite.baseId], sprite);\r\n        }\r\n        else {\r\n            $array.add(this.invalidPositions[\"noBase\"], sprite);\r\n        }\r\n    };\r\n    /**\r\n     * @ignore\r\n     */\r\n    Registry.prototype.removeFromInvalidPositions = function (sprite) {\r\n        if (sprite.baseId) {\r\n            $array.remove(this.invalidPositions[sprite.baseId], sprite);\r\n        }\r\n        $array.remove(this.invalidPositions[\"noBase\"], sprite);\r\n    };\r\n    /**\r\n     * @ignore\r\n     */\r\n    Registry.prototype.addToInvalidLayouts = function (sprite) {\r\n        if (sprite.baseId) {\r\n            $array.add(this.invalidLayouts[sprite.baseId], sprite);\r\n        }\r\n        else {\r\n            $array.add(this.invalidLayouts[\"noBase\"], sprite);\r\n        }\r\n    };\r\n    /**\r\n     * @ignore\r\n     */\r\n    Registry.prototype.removeFromInvalidLayouts = function (sprite) {\r\n        if (sprite.baseId) {\r\n            $array.remove(this.invalidLayouts[sprite.baseId], sprite);\r\n        }\r\n        $array.remove(this.invalidLayouts[\"noBase\"], sprite);\r\n    };\r\n    return Registry;\r\n}());\r\nexport { Registry };\r\n/**\r\n * A singleton global instance of [[Registry]].\r\n *\r\n * @ignore Exclude from docs\r\n */\r\nexport var registry = new Registry();\r\n/**\r\n * Returns `true` if object is an instance of the class. It's the same as `instanceof` except it doesn't need to import the class.\r\n *\r\n * @param object Object\r\n * @param name Class name\r\n * @return Is instance of class\r\n */\r\nexport function is(object, name) {\r\n    var x = registry.registeredClasses[name];\r\n    return x != null && object instanceof x;\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}