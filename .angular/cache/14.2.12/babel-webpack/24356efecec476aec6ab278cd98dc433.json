{"ast":null,"code":"/**\r\n * Line series segment module.\r\n * @todo Add description about what this is\r\n */\nimport { __extends } from \"tslib\";\n/**\r\n * ============================================================================\r\n * IMPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\n\nimport { Container } from \"../../core/Container\";\nimport { Sprite, visualProperties } from \"../../core/Sprite\";\nimport { registry } from \"../../core/Registry\";\nimport * as $path from \"../../core/rendering/Path\";\nimport * as $object from \"../../core/utils/Object\";\nimport * as $type from \"../../core/utils/Type\";\nimport { color } from \"../../core/utils/Color\";\nimport * as $smoothing from \"../../core/rendering/Smoothing\";\n/**\r\n * ============================================================================\r\n * MAIN CLASS\r\n * ============================================================================\r\n * @hidden\r\n */\n\n/**\r\n * Represents a line series segment.\r\n *\r\n * A line segment can be used to apply different properties to a part of the\r\n * line series, between two data points.\r\n *\r\n * @see {@link ILineSeriesSegmentEvents} for a list of available events\r\n * @see {@link ILineSeriesSegmentAdapters} for a list of available Adapters\r\n * @todo Example\r\n */\n\nvar LineSeriesSegment =\n/** @class */\nfunction (_super) {\n  __extends(LineSeriesSegment, _super);\n  /**\r\n   * Constructor\r\n   */\n\n\n  function LineSeriesSegment() {\n    var _this = // Init\n    _super.call(this) || this;\n\n    _this.className = \"LineSeriesSegment\"; // Set defaults\n\n    _this.isMeasured = false;\n    _this.interactionsEnabled = false;\n    _this.layout = \"none\"; // Create fill element\n\n    var fillSprite = _this.createChild(Sprite);\n\n    _this.fillSprite = fillSprite;\n    fillSprite.shouldClone = false;\n    fillSprite.setElement(_this.paper.add(\"path\"));\n    fillSprite.isMeasured = false;\n\n    _this._disposers.push(fillSprite); // Create line element\n\n\n    var strokeSprite = _this.createChild(Sprite);\n\n    _this.strokeSprite = strokeSprite;\n    strokeSprite.shouldClone = false;\n    strokeSprite.fill = color();\n    strokeSprite.setElement(_this.paper.add(\"path\"));\n    strokeSprite.isMeasured = false;\n\n    _this._disposers.push(strokeSprite);\n\n    return _this;\n  }\n  /**\r\n   * Draws the series segment.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param points       Points to connect\r\n   * @param closePoints  ?\r\n   * @param smoothnessX  Horizontal bezier setting (?)\r\n   * @param smoothnessY  Vertical bezier setting (?)\r\n   */\n\n\n  LineSeriesSegment.prototype.drawSegment = function (points, closePoints, smoothnessX, smoothnessY) {\n    if (!this.disabled) {\n      if (points.length > 0 && closePoints.length > 0 && $type.isNumber(points[0].x) && $type.isNumber(points[0].y)) {\n        // first moveTo helps to avoid Chrome straight line in the mask bug.\n        var path = $path.moveTo({\n          x: points[0].x - 0.2,\n          y: points[0].y - 0.2\n        }) + $path.moveTo(points[0]);\n        var series = this.series;\n\n        if (series.smoothing == \"bezier\") {\n          path += new $smoothing.Tension(smoothnessX, smoothnessY).smooth(points);\n        } else if (series.smoothing == \"monotoneX\") {\n          path += new $smoothing.MonotoneX({\n            closed: false\n          }).smooth(points);\n        } else if (series.smoothing == \"monotoneY\") {\n          path += new $smoothing.MonotoneY({\n            closed: false\n          }).smooth(points);\n        }\n\n        if (this.strokeOpacity == 0 || this.strokeSprite.strokeOpacity == 0) {// like this and not if != 0, otherwise ranges stroke won't be drawn.\n        } else {\n          this.strokeSprite.path = path;\n        }\n\n        if (this.fillOpacity > 0 || this.fillSprite.fillOpacity > 0) {\n          // helps to avoid drawing fill object if fill is not visible\n          if ($type.isNumber(closePoints[0].x) && $type.isNumber(closePoints[0].y)) {\n            path += $path.lineTo(closePoints[0]);\n\n            if (series.smoothing == \"bezier\") {\n              path += new $smoothing.Tension(smoothnessX, smoothnessY).smooth(closePoints);\n            } else if (series.smoothing == \"monotoneX\") {\n              path += new $smoothing.MonotoneX({\n                closed: false\n              }).smooth(closePoints);\n            } else if (series.smoothing == \"monotoneY\") {\n              path += new $smoothing.MonotoneY({\n                closed: false\n              }).smooth(closePoints);\n            }\n\n            path += $path.lineTo(points[0]);\n            path += $path.closePath();\n            this.fillSprite.path = path;\n          }\n        }\n      } else {\n        this.fillSprite.path = \"\";\n        this.strokeSprite.path = \"\";\n      }\n    }\n  };\n  /**\r\n   * Copies properties from a [[Sprite]] to both line and fill elements.\r\n   *\r\n   * @param source Source [[Sprite]] to copy properties from\r\n   */\n\n\n  LineSeriesSegment.prototype.copyFrom = function (source) {\n    _super.prototype.copyFrom.call(this, source);\n\n    var lineElement = this.strokeSprite;\n    $object.copyProperties(source, lineElement.properties, visualProperties);\n    lineElement.events.copyFrom(source.strokeSprite.events);\n    lineElement.fillOpacity = 0;\n    var fillElement = this.fillSprite;\n    $object.copyProperties(source, fillElement.properties, visualProperties);\n    fillElement.events.copyFrom(source.fillSprite.events);\n    fillElement.strokeOpacity = 0;\n  };\n\n  return LineSeriesSegment;\n}(Container);\n\nexport { LineSeriesSegment };\n/**\r\n * Register class in system, so that it can be instantiated using its name from\r\n * anywhere.\r\n *\r\n * @ignore\r\n */\n\nregistry.registeredClasses[\"LineSeriesSegment\"] = LineSeriesSegment;","map":{"version":3,"names":["__extends","Container","Sprite","visualProperties","registry","$path","$object","$type","color","$smoothing","LineSeriesSegment","_super","_this","call","className","isMeasured","interactionsEnabled","layout","fillSprite","createChild","shouldClone","setElement","paper","add","_disposers","push","strokeSprite","fill","prototype","drawSegment","points","closePoints","smoothnessX","smoothnessY","disabled","length","isNumber","x","y","path","moveTo","series","smoothing","Tension","smooth","MonotoneX","closed","MonotoneY","strokeOpacity","fillOpacity","lineTo","closePath","copyFrom","source","lineElement","copyProperties","properties","events","fillElement","registeredClasses"],"sources":["D:/APPLICATION/UI/UPL/NEW/node_modules/@amcharts/amcharts4/.internal/charts/series/LineSeriesSegment.js"],"sourcesContent":["/**\r\n * Line series segment module.\r\n * @todo Add description about what this is\r\n */\r\nimport { __extends } from \"tslib\";\r\n/**\r\n * ============================================================================\r\n * IMPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\r\nimport { Container } from \"../../core/Container\";\r\nimport { Sprite, visualProperties } from \"../../core/Sprite\";\r\nimport { registry } from \"../../core/Registry\";\r\nimport * as $path from \"../../core/rendering/Path\";\r\nimport * as $object from \"../../core/utils/Object\";\r\nimport * as $type from \"../../core/utils/Type\";\r\nimport { color } from \"../../core/utils/Color\";\r\nimport * as $smoothing from \"../../core/rendering/Smoothing\";\r\n/**\r\n * ============================================================================\r\n * MAIN CLASS\r\n * ============================================================================\r\n * @hidden\r\n */\r\n/**\r\n * Represents a line series segment.\r\n *\r\n * A line segment can be used to apply different properties to a part of the\r\n * line series, between two data points.\r\n *\r\n * @see {@link ILineSeriesSegmentEvents} for a list of available events\r\n * @see {@link ILineSeriesSegmentAdapters} for a list of available Adapters\r\n * @todo Example\r\n */\r\nvar LineSeriesSegment = /** @class */ (function (_super) {\r\n    __extends(LineSeriesSegment, _super);\r\n    /**\r\n     * Constructor\r\n     */\r\n    function LineSeriesSegment() {\r\n        var _this = \r\n        // Init\r\n        _super.call(this) || this;\r\n        _this.className = \"LineSeriesSegment\";\r\n        // Set defaults\r\n        _this.isMeasured = false;\r\n        _this.interactionsEnabled = false;\r\n        _this.layout = \"none\";\r\n        // Create fill element\r\n        var fillSprite = _this.createChild(Sprite);\r\n        _this.fillSprite = fillSprite;\r\n        fillSprite.shouldClone = false;\r\n        fillSprite.setElement(_this.paper.add(\"path\"));\r\n        fillSprite.isMeasured = false;\r\n        _this._disposers.push(fillSprite);\r\n        // Create line element\r\n        var strokeSprite = _this.createChild(Sprite);\r\n        _this.strokeSprite = strokeSprite;\r\n        strokeSprite.shouldClone = false;\r\n        strokeSprite.fill = color();\r\n        strokeSprite.setElement(_this.paper.add(\"path\"));\r\n        strokeSprite.isMeasured = false;\r\n        _this._disposers.push(strokeSprite);\r\n        return _this;\r\n    }\r\n    /**\r\n     * Draws the series segment.\r\n     *\r\n     * @ignore Exclude from docs\r\n     * @param points       Points to connect\r\n     * @param closePoints  ?\r\n     * @param smoothnessX  Horizontal bezier setting (?)\r\n     * @param smoothnessY  Vertical bezier setting (?)\r\n     */\r\n    LineSeriesSegment.prototype.drawSegment = function (points, closePoints, smoothnessX, smoothnessY) {\r\n        if (!this.disabled) {\r\n            if (points.length > 0 && closePoints.length > 0 && $type.isNumber(points[0].x) && $type.isNumber(points[0].y)) {\r\n                // first moveTo helps to avoid Chrome straight line in the mask bug.\r\n                var path = $path.moveTo({ x: points[0].x - 0.2, y: points[0].y - 0.2 }) + $path.moveTo(points[0]);\r\n                var series = this.series;\r\n                if (series.smoothing == \"bezier\") {\r\n                    path += new $smoothing.Tension(smoothnessX, smoothnessY).smooth(points);\r\n                }\r\n                else if (series.smoothing == \"monotoneX\") {\r\n                    path += new $smoothing.MonotoneX({ closed: false }).smooth(points);\r\n                }\r\n                else if (series.smoothing == \"monotoneY\") {\r\n                    path += new $smoothing.MonotoneY({ closed: false }).smooth(points);\r\n                }\r\n                if (this.strokeOpacity == 0 || this.strokeSprite.strokeOpacity == 0) {\r\n                    // like this and not if != 0, otherwise ranges stroke won't be drawn.\r\n                }\r\n                else {\r\n                    this.strokeSprite.path = path;\r\n                }\r\n                if (this.fillOpacity > 0 || this.fillSprite.fillOpacity > 0) { // helps to avoid drawing fill object if fill is not visible\r\n                    if ($type.isNumber(closePoints[0].x) && $type.isNumber(closePoints[0].y)) {\r\n                        path += $path.lineTo(closePoints[0]);\r\n                        if (series.smoothing == \"bezier\") {\r\n                            path += new $smoothing.Tension(smoothnessX, smoothnessY).smooth(closePoints);\r\n                        }\r\n                        else if (series.smoothing == \"monotoneX\") {\r\n                            path += new $smoothing.MonotoneX({ closed: false }).smooth(closePoints);\r\n                        }\r\n                        else if (series.smoothing == \"monotoneY\") {\r\n                            path += new $smoothing.MonotoneY({ closed: false }).smooth(closePoints);\r\n                        }\r\n                        path += $path.lineTo(points[0]);\r\n                        path += $path.closePath();\r\n                        this.fillSprite.path = path;\r\n                    }\r\n                }\r\n            }\r\n            else {\r\n                this.fillSprite.path = \"\";\r\n                this.strokeSprite.path = \"\";\r\n            }\r\n        }\r\n    };\r\n    /**\r\n     * Copies properties from a [[Sprite]] to both line and fill elements.\r\n     *\r\n     * @param source Source [[Sprite]] to copy properties from\r\n     */\r\n    LineSeriesSegment.prototype.copyFrom = function (source) {\r\n        _super.prototype.copyFrom.call(this, source);\r\n        var lineElement = this.strokeSprite;\r\n        $object.copyProperties(source, lineElement.properties, visualProperties);\r\n        lineElement.events.copyFrom(source.strokeSprite.events);\r\n        lineElement.fillOpacity = 0;\r\n        var fillElement = this.fillSprite;\r\n        $object.copyProperties(source, fillElement.properties, visualProperties);\r\n        fillElement.events.copyFrom(source.fillSprite.events);\r\n        fillElement.strokeOpacity = 0;\r\n    };\r\n    return LineSeriesSegment;\r\n}(Container));\r\nexport { LineSeriesSegment };\r\n/**\r\n * Register class in system, so that it can be instantiated using its name from\r\n * anywhere.\r\n *\r\n * @ignore\r\n */\r\nregistry.registeredClasses[\"LineSeriesSegment\"] = LineSeriesSegment;\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}