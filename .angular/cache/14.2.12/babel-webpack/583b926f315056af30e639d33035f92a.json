{"ast":null,"code":"/**\r\n * Polygon module.\r\n */\nimport { __extends } from \"tslib\";\n/**\r\n * ============================================================================\r\n * IMPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\n\nimport { Sprite } from \"../Sprite\";\nimport { Morpher } from \"../utils/Morpher\";\nimport { registry } from \"../Registry\";\nimport * as $path from \"../rendering/Path\";\nimport * as $type from \"../utils/Type\";\n/**\r\n * ============================================================================\r\n * MAIN CLASS\r\n * ============================================================================\r\n * @hidden\r\n */\n\n/**\r\n * Draws a polygon.\r\n *\r\n * @see {@link IPolygonEvents} for a list of available events\r\n * @see {@link IPolygonAdapters} for a list of available Adapters\r\n */\n\nvar Polygon =\n/** @class */\nfunction (_super) {\n  __extends(Polygon, _super);\n  /**\r\n   * Constructor\r\n   */\n\n\n  function Polygon() {\n    var _this = _super.call(this) || this;\n\n    _this.className = \"Polygon\";\n    _this.element = _this.paper.add(\"path\");\n    _this.shapeRendering = \"auto\";\n    _this._currentPoints = [];\n\n    _this.applyTheme();\n\n    return _this;\n  }\n\n  Object.defineProperty(Polygon.prototype, \"points\", {\n    /**\r\n     * @return Polygon points\r\n     */\n    get: function () {\n      var points = this.getPropertyValue(\"points\");\n      var path = this.path;\n\n      if (path && (!points || points.length == 0)) {\n        var valueStr = path.slice(1, path.length - 1);\n        var segments = valueStr.split(\"ZM\");\n\n        for (var s = 0; s < segments.length; s++) {\n          var segment = segments[s];\n\n          if (segment.length > 0) {\n            var areaHole = segment.split(\"M\");\n            var areaArr = areaHole[0];\n            var holeArr = areaHole[1];\n\n            if (areaArr && areaArr.length > 0) {\n              var pointsArr = areaArr.split(\"L\");\n\n              if (pointsArr.length > 0) {\n                var area = [];\n                var areaAndHole = [area];\n                points.push(areaAndHole);\n\n                for (var p = 0; p < pointsArr.length; p++) {\n                  var coords = pointsArr[p].split(\",\");\n                  area.push({\n                    x: +coords[0],\n                    y: +coords[1]\n                  });\n                }\n\n                if (holeArr && holeArr.length > 0) {\n                  var pointsArr_1 = holeArr.split(\"L\");\n\n                  if (pointsArr_1.length > 0) {\n                    var hole = [];\n                    areaAndHole.push(hole);\n\n                    for (var p = pointsArr_1.length - 1; p >= 0; p--) {\n                      var coords = pointsArr_1[p].split(\",\");\n                      hole.push({\n                        x: +coords[0],\n                        y: +coords[1]\n                      });\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n\n        this.setPropertyValue(\"points\", points);\n        this._currentPoints = points;\n      }\n\n      return points;\n    },\n\n    /**\r\n     * An array of X/Y coordinates for each elbow of the polygon.\r\n     *\r\n     * @todo Example\r\n     * @param points  Polygon points\r\n     */\n    set: function (points) {\n      this.setPropertyValue(\"points\", points, true);\n      this._currentPoints = points;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Polygon.prototype, \"currentPoints\", {\n    /**\r\n     * @return Polygon points\r\n     */\n    get: function () {\n      if ((!this._currentPoints || this._currentPoints.length == 0) && this.path) {\n        this._currentPoints = this.points;\n      }\n\n      return this._currentPoints;\n    },\n\n    /**\r\n     * Current points. Used when morphing the element, so that original `points`\r\n     * are not overwritten.\r\n     *\r\n     * @param points  Polygon points\r\n     */\n    set: function (points) {\n      if (this._currentPoints != points) {\n        this._currentPoints = points;\n        this.draw();\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\r\n   * Draws the element.\r\n   *\r\n   * @ignore Exclude from docs\r\n   */\n\n  Polygon.prototype.draw = function () {\n    var path = \"\";\n    var points = this._currentPoints;\n    var left;\n    var right;\n    var top;\n    var bottom;\n\n    if (points.length > 0) {\n      // separate areas\n      for (var i = 0, len = points.length; i < len; i++) {\n        // surface\n        var surface = points[i][0];\n        var hole = points[i][1];\n\n        if (surface && surface.length > 0) {\n          var point = surface[0];\n          path += $path.moveTo(point);\n\n          for (var s = 0; s < surface.length; s++) {\n            point = surface[s];\n            path += $path.lineTo(point);\n\n            if (!$type.isNumber(right) || right < point.x) {\n              right = point.x;\n            }\n\n            if (!$type.isNumber(left) || left > point.x) {\n              left = point.x;\n            }\n\n            if (!$type.isNumber(top) || top > point.y) {\n              top = point.y;\n            }\n\n            if (!$type.isNumber(bottom) || bottom < point.y) {\n              bottom = point.y;\n            }\n          }\n        } // hole\n\n\n        if (hole && hole.length > 0) {\n          var point = hole[0];\n          path += $path.moveTo(point);\n\n          for (var h = 0, hlen = hole.length; h < hlen; h++) {\n            point = hole[h];\n            path += $path.lineTo(point);\n          }\n        }\n      }\n\n      if (path) {\n        path += $path.closePath();\n      }\n\n      this.bbox.x = left;\n      this.bbox.y = top;\n      this.bbox.width = right - left;\n      this.bbox.height = bottom - top;\n\n      _super.prototype.setPath.call(this, path);\n    }\n  };\n  /**\r\n   * @ignore\r\n   */\n\n\n  Polygon.prototype.setPath = function (value) {\n    if (_super.prototype.setPath.call(this, value)) {\n      this.points = [];\n      this._bbox = this.group.getBBox();\n      return true;\n    }\n\n    return false;\n  };\n  /**\r\n   * Measures element\r\n   */\n\n\n  Polygon.prototype.measureElement = function () {// Overriding to avoid extra measurement.\n  };\n\n  Object.defineProperty(Polygon.prototype, \"centerPoint\", {\n    /**\r\n     * A calculated center point for the shape.\r\n     *\r\n     * @readonly\r\n     * @return Center\r\n     */\n    get: function () {\n      return {\n        x: this.bbox.x + this.bbox.width / 2,\n        y: this.bbox.y + this.bbox.height / 2\n      };\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Polygon.prototype, \"morpher\", {\n    /**\r\n     * A [[Morpher]] instance that is used to morph polygon into some other\r\n     * shape.\r\n     *\r\n     * @readonly\r\n     * @return Morpher instance\r\n     */\n    get: function () {\n      if (!this._morpher) {\n        this._morpher = new Morpher(this);\n\n        this._disposers.push(this._morpher);\n      }\n\n      return this._morpher;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  return Polygon;\n}(Sprite);\n\nexport { Polygon };\n/**\r\n * Register class in system, so that it can be instantiated using its name from\r\n * anywhere.\r\n *\r\n * @ignore\r\n */\n\nregistry.registeredClasses[\"Polygon\"] = Polygon;","map":{"version":3,"names":["__extends","Sprite","Morpher","registry","$path","$type","Polygon","_super","_this","call","className","element","paper","add","shapeRendering","_currentPoints","applyTheme","Object","defineProperty","prototype","get","points","getPropertyValue","path","length","valueStr","slice","segments","split","s","segment","areaHole","areaArr","holeArr","pointsArr","area","areaAndHole","push","p","coords","x","y","pointsArr_1","hole","setPropertyValue","set","enumerable","configurable","draw","left","right","top","bottom","i","len","surface","point","moveTo","lineTo","isNumber","h","hlen","closePath","bbox","width","height","setPath","value","_bbox","group","getBBox","measureElement","_morpher","_disposers","registeredClasses"],"sources":["D:/APPLICATION/UI/UPL/NEW/node_modules/@amcharts/amcharts4/.internal/core/elements/Polygon.js"],"sourcesContent":["/**\r\n * Polygon module.\r\n */\r\nimport { __extends } from \"tslib\";\r\n/**\r\n * ============================================================================\r\n * IMPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\r\nimport { Sprite } from \"../Sprite\";\r\nimport { Morpher } from \"../utils/Morpher\";\r\nimport { registry } from \"../Registry\";\r\nimport * as $path from \"../rendering/Path\";\r\nimport * as $type from \"../utils/Type\";\r\n/**\r\n * ============================================================================\r\n * MAIN CLASS\r\n * ============================================================================\r\n * @hidden\r\n */\r\n/**\r\n * Draws a polygon.\r\n *\r\n * @see {@link IPolygonEvents} for a list of available events\r\n * @see {@link IPolygonAdapters} for a list of available Adapters\r\n */\r\nvar Polygon = /** @class */ (function (_super) {\r\n    __extends(Polygon, _super);\r\n    /**\r\n     * Constructor\r\n     */\r\n    function Polygon() {\r\n        var _this = _super.call(this) || this;\r\n        _this.className = \"Polygon\";\r\n        _this.element = _this.paper.add(\"path\");\r\n        _this.shapeRendering = \"auto\";\r\n        _this._currentPoints = [];\r\n        _this.applyTheme();\r\n        return _this;\r\n    }\r\n    Object.defineProperty(Polygon.prototype, \"points\", {\r\n        /**\r\n         * @return Polygon points\r\n         */\r\n        get: function () {\r\n            var points = this.getPropertyValue(\"points\");\r\n            var path = this.path;\r\n            if (path && (!points || points.length == 0)) {\r\n                var valueStr = path.slice(1, path.length - 1);\r\n                var segments = valueStr.split(\"ZM\");\r\n                for (var s = 0; s < segments.length; s++) {\r\n                    var segment = segments[s];\r\n                    if (segment.length > 0) {\r\n                        var areaHole = segment.split(\"M\");\r\n                        var areaArr = areaHole[0];\r\n                        var holeArr = areaHole[1];\r\n                        if (areaArr && areaArr.length > 0) {\r\n                            var pointsArr = areaArr.split(\"L\");\r\n                            if (pointsArr.length > 0) {\r\n                                var area = [];\r\n                                var areaAndHole = [area];\r\n                                points.push(areaAndHole);\r\n                                for (var p = 0; p < pointsArr.length; p++) {\r\n                                    var coords = pointsArr[p].split(\",\");\r\n                                    area.push({ x: +coords[0], y: +coords[1] });\r\n                                }\r\n                                if (holeArr && holeArr.length > 0) {\r\n                                    var pointsArr_1 = holeArr.split(\"L\");\r\n                                    if (pointsArr_1.length > 0) {\r\n                                        var hole = [];\r\n                                        areaAndHole.push(hole);\r\n                                        for (var p = pointsArr_1.length - 1; p >= 0; p--) {\r\n                                            var coords = pointsArr_1[p].split(\",\");\r\n                                            hole.push({ x: +coords[0], y: +coords[1] });\r\n                                        }\r\n                                    }\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n                this.setPropertyValue(\"points\", points);\r\n                this._currentPoints = points;\r\n            }\r\n            return points;\r\n        },\r\n        /**\r\n         * An array of X/Y coordinates for each elbow of the polygon.\r\n         *\r\n         * @todo Example\r\n         * @param points  Polygon points\r\n         */\r\n        set: function (points) {\r\n            this.setPropertyValue(\"points\", points, true);\r\n            this._currentPoints = points;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(Polygon.prototype, \"currentPoints\", {\r\n        /**\r\n         * @return Polygon points\r\n         */\r\n        get: function () {\r\n            if ((!this._currentPoints || this._currentPoints.length == 0) && this.path) {\r\n                this._currentPoints = this.points;\r\n            }\r\n            return this._currentPoints;\r\n        },\r\n        /**\r\n         * Current points. Used when morphing the element, so that original `points`\r\n         * are not overwritten.\r\n         *\r\n         * @param points  Polygon points\r\n         */\r\n        set: function (points) {\r\n            if (this._currentPoints != points) {\r\n                this._currentPoints = points;\r\n                this.draw();\r\n            }\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    /**\r\n     * Draws the element.\r\n     *\r\n     * @ignore Exclude from docs\r\n     */\r\n    Polygon.prototype.draw = function () {\r\n        var path = \"\";\r\n        var points = this._currentPoints;\r\n        var left;\r\n        var right;\r\n        var top;\r\n        var bottom;\r\n        if (points.length > 0) {\r\n            // separate areas\r\n            for (var i = 0, len = points.length; i < len; i++) {\r\n                // surface\r\n                var surface = points[i][0];\r\n                var hole = points[i][1];\r\n                if (surface && surface.length > 0) {\r\n                    var point = surface[0];\r\n                    path += $path.moveTo(point);\r\n                    for (var s = 0; s < surface.length; s++) {\r\n                        point = surface[s];\r\n                        path += $path.lineTo(point);\r\n                        if (!$type.isNumber(right) || (right < point.x)) {\r\n                            right = point.x;\r\n                        }\r\n                        if (!$type.isNumber(left) || (left > point.x)) {\r\n                            left = point.x;\r\n                        }\r\n                        if (!$type.isNumber(top) || (top > point.y)) {\r\n                            top = point.y;\r\n                        }\r\n                        if (!$type.isNumber(bottom) || (bottom < point.y)) {\r\n                            bottom = point.y;\r\n                        }\r\n                    }\r\n                }\r\n                // hole\r\n                if (hole && hole.length > 0) {\r\n                    var point = hole[0];\r\n                    path += $path.moveTo(point);\r\n                    for (var h = 0, hlen = hole.length; h < hlen; h++) {\r\n                        point = hole[h];\r\n                        path += $path.lineTo(point);\r\n                    }\r\n                }\r\n            }\r\n            if (path) {\r\n                path += $path.closePath();\r\n            }\r\n            this.bbox.x = left;\r\n            this.bbox.y = top;\r\n            this.bbox.width = right - left;\r\n            this.bbox.height = bottom - top;\r\n            _super.prototype.setPath.call(this, path);\r\n        }\r\n    };\r\n    /**\r\n     * @ignore\r\n     */\r\n    Polygon.prototype.setPath = function (value) {\r\n        if (_super.prototype.setPath.call(this, value)) {\r\n            this.points = [];\r\n            this._bbox = this.group.getBBox();\r\n            return true;\r\n        }\r\n        return false;\r\n    };\r\n    /**\r\n     * Measures element\r\n     */\r\n    Polygon.prototype.measureElement = function () {\r\n        // Overriding to avoid extra measurement.\r\n    };\r\n    Object.defineProperty(Polygon.prototype, \"centerPoint\", {\r\n        /**\r\n         * A calculated center point for the shape.\r\n         *\r\n         * @readonly\r\n         * @return Center\r\n         */\r\n        get: function () {\r\n            return { x: this.bbox.x + this.bbox.width / 2, y: this.bbox.y + this.bbox.height / 2 };\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(Polygon.prototype, \"morpher\", {\r\n        /**\r\n         * A [[Morpher]] instance that is used to morph polygon into some other\r\n         * shape.\r\n         *\r\n         * @readonly\r\n         * @return Morpher instance\r\n         */\r\n        get: function () {\r\n            if (!this._morpher) {\r\n                this._morpher = new Morpher(this);\r\n                this._disposers.push(this._morpher);\r\n            }\r\n            return this._morpher;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    return Polygon;\r\n}(Sprite));\r\nexport { Polygon };\r\n/**\r\n * Register class in system, so that it can be instantiated using its name from\r\n * anywhere.\r\n *\r\n * @ignore\r\n */\r\nregistry.registeredClasses[\"Polygon\"] = Polygon;\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}