{"ast":null,"code":"/**\r\n * Text class deals with all text placed on chart.\r\n */\nimport { __extends } from \"tslib\";\n/**\r\n * ============================================================================\r\n * IMPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\n\nimport { Container } from \"../Container\";\nimport { registry } from \"../Registry\";\nimport { getTextFormatter } from \"../formatters/TextFormatter\";\nimport { MultiDisposer } from \"../utils/Disposer\";\nimport { InterfaceColorSet } from \"../../core/utils/InterfaceColorSet\";\nimport * as $math from \"../utils/Math\";\nimport * as $utils from \"../utils/Utils\";\nimport * as $type from \"../utils/Type\";\nimport * as $dom from \"../utils/DOM\";\nimport { defaultRules, ResponsiveBreakpoints } from \"../utils/Responsive\";\nimport { options } from \"../Options\";\n;\n/**\r\n * ============================================================================\r\n * MAIN CLASS\r\n * ============================================================================\r\n * @hidden\r\n */\n\n/**\r\n * Text is used to display highly configurable, data-enabled textual elements.\r\n *\r\n * ## Data Binding\r\n *\r\n * A Text element can dynamically parse and populate its contents with values\r\n * from a [[DataItem]].\r\n *\r\n * To activate such binding, set element's `dataItem` property.\r\n *\r\n * When activated, text contents will be parsed for special tags, e.g.:\r\n *\r\n * ```TypeScript\r\n * label.dataItem = myDataItem;\r\n * label.text = \"The title is: {title}\";\r\n * ```\r\n * ```JavaScript\r\n * label.dataItem = myDataItem;\r\n * label.text = \"The title is: {title}\";\r\n * ```\r\n *\r\n * The above will automatically replace \"{title}\" in the string with the\r\n * actual data value from `myDataItem`.\r\n *\r\n * Note, that most often dataItem is set by the Component.\r\n *\r\n *\r\n * @see {@link ILabelEvents} for a list of available events\r\n * @see {@link ILabelAdapters} for a list of available Adapters\r\n * @see {@link https://www.amcharts.com/docs/v4/concepts/formatters/formatting-strings/} for info on string formatting and data binding\r\n * @todo Vertical align\r\n * @important\r\n */\n\nvar Label =\n/** @class */\nfunction (_super) {\n  __extends(Label, _super);\n  /**\r\n   * Constructor\r\n   */\n\n\n  function Label() {\n    var _this = // Execute super's constructor\n    _super.call(this) || this;\n    /**\r\n     * Indicates if the whole text does not fit into max dimenstions set for it.\r\n     */\n\n\n    _this.isOversized = false; // Set this class name\n\n    _this.className = \"Label\";\n    _this.fill = new InterfaceColorSet().getFor(\"text\"); // not good to set this, as then these will appear on each label and values set on container won't be applied.\n    //this.textDecoration = \"none\";\n    //this.fontWeight = \"normal\";\n    // Set defaults\n\n    _this.wrap = false;\n    _this.truncate = false;\n    _this.fullWords = true;\n    _this.ellipsis = \"â€¦\";\n    _this.textAlign = \"start\";\n    _this.textValign = \"top\";\n    _this.layout = \"absolute\";\n    _this.baseLineRatio = -0.27; //this.pixelPerfect = true;\n\n    _this._positionPrecision = 1; // Add events to watch for maxWidth/maxHeight changes so that we can\n    // invalidate this\n\n    _this.events.on(\"maxsizechanged\", function () {\n      if (_this.inited) {\n        _this.handleMaxSize();\n      }\n    }, _this, false); // this solves strange bug when text just added to svg is 0x0\n\n\n    _this.events.once(\"validated\", _this.handleValidate, _this, false); // Aply theme\n\n\n    _this.applyTheme();\n\n    return _this;\n  }\n  /**\r\n   * A placeholder method that is called **after** element finishes drawing\r\n   * itself.\r\n   *\r\n   * @ignore Exclude from docs\r\n   */\n\n\n  Label.prototype.afterDraw = function () {\n    // since we removed validatePosition from sprite, we still need it here to handle rotated text\n    _super.prototype.afterDraw.call(this);\n\n    this.validatePosition();\n  };\n  /**\r\n   * Sets [[Paper]] instance to use to draw elements.\r\n   * @ignore\r\n   * @param paper Paper\r\n   * @return true if paper was changed, false, if it's the same\r\n   */\n\n\n  Label.prototype.setPaper = function (paper) {\n    var changed = _super.prototype.setPaper.call(this, paper);\n\n    if (changed) {\n      this.hardInvalidate();\n    }\n\n    return changed;\n  };\n  /**\r\n   * @ignore\r\n   */\n\n\n  Label.prototype.handleValidate = function () {\n    if ((this.currentText || this.text) && (this.bbox.width == 0 || this.bbox.height == 0)) {\n      registry.events.once(\"exitframe\", this.hardInvalidate, this);\n    }\n  };\n  /**\r\n   * @ignore\r\n   */\n\n\n  Label.prototype.handleMaxSize = function () {\n    if (this.bbox.width > this.availableWidth || this.bbox.width < this.availableWidth && (this.isOversized || this.truncate) || this.bbox.height > this.availableHeight || this.bbox.height < this.availableHeight && this.isOversized) {\n      this.invalidate();\n    } else {//this.alignSVGText();\n    }\n  };\n  /**\r\n   * [arrange description]\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @todo Description\r\n   */\n\n\n  Label.prototype.arrange = function () {};\n  /**\r\n   * Updates current text according to data item and supported features.\r\n   * Returns `true` if current text has changed.\r\n   *\r\n   * @return Text changed?\r\n   */\n\n\n  Label.prototype.updateCurrentText = function () {\n    // Determine output format\n    var output, text;\n\n    if ($utils.isNotEmpty(this.html) && this.paper.supportsForeignObject()) {\n      // We favor HTML text if it's set and browser supports `foreignObject`\n      output = \"html\";\n      text = this.html;\n    } else {\n      output = \"svg\";\n      text = this.text;\n    } // Need to toString source?\n\n\n    if ($type.isObject(text)) {\n      text = text.toString();\n    } // Need to format text all the time\n\n\n    if ($type.hasValue(text) && text !== \"\") {\n      text = this.populateString(text, this.dataItem);\n    }\n\n    if (output == \"html\") {\n      if (this._adapterO) {\n        text = this._adapterO.apply(\"htmlOutput\", text);\n      }\n    } else {\n      if (this._adapterO) {\n        text = this._adapterO.apply(\"textOutput\", text);\n      }\n    } // Update the text\n\n\n    var changed = text != this.currentText || output != this._currentFormat;\n    this.currentText = text;\n    this._currentFormat = output;\n    return changed;\n  };\n  /**\r\n   * Hard invalidate means the text will be redrawn even if it hasn't changed.\r\n   * This is used when we change `fontSize`, `fontFamily`, or for some other\r\n   * reasons.\r\n   */\n\n\n  Label.prototype.hardInvalidate = function () {\n    this._prevStatus = \"\";\n    this.invalidate();\n  };\n  /**\r\n   * Gets line bbox, uses caching to save cpu\r\n   * @ignore\r\n   */\n\n\n  Label.prototype.getLineBBox = function (lineInfo) {\n    //let cacheKey = lineInfo.text + lineInfo.style;\n    //let lineBBox = this.getCache(cacheKey);\n    //if (!lineBBox) {\n    //lineBBox = lineInfo.element.getBBox();\n    //if (lineBBox.width != 0 && lineBBox.height != 0) {\n    //\tthis.setCache(cacheKey, lineBBox, 5000);\n    //}\n    //}\n    var element = lineInfo && lineInfo.element;\n    var node = element && element.node; // Check for the parent Node to avoid FF from throwing errors\n\n    if (node && node.parentNode) {\n      lineInfo.bbox = element.getBBox();\n    }\n  };\n  /**\r\n   * Draws the textual label.\r\n   *\r\n   * @ignore Exclude from docs\r\n   */\n\n\n  Label.prototype.draw = function () {\n    // Draw super\n    _super.prototype.draw.call(this);\n\n    var oldW = this.bbox.width;\n    var oldH = this.bbox.height;\n    var topParent = this.topParent;\n\n    if (topParent) {\n      if (!topParent.maxWidth || !topParent.maxHeight) {\n        topParent.events.once(\"maxsizechanged\", this.hardInvalidate, this, false);\n        return;\n      }\n    } // Calculate max width and height\n\n\n    var maxWidth = $math.max(this.availableWidth - this.pixelPaddingLeft - this.pixelPaddingRight, 0);\n    var maxHeight = $math.max(this.availableHeight - this.pixelPaddingTop - this.pixelPaddingBottom, 0); // save\n\n    var status = maxHeight + \",\" + maxWidth + this.wrap + this.truncate + this.fullWords + this.rtl + this.ellipsis; // Update text\n\n    if (!this.updateCurrentText() && this.inited && this._prevStatus == status) {\n      return;\n    }\n\n    this._measuredWidth = 0;\n    this._measuredHeight = 0; // Reset\n\n    this.isOversized = false; // Determine output format\n\n    var output = this._currentFormat;\n    var text = this.currentText; // Empty string\n\n    if (!$type.hasValue(text) || text == \"\") {\n      this.element.attr({\n        display: \"none\"\n      });\n      return;\n    } // Chop up text into lines\n    // We're still processing SVG and HTML in the same way for now\n\n\n    var lines = text.split(\"\\n\"); // Do we need to go through the trouble of measuring lines\n    //let measure: boolean = true;// (lines.length > 1) || this.wrap;\n\n    this._prevStatus = status;\n    this.textAlign = this.textAlign; // need this to measure\n\n    var display = this.group.getAttr(\"display\");\n\n    if (display == \"none\") {\n      this.group.removeAttr(\"display\");\n    }\n\n    if (this.textPathElement) {\n      this.textPathElement.removeChildren();\n    } // SVG or HTML?\n\n\n    if (output === \"svg\") {\n      /**\r\n       * SVG\r\n       */\n      this.element.removeAttr(\"display\"); // Clear the element\n\n      var group = this.element; //group.removeChildren();\n\n      this.resetBBox(); // Init state variables\n\n      var currentHeight = 0;\n      var currentFormat = \"\"; // Process each line\n\n      for (var i = 0; i < lines.length; i++) {\n        // Get line\n        var line = lines[i]; // Check if line is empty\n\n        if (line == \"\") {\n          // It is, let's just update currentHeight and go to the next one\n          // If it's the first line, we'll have to use arbirary line height,\n          // since there's nothing to measure. For subsequent lines we can take\n          // previous line's height\n          var tempElement = this.getSVGLineElement(\"\", 0);\n          tempElement.add(this.getSvgElement(\".\", getTextFormatter().translateStyleShortcuts(currentFormat)));\n          group.add(tempElement);\n          var offset = Math.ceil(tempElement.getBBox().height);\n\n          if (offset > 0) {\n            currentHeight += offset;\n          }\n\n          group.removeElement(tempElement); // Clear cache if necessary\n\n          var lineInfo_1 = this.getLineInfo(i);\n\n          if (lineInfo_1) {\n            lineInfo_1.text = \"\";\n            lineInfo_1.element.textContent = \"\";\n          }\n\n          continue;\n        } // Chunk up the line and process each chunk\n\n\n        var chunks = getTextFormatter().chunk(line, null, this.ignoreFormatting);\n        var currentLineHeight = 0;\n        var firstChunk = true;\n        var skipTextChunks = false; // Create line element or grab it from cache\n\n        var lineInfo = this.getLineInfo(i);\n\n        if (lineInfo) {\n          // Empty line\n          lineInfo.text = \"\";\n          lineInfo.element.textContent = \"\";\n        } else {\n          // Init new line info\n          lineInfo = {\n            \"text\": \"\",\n            \"element\": this.getSVGLineElement(\"\", 0),\n            \"complex\": false\n          }; // Create the line element\n          //lineInfo.element = this.getSVGLineElement(\"\", 0);\n          //lineElement = this.getSVGLineElement(\"\", 0);\n\n          group.add(lineInfo.element);\n        }\n\n        lineInfo.element.removeAttr(\"display\");\n        lineInfo.element.removeChildren(); // memory leak without this\n\n        if (this.textPathElement) {\n          lineInfo.element.add(this.textPathElement);\n        }\n        /*// @todo not needed anymore\r\n        if (this.rtl) {\r\n            chunks.reverse();\r\n        }*/\n        // Process each chunk\n\n\n        for (var x = 0; x < chunks.length; x++) {\n          // If there's more than one chunk, means the line is \"complex\"\n          if (x) {\n            lineInfo.complex = true;\n          } // Get chunk\n\n\n          var chunk = chunks[x]; // Is this chunk format or text?\n\n          if (chunk.type === \"format\") {\n            // Log current format, so that we can apply it to multiple lines if\n            // necessary\n            currentFormat = chunk.text;\n          } else {\n            // It's text block\n            // Need to skip?\n            // We do this when truncating. We can't just simply go ahead and\n            // abandon chunk processing as they might have formatting\n            // instructions in them that are relevant for subsequent lines\n            if (skipTextChunks) {\n              continue;\n            } // Add chunk to the current element\n            //lineInfo.element.content += $utils.trim(getTextFormatter().format(currentFormat + chunk.text, output));\n\n\n            lineInfo.text = chunk.text;\n            lineInfo.style = getTextFormatter().translateStyleShortcuts(currentFormat);\n\n            if (this.textPathElement) {\n              this.getSvgElement(lineInfo.text, lineInfo.style, this.textPathElement);\n            } else {\n              this.getSvgElement(lineInfo.text, lineInfo.style, lineInfo.element);\n            }\n\n            this.getLineBBox(lineInfo);\n            lineInfo.bbox.width = Math.ceil(lineInfo.bbox.width); // Updated current line height\n\n            if (currentLineHeight < lineInfo.bbox.height) {\n              currentLineHeight = lineInfo.bbox.height;\n            } // Wrapping?\n\n\n            if ((this.wrap || this.truncate) && lineInfo.bbox.width > maxWidth) {\n              // Set oversized\n              this.isOversized = true; // Take temporary measurements\n\n              var lineText = lineInfo.element.textContent;\n              var avgCharWidth = lineInfo.bbox.width / lineText.length; // * .9;\n              // Calculate average number of symbols / width\n\n              var excessChars = $math.min(Math.ceil((lineInfo.bbox.width - maxWidth) / avgCharWidth), lineText.length); // Are we truncating or auto-wrapping text?\n\n              if (this.truncate) {\n                /**\r\n                 * Processing line truncation\r\n                 * With the addition of each text chunk we measure if current\r\n                 * line does not exceed maxWidth. If it does, we will stop\r\n                 * addition of further chunks as well as try to truncate\r\n                 * current or any number of previous chunks with an added\r\n                 * ellipsis\r\n                 */\n                // Indicator whether we need to add ellipsis to the current\n                // element, even if it fits. This is needed to indicate\n                // whether we have already removed some subsequent chunks in\n                // which case we need to add ellipsis.\n                var addEllipsis = false; // Process each child in the temporary line, until the whole\n                // line fits, preferably with an ellipsis\n                // TODO use iterator instead\n\n                var node_1 = lineInfo.element.node;\n\n                if (node_1 && node_1.childNodes) {\n                  for (var e = lineInfo.element.node.childNodes.length - 1; e >= 0; e--) {\n                    // Get current element\n                    var node_2 = lineInfo.element.node.childNodes[e]; // Add ellipsis only if previous chunk was removed in full\n                    // and this chunk already fits\n                    //if (addEllipsis && (bbox.width <= maxWidth)) {\n\n                    if (addEllipsis && lineInfo.bbox.width <= maxWidth) {\n                      // Add ellipsis\n                      node_2.textContent += \" \" + this.ellipsis; // Measure again (we need to make sure ellipsis fits)\n\n                      lineInfo.bbox = lineInfo.element.getBBox();\n                      lineInfo.bbox.width = Math.floor(lineInfo.bbox.width); // If it fits, we're done here\n                      // If it doesn't we continue rolling\n\n                      if (lineInfo.bbox.width <= maxWidth) {\n                        break;\n                      }\n                    }\n\n                    addEllipsis = false; // Get element text\n\n                    var elementText = node_2.textContent; // Calculate average number of symbols / width\n\n                    lineText = lineInfo.element.textContent;\n                    excessChars = $math.min(Math.ceil((lineInfo.bbox.width - maxWidth) / avgCharWidth), lineText.length); // Do this until we fit\n\n                    while (lineInfo.bbox.width > maxWidth && excessChars <= lineText.length && excessChars > 0) {\n                      // Calculate max available chars\n                      var maxChars = $math.max(lineText.length - excessChars - this.ellipsis.length, 1); // Is there anything left?\n\n                      if (maxChars <= 1) {\n                        // Nope, let's jump to the previous item\n                        // Set excess characters to zero so that this loop does\n                        // not repeat when it over\n                        excessChars = 0; // Add ellipsis to previous item\n                        // Subsequent iterations will check if the ellipsis fits\n\n                        if (e > 0) {\n                          // Indicating to add ellipsis to previous item\n                          addEllipsis = true; // Removing this node\n\n                          lineInfo.element.node.removeChild(node_2);\n                        }\n                      } // Truncate the text\n\n\n                      elementText = $utils.truncateWithEllipsis(elementText, maxChars, this.ellipsis, this.fullWords, this.rtl);\n\n                      if (elementText.length > maxChars && this.fullWords) {\n                        // Still too long?\n                        // Let's try truncating breaking words anyway\n                        elementText = $utils.truncateWithEllipsis(elementText, maxChars, this.ellipsis, false, this.rtl);\n                      } // Set truncated text\n\n\n                      node_2.textContent = elementText; // Measure again\n\n                      lineInfo.bbox = lineInfo.element.getBBox();\n                      lineInfo.bbox.width = Math.floor(lineInfo.bbox.width); // Increase excess characters count, just in case it still\n                      // doesn't fit and we have to go at it again\n\n                      excessChars = Math.ceil(excessChars * 1.1);\n                    } // Do not process further chunks\n\n\n                    skipTextChunks = true;\n                  }\n                }\n              } else {\n                /**\r\n                 * Processign auto-wrap\r\n                 * In this case we're going to be adding text chunks until\r\n                 * they don't fit into current line. Once that happens we will\r\n                 * inject the rest of the chunks to the next line\r\n                 */\n                // Get last node added and measure it\n                var node_3 = lineInfo.element.node;\n\n                if (node_3) {\n                  var lastNode = lineInfo.element.node.lastChild; // Init split lines\n\n                  var splitLines = void 0;\n\n                  while (lineInfo.bbox.width > maxWidth && excessChars <= lineText.length && excessChars > 0) {\n                    // Calculate max available chars\n                    var maxChars = $math.max(chunk.text.length - excessChars, 1); // Don't split the words mid-word if it's not the first chunk\n                    // in the line\n\n                    if (firstChunk) {\n                      // Split mid-word if necessary\n                      splitLines = $utils.splitTextByCharCount(chunk.text, maxChars, true, this.rtl);\n                    } else {\n                      // Don't split mid-word\n                      splitLines = $utils.splitTextByCharCount(chunk.text, maxChars, true, this.rtl, false); // Check if the first word is too long\n\n                      if (splitLines[0].length > maxChars || maxChars === 1) {\n                        // Yes - move the whole chunk to the next line\n                        // Remove the element we just added\n                        lineInfo.element.node.removeChild(lastNode); // Break out of the while on next cycle\n\n                        excessChars = 0;\n                      }\n                    } // Use the first line to update last item\n\n\n                    if (excessChars > 0) {\n                      var lineText_1 = splitLines.shift();\n\n                      if (firstChunk) {\n                        lineText_1 = $utils.trim(lineText_1);\n                      }\n\n                      lastNode.textContent = getTextFormatter().cleanUp(lineText_1);\n                    } // Measure again, just in case\n\n\n                    lineInfo.bbox = lineInfo.element.getBBox();\n                    lineInfo.bbox.width = Math.floor(lineInfo.bbox.width); // Increase excess characters count, just in case it still\n                    // doesn't fit and we have to go at it again\n                    //excessChars = Math.ceil(excessChars * 1.05);\n\n                    excessChars++;\n                  } // Construct the rest of the line\n\n\n                  if (splitLines.length > 0) {\n                    var restOfLine = \"\"; // Add leftovers from splitting the current chunk\n\n                    if ($type.hasValue(splitLines)) {\n                      if (this.rtl) {\n                        restOfLine += splitLines.join(\"\") + currentFormat;\n                      } else {\n                        restOfLine += currentFormat + splitLines.join(\"\").replace(/([\\[\\]]{1})/g, \"$1$1\");\n                      }\n                    } // Add the rest of the chunks\n\n\n                    for (var c = x + 1; c < chunks.length; c++) {\n                      if (chunks[c].type == \"value\") {\n                        // We're escaping single square brackets that were\n                        // cleaned up by chunk() back to double square brackets\n                        // so that they are not being treated as format on\n                        // next pass.\n                        restOfLine += chunks[c].text.replace(/([\\[\\]]{1})/g, \"$1$1\");\n                      } else {\n                        restOfLine += chunks[c].text;\n                      }\n                    } // Inject the rest of the lines as chunks for subsequent\n\n\n                    lines.splice(i + 1, 0, restOfLine);\n                  } // Skip processing the rest of the chunks\n\n\n                  skipTextChunks = true;\n                }\n              }\n            } // Let's update the text's bbox with the line's one\n\n\n            if (this.bbox.width < lineInfo.bbox.width) {\n              this.bbox.width = lineInfo.bbox.width;\n            } // commented to avoid bug (seen on sankey link) where text is incorrectly aligned\n            //if (this.bbox.x > lineInfo.bbox.x) {\n            //this.bbox.x = lineInfo.bbox.x;\n            //}\n\n\n            this.bbox.height = currentHeight + currentLineHeight; // Position current line\n\n            if (!this.textPathElement) {\n              lineInfo.element.attr({\n                \"x\": \"0\",\n                \"y\": currentHeight + currentLineHeight,\n                \"dy\": $math.round(this.baseLineRatio * currentLineHeight, 3).toString()\n              });\n            } else {\n              lineInfo.element.attr({\n                \"dy\": -this.paddingBottom.toString()\n              });\n            }\n\n            firstChunk = false;\n          }\n        } // Trim the last item\n\n\n        var node = lineInfo.element.node;\n\n        if (node) {\n          var lastNode = node.lastChild;\n\n          if (lastNode) {\n            lastNode.textContent = this.rtl ? $utils.ltrim(lastNode.textContent) : $utils.rtrim(lastNode.textContent);\n          }\n        } // Increment collective height\n\n\n        currentHeight += currentLineHeight; // Save line cache\n\n        this.addLineInfo(lineInfo, i);\n      } // Check if maybe we need to hide the whole label if it doesn't fit\n\n\n      this.maybeHideOversized();\n      this.measureFailed = false;\n\n      if (this.bbox.width == 0 || this.bbox.height == 0) {\n        this.measureFailed = true;\n      } // Updated measured dims\n\n\n      this._measuredWidth = $math.round($math.max(this.bbox.width, this.pixelWidth - this.pixelPaddingLeft - this.pixelPaddingRight));\n      this._measuredHeight = $math.round($math.max(this.bbox.height, this.pixelHeight - this.pixelPaddingTop - this.pixelPaddingBottom)); // Align the lines\n\n      this.alignSVGText();\n      this.bbox.width = this._measuredWidth;\n      this.bbox.height = this._measuredHeight;\n\n      if (oldH != this._measuredHeight || oldW != this._measuredWidth) {\n        this.dispatch(\"transformed\");\n      }\n\n      this.hideUnused(lines.length);\n    } else {\n      /**\r\n       * HTML\r\n       */\n      this.element.removeAttr(\"display\");\n      this.resetBBox(); // Clear the element\n\n      var group = this.element;\n      group.removeChildren();\n      this.setCache(\"lineInfo\", [], 0); // Create a ForeignObject to use as HTML container\n\n      var fo = this.paper.foreignObject();\n      group.add(fo); // Set widths on foreignObject so that autosizing measurements work\n      // This will bet reset to actual content width/height\n\n      if (this.maxWidth) {\n        fo.attr({\n          width: this.maxWidth - this.pixelPaddingLeft - this.pixelPaddingRight\n        });\n      }\n\n      if (this.maxHeight) {\n        fo.attr({\n          height: this.maxHeight - this.pixelPaddingTop - this.pixelPaddingBottom\n        });\n      } // Create line element\n      //let lineElement: HTMLElement = this.getHTMLLineElement(getTextFormatter().format(this.html, output));\n\n\n      var lineElement = this.getHTMLLineElement(text);\n      fo.node.appendChild(lineElement); // Temporarily set to inline-block so we can measure real width and height\n\n      lineElement.style.display = \"inline-block\";\n      var clientWidth = lineElement.clientWidth;\n      var clientHeight = lineElement.clientHeight;\n      lineElement.style.display = \"block\";\n      this._bbox = {\n        x: 0,\n        y: 0,\n        width: clientWidth,\n        height: clientHeight\n      }; // Set exact dimensions of foreignObject so it is sized exactly as\n      // the content within (add one pixel to width so it does not wrap)\n\n      fo.attr({\n        width: clientWidth + 1,\n        height: clientHeight\n      }); // Check if maybe we need to hide the whole label if it doesn't fit\n\n      this.maybeHideOversized(); // Set measurements and update bbox\n\n      this._measuredWidth = $math.max(this.bbox.width, this.pixelWidth - this.pixelPaddingLeft - this.pixelPaddingRight);\n      this._measuredHeight = $math.max(this.bbox.height, this.pixelHeight - this.pixelPaddingTop - this.pixelPaddingBottom);\n      this.bbox.width = this._measuredWidth;\n      this.bbox.height = this._measuredHeight; // Don't let labels bleed out of the alotted area\n\n      if (this.truncate) {\n        lineElement.style.overflow = \"hidden\";\n      }\n\n      if (clientWidth > maxWidth || clientHeight > maxHeight) {\n        this.isOversized = true;\n      }\n    } // Set applicable styles\n\n\n    this.setStyles();\n    this.updateCenter();\n    this.updateBackground();\n\n    if (display == \"none\") {\n      this.group.attr({\n        display: \"none\"\n      });\n    }\n\n    if (this.pathElement) {\n      this.paper.appendDef(this.pathElement);\n    }\n  };\n  /**\r\n   * Hides element if it does not fit into available space\r\n   */\n\n\n  Label.prototype.maybeHideOversized = function () {\n    if (this.hideOversized) {\n      if (this.availableWidth < this.bbox.width || this.availableHeight < this.bbox.height) {\n        this.element.attr({\n          display: \"none\"\n        });\n        this.isOversized = true;\n      } else {\n        this.element.removeAttr(\"display\");\n        this.isOversized = false;\n      }\n    }\n  };\n  /**\r\n   * Aligns the lines horizontally and vertically, based on properties.\r\n   *\r\n   * @ignore Exclude from docs\r\n   */\n\n\n  Label.prototype.alignSVGText = function () {\n    // Get Group\n    var group = this.element;\n    var children = group.node.children || group.node.childNodes; // Is there anything to align?\n\n    if (!children || children && children.length == 0) {\n      return;\n    }\n\n    var width = this._measuredWidth;\n    var height = this._measuredHeight; // TODO maybe these aren't needed ?\n\n    $utils.used(this.pixelPaddingLeft);\n    $utils.used(this.pixelPaddingRight);\n    $utils.used(this.pixelPaddingTop);\n    $utils.used(this.pixelPaddingBottom);\n\n    if (this.rtl) {\n      group.attr({\n        \"direction\": \"rtl\"\n      });\n    } else {\n      group.removeAttr(\"direction\");\n    } // Process each line\n    //$iter.each(group.children.backwards().iterator(), (element) => {\n\n\n    for (var i = children.length - 1; i >= 0; i--) {\n      // Align horizontally\n      // Since we are using `text-anchor` for horizontal alignment, all we need\n      // to do here is move the `x` position\n      var node = children[i];\n      node.setAttribute(\"text-anchor\", this.textAlign);\n\n      if (this.textPathElement) {\n        node.removeAttribute(\"x\");\n        node.removeAttribute(\"y\");\n      } else {\n        switch (this.textAlign) {\n          case \"middle\":\n            node.setAttribute(\"x\", (width / 2).toString() + \"px\");\n            break;\n\n          case \"end\":\n            if (this.rtl) {} else {\n              node.setAttribute(\"x\", width.toString());\n            }\n\n            break;\n\n          default:\n            if (this.rtl) {\n              node.setAttribute(\"x\", width.toString());\n            } else {\n              node.removeAttribute(\"text-anchor\");\n            }\n\n            break;\n        }\n\n        var y = $type.toNumber(node.getAttribute(\"y\"));\n\n        switch (this.textValign) {\n          case \"middle\":\n            node.setAttribute(\"y\", ((y || 0) + (height - this.bbox.height) / 2).toString());\n            break;\n\n          case \"bottom\":\n            node.setAttribute(\"y\", ((y || 0) + height - this.bbox.height).toString());\n            break;\n\n          default:\n            node.setAttribute(\"y\", (y || 0).toString());\n            break;\n        }\n      }\n    }\n  };\n  /**\r\n   * Produces an SVG line element with formatted text.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param text    Text to wrap into line\r\n   * @param y       Current line vertical position\r\n   * @return A DOM element\r\n   * @todo Implement HTML support\r\n   */\n\n\n  Label.prototype.getSVGLineElement = function (text, y) {\n    // Create a <text> node and set text\n    var element = this.paper.addGroup(\"text\");\n    element.textContent = text; // Set parameters\n\n    element.attr({\n      \"x\": \"0\" //\"alignment-baseline\": \"hanging\",\n      //\"baseline-shift\": \"-20%\",\n      //\"text-anchor\": \"center\"\n\n    }); // Set `y` position\n\n    if ($type.hasValue(y)) {\n      element.attr({\n        \"y\": y.toString()\n      });\n    } // Don't let labels blled out of the alotted area\n\n\n    if (this.truncate || this.wrap) {\n      element.attr({\n        \"overflow\": \"hidden\"\n      });\n    } // Add RTL?\n    // This has now been moved to this.alignSVGText()\n    // if (this.rtl) {\n    // \telement.attr({\n    // \t\t\"direction\": \"rtl\",\n    // \t\t//\"unicode-bidi\": \"bidi-override\"\n    // \t});\n    // }\n\n\n    return element;\n  };\n\n  Object.defineProperty(Label.prototype, \"rtl\", {\n    /**\r\n     * @return RTL?\r\n     */\n    get: function () {\n      if ($type.hasValue(this._rtl)) {\n        return this._rtl;\n      } else if (this._topParent) {\n        return this._topParent.rtl;\n      }\n\n      return false;\n    },\n\n    /**\r\n     * An RTL (right-to-left) setting.\r\n     *\r\n     * RTL may affect alignment, text, and other visual properties.\r\n     *\r\n     * If you set this on a top-level chart object, it will be used for all\r\n     * child elements, e.g. labels, unless they have their own `rtl` setting\r\n     * set directly on them.\r\n     *\r\n     * @param value  `true` for to use RTL\r\n     */\n    set: function (value) {\n      value = $type.toBoolean(value);\n      this._rtl = value;\n\n      if (this.element) {\n        this.alignSVGText();\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\r\n   * Resets cached BBox.\r\n   *\r\n   * @ignore Exclude from docs\r\n   */\n\n  Label.prototype.resetBBox = function () {\n    this._bbox = {\n      x: 0,\n      y: 0,\n      width: 0,\n      height: 0\n    };\n  };\n  /**\r\n   * Creates and returns an HTML line element (`<div>`).\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param text  Text to add\r\n   * @return `<div>` element reference\r\n   */\n\n\n  Label.prototype.getHTMLLineElement = function (text) {\n    // Create the <div> element\n    var div = document.createElement(\"div\");\n    div.innerHTML = text; // Set text alignment\n\n    switch (this.textAlign) {\n      case \"middle\":\n        div.style.textAlign = \"center\";\n        break;\n\n      case \"end\":\n        div.style.textAlign = \"right\";\n        break;\n    } // Disable or enable wrapping\n\n\n    if (this.wrap) {\n      div.style.wordWrap = \"break-word\";\n    } else {\n      div.style.whiteSpace = \"nowrap\";\n    } // Don't let labels bleed out of the alotted area\n    // Moved to `draw()` because setting \"hidden\" kills all measuring\n\n    /*if (this.truncate) {\r\n        div.style.overflow = \"hidden\";\r\n    }*/\n    // Set RTL-related styles\n\n\n    if (this.rtl) {\n      div.style.direction = \"rtl\"; //div.style.unicodeBidi = \"bidi-override\";\n    } // Translate some of the SVG styles into CSS\n\n\n    if ($type.hasValue(this.fill)) {\n      div.style.color = this.fill.toString();\n    }\n\n    return div;\n  };\n  /**\r\n   * Applies specific styles to text to make it not selectable, unless it is\r\n   * explicitly set as `selectable`.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @todo Set styles via AMElement\r\n   */\n\n\n  Label.prototype.setStyles = function () {\n    var group = this.element;\n\n    if (!this.selectable || this.draggable || this.resizable || this.swipeable) {\n      group.addStyle({\n        \"webkitUserSelect\": \"none\",\n        \"msUserSelect\": \"none\"\n      });\n    } else if (this.selectable) {\n      group.removeStyle(\"webkitUserSelect\");\n      group.removeStyle(\"msUserSelect\");\n    }\n  };\n  /**\r\n   * Hides unused lines\r\n   */\n\n\n  Label.prototype.hideUnused = function (index) {\n    this.initLineCache();\n    var lines = this.getCache(\"lineInfo\");\n\n    if (lines.length >= index) {\n      for (var i = index; i < lines.length; i++) {\n        var line = lines[i];\n\n        if (line && line.element) {\n          line.element.attr({\n            \"display\": \"none\"\n          });\n        }\n      }\n    }\n  };\n\n  Object.defineProperty(Label.prototype, \"text\", {\n    /**\r\n     * @return SVG text\r\n     */\n    get: function () {\n      return this.getPropertyValue(\"text\");\n    },\n\n    /**\r\n     * An SVG text.\r\n     *\r\n     * Please note that setting `html` will override this setting if browser\r\n     * supports `foreignObject` in SGV, such as most modern browsers excluding\r\n     * IEs.\r\n     *\r\n     * @param value  SVG Text\r\n     */\n    set: function (value) {\n      //this.setPropertyValue(\"html\", undefined);\n      this.setPropertyValue(\"text\", value, true);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Label.prototype, \"path\", {\n    /**\r\n     * @return Path\r\n     */\n    get: function () {\n      return this.getPropertyValue(\"path\");\n    },\n\n    /**\r\n     * An SVG path string to position text along. If set, the text will follow\r\n     * the curvature of the path.\r\n     *\r\n     * Location along the path can be set using `locationOnPath`.\r\n     *\r\n     * IMPORTANT: Only SVG text can be put on path. If you are using HTML text\r\n     * this setting will be ignored.\r\n     *\r\n     * @since 4.1.2\r\n     * @param  value  Path\r\n     */\n    set: function (value) {\n      if (this.setPropertyValue(\"path\", value, true)) {\n        if (this.pathElement) {\n          this.pathElement.dispose();\n        }\n\n        if (this.textPathElement) {\n          this.textPathElement.dispose();\n        }\n\n        this.pathElement = this.paper.add(\"path\");\n        this.pathElement.attr({\n          \"d\": value\n        });\n        this.pathElement.attr({\n          \"id\": \"text-path-\" + this.uid\n        });\n\n        this._disposers.push(this.pathElement);\n\n        this.textPathElement = this.paper.addGroup(\"textPath\");\n        this.textPathElement.attrNS($dom.XLINK, \"xlink:href\", \"#text-path-\" + this.uid); // TODO remove after https://bugzilla.mozilla.org/show_bug.cgi?id=455986 is fixed\n\n        this.textPathElement.attr({\n          \"path\": value\n        });\n\n        this._disposers.push(this.textPathElement);\n\n        this.hardInvalidate();\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Label.prototype, \"locationOnPath\", {\n    /**\r\n     * @return Relatvie location on path\r\n     */\n    get: function () {\n      return this.getPropertyValue(\"locationOnPath\");\n    },\n\n    /**\r\n     * Relative label location on `path`. Value range is from 0 (beginning)\r\n     * to 1 (end).\r\n     *\r\n     * Works only if you set `path` setting to an SVG path.\r\n     *\r\n     * @since 4.1.2\r\n     * @default 0\r\n     * @param  value  Relatvie location on path\r\n     */\n    set: function (value) {\n      this.setPropertyValue(\"locationOnPath\", value);\n\n      if (this.textPathElement) {\n        this.textPathElement.attr({\n          \"startOffset\": value * 100 + \"%\"\n        });\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Label.prototype, \"baseLineRatio\", {\n    /**\r\n     * @return Base line ratio\r\n     */\n    get: function () {\n      return this.getPropertyValue(\"baseLineRatio\");\n    },\n\n    /**\r\n     * A ratio to calculate text baseline. Ralative distance from the bottom of\r\n     * the label.\r\n     *\r\n     * @since 4.4.2\r\n     * @default -0.27\r\n     * @param  value  Base line ratio\r\n     */\n    set: function (value) {\n      this.setPropertyValue(\"baseLineRatio\", value);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Label.prototype, \"wrap\", {\n    /**\r\n     * @return Auto-wrap enabled or not\r\n     */\n    get: function () {\n      return this.getPropertyValue(\"wrap\");\n    },\n\n    /**\r\n     * Enables or disables autowrapping of text.\r\n     *\r\n     * @param value  Auto-wrapping enabled\r\n     */\n    set: function (value) {\n      this.resetBBox();\n      this.setPropertyValue(\"wrap\", value, true);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Label.prototype, \"truncate\", {\n    /**\r\n     * @return Truncate text?\r\n     */\n    get: function () {\n      return this.getPropertyValue(\"truncate\");\n    },\n\n    /**\r\n     * Indicates if text lines need to be truncated if they do not fit, using\r\n     * configurable `ellipsis` string.\r\n     *\r\n     * `truncate` overrides `wrap` if both are set to `true`.\r\n     *\r\n     * NOTE: For HTML text, this setting **won't** trigger a parser and actual\r\n     * line truncation with ellipsis. It will just hide everything that goes\r\n     * outside the label.\r\n     *\r\n     * @param value  trincate text?\r\n     */\n    set: function (value) {\n      this.resetBBox();\n      this.setPropertyValue(\"truncate\", value, true);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Label.prototype, \"fullWords\", {\n    /**\r\n     * @return Truncate on full words?\r\n     */\n    get: function () {\n      return this.getPropertyValue(\"fullWords\");\n    },\n\n    /**\r\n     * If `truncate` is enabled, should Label try to break only on full words\r\n     * (`true`), or whenever needed, including middle of the word. (`false`)\r\n     *\r\n     * @default true\r\n     * @param value  Truncate on full words?\r\n     */\n    set: function (value) {\n      this.setPropertyValue(\"fullWords\", value, true);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Label.prototype, \"ellipsis\", {\n    /**\r\n     * @return Ellipsis string\r\n     */\n    get: function () {\n      return this.getPropertyValue(\"ellipsis\");\n    },\n\n    /**\r\n     * Ellipsis character to use if `truncate` is enabled.\r\n     *\r\n     * @param value Ellipsis string\r\n     * @default \"...\"\r\n     */\n    set: function (value) {\n      this.setPropertyValue(\"ellipsis\", value, true);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Label.prototype, \"selectable\", {\n    /**\r\n     * @return Text selectable?\r\n     */\n    get: function () {\n      return this.getPropertyValue(\"selectable\");\n    },\n\n    /**\r\n     * Forces the text to be selectable. This setting will be ignored if the\r\n     * object has some kind of interaction attached to it, such as it is\r\n     * `draggable`, `swipeable`, `resizable`.\r\n     *\r\n     * @param value  Text selectable?\r\n     * @default false\r\n     */\n    set: function (value) {\n      this.setPropertyValue(\"selectable\", value, true);\n      this.setStyles();\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Label.prototype, \"textAlign\", {\n    /**\r\n     * @return Alignment\r\n     */\n    get: function () {\n      return this.getPropertyValue(\"textAlign\");\n    },\n\n    /**\r\n     * Horizontal text alignment.\r\n     *\r\n     * Available choices:\r\n     * * \"start\"\r\n     * * \"middle\"\r\n     * * \"end\"\r\n     *\r\n     * @param value  Alignment\r\n     */\n    set: function (value) {\n      this.setPropertyValue(\"textAlign\", value, true);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Label.prototype, \"textValign\", {\n    /**\r\n     * @ignore Exclude from docs (not used)\r\n     * @return Alignment\r\n     * @deprecated\r\n     */\n    get: function () {\n      return this.getPropertyValue(\"textValign\");\n    },\n\n    /**\r\n     * Vertical text alignment.\r\n     *\r\n     * @ignore Exclude from docs (not used)\r\n     * @param value  Alignment\r\n     * @deprecated\r\n     */\n    set: function (value) {\n      this.setPropertyValue(\"textValign\", value, true);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Label.prototype, \"html\", {\n    /**\r\n     * @return HTML content\r\n     */\n    get: function () {\n      return this.getPropertyValue(\"html\");\n    },\n\n    /**\r\n     * Raw HTML to be used as text.\r\n     *\r\n     * NOTE: HTML text is subject to browser support. It relies on browsers\r\n     * supporting SVG `foreignObject` nodes. Some browsers (read IEs) do not\r\n     * support it. On those browsers, the text will fall back to basic SVG text,\r\n     * striping out all HTML markup and styling that goes with it.\r\n     *\r\n     * For more information about `foreignObject` and its browser compatibility\r\n     * refer to [this page](https://developer.mozilla.org/en/docs/Web/SVG/Element/foreignObject#Browser_compatibility).\r\n     *\r\n     * @param value HTML text\r\n     */\n    set: function (value) {\n      this.setPropertyValue(\"html\", value, true);\n\n      if (!$type.hasValue(value)) {\n        var group = this.element;\n        group.removeChildrenByTag(\"foreignObject\");\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  Label.prototype.setFill = function (value) {\n    _super.prototype.setFill.call(this, value);\n\n    if (this.html) {\n      var group = this.element;\n      var divs = group.node.getElementsByTagName(\"div\");\n\n      for (var i = 0; i < divs.length; i++) {\n        var div = divs[i];\n\n        if ($type.hasValue(this.fill)) {\n          div.style.color = this.fill.toString();\n        }\n      }\n    }\n  };\n\n  Object.defineProperty(Label.prototype, \"hideOversized\", {\n    /**\r\n     * @return Hide if text does not fit?\r\n     */\n    get: function () {\n      return this.getPropertyValue(\"hideOversized\");\n    },\n\n    /**\r\n     * Indicates whether the whole text should be hidden if it does not fit into\r\n     * its allotted space.\r\n     *\r\n     * @param value  Hide if text does not fit?\r\n     */\n    set: function (value) {\n      this.setPropertyValue(\"hideOversized\", value, true);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Label.prototype, \"ignoreFormatting\", {\n    /**\r\n     * @return Ignore formatting?\r\n     */\n    get: function () {\n      return this.getPropertyValue(\"ignoreFormatting\");\n    },\n\n    /**\r\n     * If set to `true` square-bracket formatting blocks will be treated as\r\n     * regular text.\r\n     *\r\n     * @default false\r\n     * @param value  Ignore formatting?\r\n     */\n    set: function (value) {\n      this.setPropertyValue(\"ignoreFormatting\", value, true);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\r\n   * Override `mesaureElement` so it does not get measure again, because\r\n   * internal `_bbox` is being updated by measuring routines in Text itself.\r\n   */\n\n  Label.prototype.measureElement = function () {};\n  /**\r\n   * Returns information about a line element.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param index  Line index\r\n   * @return Line info object\r\n   */\n\n\n  Label.prototype.getLineInfo = function (index) {\n    this.initLineCache();\n    var lines = this.getCache(\"lineInfo\");\n    return lines.length > index ? lines[index] : undefined;\n  };\n  /**\r\n   * Adds a line to line info cache.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param line     Line info object\r\n   * @param index    Insert at specified index\r\n   */\n\n\n  Label.prototype.addLineInfo = function (line, index) {\n    this.initLineCache();\n    this.getCache(\"lineInfo\")[index] = line;\n  };\n  /**\r\n   * Checks if line cache is initialized and initializes it.\r\n   */\n\n\n  Label.prototype.initLineCache = function () {\n    if (!$type.hasValue(this.getCache(\"lineInfo\"))) {\n      this.setCache(\"lineInfo\", [], 0);\n    }\n  };\n  /**\r\n   * Sets a [[DataItem]] to use for populating dynamic sections of the text.\r\n   *\r\n   * Check the description for [[Text]] class, for data binding.\r\n   *\r\n   * @param dataItem Data item\r\n   */\n\n\n  Label.prototype.setDataItem = function (dataItem) {\n    if (this._sourceDataItemEvents) {\n      this._sourceDataItemEvents.dispose();\n    }\n\n    if (dataItem) {\n      this._sourceDataItemEvents = new MultiDisposer([dataItem.events.on(\"valuechanged\", this.invalidate, this, false), dataItem.events.on(\"workingvaluechanged\", this.invalidate, this, false), dataItem.events.on(\"calculatedvaluechanged\", this.invalidate, this, false), dataItem.events.on(\"propertychanged\", this.invalidate, this, false)]);\n    }\n\n    _super.prototype.setDataItem.call(this, dataItem);\n  };\n\n  Object.defineProperty(Label.prototype, \"availableWidth\", {\n    /**\r\n     * Returns available horizontal space.\r\n     *\r\n     * @ignore Exclude from docs\r\n     * @return Available width (px)\r\n     */\n    get: function () {\n      return $type.hasValue(this.maxWidth) ? this.maxWidth : this.pixelWidth;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Label.prototype, \"availableHeight\", {\n    /**\r\n     * Returns available vertical space.\r\n     *\r\n     * @return Available height (px)\r\n     */\n    get: function () {\n      return $type.hasValue(this.maxHeight) ? this.maxHeight : this.pixelHeight;\n    },\n    enumerable: true,\n    configurable: true\n  }); // temp, replacing textFormatter method\n\n  Label.prototype.getSvgElement = function (text, style, parent) {\n    var element = this.paper.add(\"tspan\");\n    element.textContent = text;\n\n    if (style) {\n      if (options.nonce && parent) {\n        //element.node.setAttribute(\"nonce\", \"test123\");\n        var classid = \"amcharts_element_style_\" + btoa(style).replace(/[^\\w]*/g, \"\");\n        element.node.setAttribute(\"class\", classid);\n        var defs = document.createElementNS($dom.SVGNS, \"defs\");\n        parent.node.appendChild(defs);\n        var e = document.createElement(\"style\");\n        e.type = \"text/css\";\n        e.innerHTML = \".\" + classid + \" { \" + style + \"}\";\n        e.setAttribute(\"nonce\", options.nonce);\n        defs.appendChild(e);\n      } else {\n        element.node.setAttribute(\"style\", style);\n      }\n    }\n\n    if (parent) {\n      parent.add(element);\n    }\n\n    return element;\n  };\n  /**\r\n   * Invalidates the whole element, including layout AND all its child\r\n   * elements.\r\n   */\n\n\n  Label.prototype.deepInvalidate = function () {\n    _super.prototype.deepInvalidate.call(this);\n\n    this.hardInvalidate();\n  };\n\n  Object.defineProperty(Label.prototype, \"readerTitle\", {\n    /**\r\n     * @return Title\r\n     */\n    get: function () {\n      var title = this.getPropertyValue(\"readerTitle\");\n\n      if (!title) {\n        title = this.populateString($utils.plainText($utils.isNotEmpty(this.html) ? this.html : this.text));\n      } else if (this.dataItem) {\n        title = this.populateString(title);\n      }\n\n      return title;\n    },\n\n    /**\r\n     * Screen reader title of the element.\r\n     *\r\n     * @param value Title\r\n     */\n    set: function (value) {\n      value = $type.toText(value);\n\n      if (this.setPropertyValue(\"readerTitle\", value)) {\n        this.applyAccessibility();\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  return Label;\n}(Container);\n\nexport { Label };\n/**\r\n * Register class in system, so that it can be instantiated using its name from\r\n * anywhere.\r\n *\r\n * @ignore\r\n */\n\nregistry.registeredClasses[\"Label\"] = Label;\n/**\r\n * Add default responsive rules\r\n */\n\n/**\r\n * Hide labels added directly to chart, like titles if chart is short.\r\n */\n\ndefaultRules.push({\n  relevant: ResponsiveBreakpoints.heightXS,\n  state: function (target, stateId) {\n    if (target instanceof Label && target.parent && target.parent.isBaseSprite) {\n      var state = target.states.create(stateId);\n      state.properties.disabled = true;\n      return state;\n    }\n\n    return null;\n  }\n});","map":{"version":3,"names":["__extends","Container","registry","getTextFormatter","MultiDisposer","InterfaceColorSet","$math","$utils","$type","$dom","defaultRules","ResponsiveBreakpoints","options","Label","_super","_this","call","isOversized","className","fill","getFor","wrap","truncate","fullWords","ellipsis","textAlign","textValign","layout","baseLineRatio","_positionPrecision","events","on","inited","handleMaxSize","once","handleValidate","applyTheme","prototype","afterDraw","validatePosition","setPaper","paper","changed","hardInvalidate","currentText","text","bbox","width","height","availableWidth","availableHeight","invalidate","arrange","updateCurrentText","output","isNotEmpty","html","supportsForeignObject","isObject","toString","hasValue","populateString","dataItem","_adapterO","apply","_currentFormat","_prevStatus","getLineBBox","lineInfo","element","node","parentNode","getBBox","draw","oldW","oldH","topParent","maxWidth","maxHeight","max","pixelPaddingLeft","pixelPaddingRight","pixelPaddingTop","pixelPaddingBottom","status","rtl","_measuredWidth","_measuredHeight","attr","display","lines","split","group","getAttr","removeAttr","textPathElement","removeChildren","resetBBox","currentHeight","currentFormat","i","length","line","tempElement","getSVGLineElement","add","getSvgElement","translateStyleShortcuts","offset","Math","ceil","removeElement","lineInfo_1","getLineInfo","textContent","chunks","chunk","ignoreFormatting","currentLineHeight","firstChunk","skipTextChunks","x","complex","type","style","lineText","avgCharWidth","excessChars","min","addEllipsis","node_1","childNodes","e","node_2","floor","elementText","maxChars","removeChild","truncateWithEllipsis","node_3","lastNode","lastChild","splitLines","splitTextByCharCount","lineText_1","shift","trim","cleanUp","restOfLine","join","replace","c","splice","round","paddingBottom","ltrim","rtrim","addLineInfo","maybeHideOversized","measureFailed","pixelWidth","pixelHeight","alignSVGText","dispatch","hideUnused","setCache","fo","foreignObject","lineElement","getHTMLLineElement","appendChild","clientWidth","clientHeight","_bbox","y","overflow","setStyles","updateCenter","updateBackground","pathElement","appendDef","hideOversized","children","used","setAttribute","removeAttribute","toNumber","getAttribute","addGroup","Object","defineProperty","get","_rtl","_topParent","set","value","toBoolean","enumerable","configurable","div","document","createElement","innerHTML","wordWrap","whiteSpace","direction","color","selectable","draggable","resizable","swipeable","addStyle","removeStyle","index","initLineCache","getCache","getPropertyValue","setPropertyValue","dispose","uid","_disposers","push","attrNS","XLINK","removeChildrenByTag","setFill","divs","getElementsByTagName","measureElement","undefined","setDataItem","_sourceDataItemEvents","parent","nonce","classid","btoa","defs","createElementNS","SVGNS","deepInvalidate","title","plainText","toText","applyAccessibility","registeredClasses","relevant","heightXS","state","target","stateId","isBaseSprite","states","create","properties","disabled"],"sources":["D:/APPLICATION/UI/UPL/NEW/node_modules/@amcharts/amcharts4/.internal/core/elements/Label.js"],"sourcesContent":["/**\r\n * Text class deals with all text placed on chart.\r\n */\r\nimport { __extends } from \"tslib\";\r\n/**\r\n * ============================================================================\r\n * IMPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\r\nimport { Container } from \"../Container\";\r\nimport { registry } from \"../Registry\";\r\nimport { getTextFormatter } from \"../formatters/TextFormatter\";\r\nimport { MultiDisposer } from \"../utils/Disposer\";\r\nimport { InterfaceColorSet } from \"../../core/utils/InterfaceColorSet\";\r\nimport * as $math from \"../utils/Math\";\r\nimport * as $utils from \"../utils/Utils\";\r\nimport * as $type from \"../utils/Type\";\r\nimport * as $dom from \"../utils/DOM\";\r\nimport { defaultRules, ResponsiveBreakpoints } from \"../utils/Responsive\";\r\nimport { options } from \"../Options\";\r\n;\r\n/**\r\n * ============================================================================\r\n * MAIN CLASS\r\n * ============================================================================\r\n * @hidden\r\n */\r\n/**\r\n * Text is used to display highly configurable, data-enabled textual elements.\r\n *\r\n * ## Data Binding\r\n *\r\n * A Text element can dynamically parse and populate its contents with values\r\n * from a [[DataItem]].\r\n *\r\n * To activate such binding, set element's `dataItem` property.\r\n *\r\n * When activated, text contents will be parsed for special tags, e.g.:\r\n *\r\n * ```TypeScript\r\n * label.dataItem = myDataItem;\r\n * label.text = \"The title is: {title}\";\r\n * ```\r\n * ```JavaScript\r\n * label.dataItem = myDataItem;\r\n * label.text = \"The title is: {title}\";\r\n * ```\r\n *\r\n * The above will automatically replace \"{title}\" in the string with the\r\n * actual data value from `myDataItem`.\r\n *\r\n * Note, that most often dataItem is set by the Component.\r\n *\r\n *\r\n * @see {@link ILabelEvents} for a list of available events\r\n * @see {@link ILabelAdapters} for a list of available Adapters\r\n * @see {@link https://www.amcharts.com/docs/v4/concepts/formatters/formatting-strings/} for info on string formatting and data binding\r\n * @todo Vertical align\r\n * @important\r\n */\r\nvar Label = /** @class */ (function (_super) {\r\n    __extends(Label, _super);\r\n    /**\r\n     * Constructor\r\n     */\r\n    function Label() {\r\n        var _this = \r\n        // Execute super's constructor\r\n        _super.call(this) || this;\r\n        /**\r\n         * Indicates if the whole text does not fit into max dimenstions set for it.\r\n         */\r\n        _this.isOversized = false;\r\n        // Set this class name\r\n        _this.className = \"Label\";\r\n        _this.fill = new InterfaceColorSet().getFor(\"text\");\r\n        // not good to set this, as then these will appear on each label and values set on container won't be applied.\r\n        //this.textDecoration = \"none\";\r\n        //this.fontWeight = \"normal\";\r\n        // Set defaults\r\n        _this.wrap = false;\r\n        _this.truncate = false;\r\n        _this.fullWords = true;\r\n        _this.ellipsis = \"â€¦\";\r\n        _this.textAlign = \"start\";\r\n        _this.textValign = \"top\";\r\n        _this.layout = \"absolute\";\r\n        _this.baseLineRatio = -0.27;\r\n        //this.pixelPerfect = true;\r\n        _this._positionPrecision = 1;\r\n        // Add events to watch for maxWidth/maxHeight changes so that we can\r\n        // invalidate this\r\n        _this.events.on(\"maxsizechanged\", function () {\r\n            if (_this.inited) {\r\n                _this.handleMaxSize();\r\n            }\r\n        }, _this, false);\r\n        // this solves strange bug when text just added to svg is 0x0\r\n        _this.events.once(\"validated\", _this.handleValidate, _this, false);\r\n        // Aply theme\r\n        _this.applyTheme();\r\n        return _this;\r\n    }\r\n    /**\r\n     * A placeholder method that is called **after** element finishes drawing\r\n     * itself.\r\n     *\r\n     * @ignore Exclude from docs\r\n     */\r\n    Label.prototype.afterDraw = function () {\r\n        // since we removed validatePosition from sprite, we still need it here to handle rotated text\r\n        _super.prototype.afterDraw.call(this);\r\n        this.validatePosition();\r\n    };\r\n    /**\r\n     * Sets [[Paper]] instance to use to draw elements.\r\n     * @ignore\r\n     * @param paper Paper\r\n     * @return true if paper was changed, false, if it's the same\r\n     */\r\n    Label.prototype.setPaper = function (paper) {\r\n        var changed = _super.prototype.setPaper.call(this, paper);\r\n        if (changed) {\r\n            this.hardInvalidate();\r\n        }\r\n        return changed;\r\n    };\r\n    /**\r\n     * @ignore\r\n     */\r\n    Label.prototype.handleValidate = function () {\r\n        if ((this.currentText || this.text) && (this.bbox.width == 0 || this.bbox.height == 0)) {\r\n            registry.events.once(\"exitframe\", this.hardInvalidate, this);\r\n        }\r\n    };\r\n    /**\r\n     * @ignore\r\n     */\r\n    Label.prototype.handleMaxSize = function () {\r\n        if ((this.bbox.width > this.availableWidth)\r\n            || ((this.bbox.width < this.availableWidth) && (this.isOversized || this.truncate))\r\n            || (this.bbox.height > this.availableHeight)\r\n            || ((this.bbox.height < this.availableHeight) && this.isOversized)) {\r\n            this.invalidate();\r\n        }\r\n        else {\r\n            //this.alignSVGText();\r\n        }\r\n    };\r\n    /**\r\n     * [arrange description]\r\n     *\r\n     * @ignore Exclude from docs\r\n     * @todo Description\r\n     */\r\n    Label.prototype.arrange = function () {\r\n    };\r\n    /**\r\n     * Updates current text according to data item and supported features.\r\n     * Returns `true` if current text has changed.\r\n     *\r\n     * @return Text changed?\r\n     */\r\n    Label.prototype.updateCurrentText = function () {\r\n        // Determine output format\r\n        var output, text;\r\n        if ($utils.isNotEmpty(this.html) && this.paper.supportsForeignObject()) {\r\n            // We favor HTML text if it's set and browser supports `foreignObject`\r\n            output = \"html\";\r\n            text = this.html;\r\n        }\r\n        else {\r\n            output = \"svg\";\r\n            text = this.text;\r\n        }\r\n        // Need to toString source?\r\n        if ($type.isObject(text)) {\r\n            text = text.toString();\r\n        }\r\n        // Need to format text all the time\r\n        if ($type.hasValue(text) && text !== \"\") {\r\n            text = this.populateString(text, this.dataItem);\r\n        }\r\n        if (output == \"html\") {\r\n            if (this._adapterO) {\r\n                text = this._adapterO.apply(\"htmlOutput\", text);\r\n            }\r\n        }\r\n        else {\r\n            if (this._adapterO) {\r\n                text = this._adapterO.apply(\"textOutput\", text);\r\n            }\r\n        }\r\n        // Update the text\r\n        var changed = text != this.currentText || output != this._currentFormat;\r\n        this.currentText = text;\r\n        this._currentFormat = output;\r\n        return changed;\r\n    };\r\n    /**\r\n     * Hard invalidate means the text will be redrawn even if it hasn't changed.\r\n     * This is used when we change `fontSize`, `fontFamily`, or for some other\r\n     * reasons.\r\n     */\r\n    Label.prototype.hardInvalidate = function () {\r\n        this._prevStatus = \"\";\r\n        this.invalidate();\r\n    };\r\n    /**\r\n     * Gets line bbox, uses caching to save cpu\r\n     * @ignore\r\n     */\r\n    Label.prototype.getLineBBox = function (lineInfo) {\r\n        //let cacheKey = lineInfo.text + lineInfo.style;\r\n        //let lineBBox = this.getCache(cacheKey);\r\n        //if (!lineBBox) {\r\n        //lineBBox = lineInfo.element.getBBox();\r\n        //if (lineBBox.width != 0 && lineBBox.height != 0) {\r\n        //\tthis.setCache(cacheKey, lineBBox, 5000);\r\n        //}\r\n        //}\r\n        var element = lineInfo && lineInfo.element;\r\n        var node = element && element.node;\r\n        // Check for the parent Node to avoid FF from throwing errors\r\n        if (node && node.parentNode) {\r\n            lineInfo.bbox = element.getBBox();\r\n        }\r\n    };\r\n    /**\r\n     * Draws the textual label.\r\n     *\r\n     * @ignore Exclude from docs\r\n     */\r\n    Label.prototype.draw = function () {\r\n        // Draw super\r\n        _super.prototype.draw.call(this);\r\n        var oldW = this.bbox.width;\r\n        var oldH = this.bbox.height;\r\n        var topParent = this.topParent;\r\n        if (topParent) {\r\n            if (!topParent.maxWidth || !topParent.maxHeight) {\r\n                topParent.events.once(\"maxsizechanged\", this.hardInvalidate, this, false);\r\n                return;\r\n            }\r\n        }\r\n        // Calculate max width and height\r\n        var maxWidth = $math.max(this.availableWidth - this.pixelPaddingLeft - this.pixelPaddingRight, 0);\r\n        var maxHeight = $math.max(this.availableHeight - this.pixelPaddingTop - this.pixelPaddingBottom, 0);\r\n        // save\r\n        var status = maxHeight + \",\" + maxWidth + this.wrap + this.truncate + this.fullWords + this.rtl + this.ellipsis;\r\n        // Update text\r\n        if (!this.updateCurrentText() && this.inited && this._prevStatus == status) {\r\n            return;\r\n        }\r\n        this._measuredWidth = 0;\r\n        this._measuredHeight = 0;\r\n        // Reset\r\n        this.isOversized = false;\r\n        // Determine output format\r\n        var output = this._currentFormat;\r\n        var text = this.currentText;\r\n        // Empty string\r\n        if (!$type.hasValue(text) || text == \"\") {\r\n            this.element.attr({ display: \"none\" });\r\n            return;\r\n        }\r\n        // Chop up text into lines\r\n        // We're still processing SVG and HTML in the same way for now\r\n        var lines = text.split(\"\\n\");\r\n        // Do we need to go through the trouble of measuring lines\r\n        //let measure: boolean = true;// (lines.length > 1) || this.wrap;\r\n        this._prevStatus = status;\r\n        this.textAlign = this.textAlign;\r\n        // need this to measure\r\n        var display = this.group.getAttr(\"display\");\r\n        if (display == \"none\") {\r\n            this.group.removeAttr(\"display\");\r\n        }\r\n        if (this.textPathElement) {\r\n            this.textPathElement.removeChildren();\r\n        }\r\n        // SVG or HTML?\r\n        if (output === \"svg\") {\r\n            /**\r\n             * SVG\r\n             */\r\n            this.element.removeAttr(\"display\");\r\n            // Clear the element\r\n            var group = this.element;\r\n            //group.removeChildren();\r\n            this.resetBBox();\r\n            // Init state variables\r\n            var currentHeight = 0;\r\n            var currentFormat = \"\";\r\n            // Process each line\r\n            for (var i = 0; i < lines.length; i++) {\r\n                // Get line\r\n                var line = lines[i];\r\n                // Check if line is empty\r\n                if (line == \"\") {\r\n                    // It is, let's just update currentHeight and go to the next one\r\n                    // If it's the first line, we'll have to use arbirary line height,\r\n                    // since there's nothing to measure. For subsequent lines we can take\r\n                    // previous line's height\r\n                    var tempElement = this.getSVGLineElement(\"\", 0);\r\n                    tempElement.add(this.getSvgElement(\".\", getTextFormatter().translateStyleShortcuts(currentFormat)));\r\n                    group.add(tempElement);\r\n                    var offset = Math.ceil(tempElement.getBBox().height);\r\n                    if (offset > 0) {\r\n                        currentHeight += offset;\r\n                    }\r\n                    group.removeElement(tempElement);\r\n                    // Clear cache if necessary\r\n                    var lineInfo_1 = this.getLineInfo(i);\r\n                    if (lineInfo_1) {\r\n                        lineInfo_1.text = \"\";\r\n                        lineInfo_1.element.textContent = \"\";\r\n                    }\r\n                    continue;\r\n                }\r\n                // Chunk up the line and process each chunk\r\n                var chunks = getTextFormatter().chunk(line, null, this.ignoreFormatting);\r\n                var currentLineHeight = 0;\r\n                var firstChunk = true;\r\n                var skipTextChunks = false;\r\n                // Create line element or grab it from cache\r\n                var lineInfo = this.getLineInfo(i);\r\n                if (lineInfo) {\r\n                    // Empty line\r\n                    lineInfo.text = \"\";\r\n                    lineInfo.element.textContent = \"\";\r\n                }\r\n                else {\r\n                    // Init new line info\r\n                    lineInfo = {\r\n                        \"text\": \"\",\r\n                        \"element\": this.getSVGLineElement(\"\", 0),\r\n                        \"complex\": false\r\n                    };\r\n                    // Create the line element\r\n                    //lineInfo.element = this.getSVGLineElement(\"\", 0);\r\n                    //lineElement = this.getSVGLineElement(\"\", 0);\r\n                    group.add(lineInfo.element);\r\n                }\r\n                lineInfo.element.removeAttr(\"display\");\r\n                lineInfo.element.removeChildren(); // memory leak without this\r\n                if (this.textPathElement) {\r\n                    lineInfo.element.add(this.textPathElement);\r\n                }\r\n                /*// @todo not needed anymore\r\n                if (this.rtl) {\r\n                    chunks.reverse();\r\n                }*/\r\n                // Process each chunk\r\n                for (var x = 0; x < chunks.length; x++) {\r\n                    // If there's more than one chunk, means the line is \"complex\"\r\n                    if (x) {\r\n                        lineInfo.complex = true;\r\n                    }\r\n                    // Get chunk\r\n                    var chunk = chunks[x];\r\n                    // Is this chunk format or text?\r\n                    if (chunk.type === \"format\") {\r\n                        // Log current format, so that we can apply it to multiple lines if\r\n                        // necessary\r\n                        currentFormat = chunk.text;\r\n                    }\r\n                    else {\r\n                        // It's text block\r\n                        // Need to skip?\r\n                        // We do this when truncating. We can't just simply go ahead and\r\n                        // abandon chunk processing as they might have formatting\r\n                        // instructions in them that are relevant for subsequent lines\r\n                        if (skipTextChunks) {\r\n                            continue;\r\n                        }\r\n                        // Add chunk to the current element\r\n                        //lineInfo.element.content += $utils.trim(getTextFormatter().format(currentFormat + chunk.text, output));\r\n                        lineInfo.text = chunk.text;\r\n                        lineInfo.style = getTextFormatter().translateStyleShortcuts(currentFormat);\r\n                        if (this.textPathElement) {\r\n                            this.getSvgElement(lineInfo.text, lineInfo.style, this.textPathElement);\r\n                        }\r\n                        else {\r\n                            this.getSvgElement(lineInfo.text, lineInfo.style, lineInfo.element);\r\n                        }\r\n                        this.getLineBBox(lineInfo);\r\n                        lineInfo.bbox.width = Math.ceil(lineInfo.bbox.width);\r\n                        // Updated current line height\r\n                        if (currentLineHeight < lineInfo.bbox.height) {\r\n                            currentLineHeight = lineInfo.bbox.height;\r\n                        }\r\n                        // Wrapping?\r\n                        if ((this.wrap || this.truncate) && (lineInfo.bbox.width > maxWidth)) {\r\n                            // Set oversized\r\n                            this.isOversized = true;\r\n                            // Take temporary measurements\r\n                            var lineText = lineInfo.element.textContent;\r\n                            var avgCharWidth = (lineInfo.bbox.width / lineText.length); // * .9;\r\n                            // Calculate average number of symbols / width\r\n                            var excessChars = $math.min(Math.ceil((lineInfo.bbox.width - maxWidth) / avgCharWidth), lineText.length);\r\n                            // Are we truncating or auto-wrapping text?\r\n                            if (this.truncate) {\r\n                                /**\r\n                                 * Processing line truncation\r\n                                 * With the addition of each text chunk we measure if current\r\n                                 * line does not exceed maxWidth. If it does, we will stop\r\n                                 * addition of further chunks as well as try to truncate\r\n                                 * current or any number of previous chunks with an added\r\n                                 * ellipsis\r\n                                 */\r\n                                // Indicator whether we need to add ellipsis to the current\r\n                                // element, even if it fits. This is needed to indicate\r\n                                // whether we have already removed some subsequent chunks in\r\n                                // which case we need to add ellipsis.\r\n                                var addEllipsis = false;\r\n                                // Process each child in the temporary line, until the whole\r\n                                // line fits, preferably with an ellipsis\r\n                                // TODO use iterator instead\r\n                                var node_1 = lineInfo.element.node;\r\n                                if (node_1 && node_1.childNodes) {\r\n                                    for (var e = lineInfo.element.node.childNodes.length - 1; e >= 0; e--) {\r\n                                        // Get current element\r\n                                        var node_2 = lineInfo.element.node.childNodes[e];\r\n                                        // Add ellipsis only if previous chunk was removed in full\r\n                                        // and this chunk already fits\r\n                                        //if (addEllipsis && (bbox.width <= maxWidth)) {\r\n                                        if (addEllipsis && (lineInfo.bbox.width <= maxWidth)) {\r\n                                            // Add ellipsis\r\n                                            node_2.textContent += \" \" + this.ellipsis;\r\n                                            // Measure again (we need to make sure ellipsis fits)\r\n                                            lineInfo.bbox = lineInfo.element.getBBox();\r\n                                            lineInfo.bbox.width = Math.floor(lineInfo.bbox.width);\r\n                                            // If it fits, we're done here\r\n                                            // If it doesn't we continue rolling\r\n                                            if (lineInfo.bbox.width <= maxWidth) {\r\n                                                break;\r\n                                            }\r\n                                        }\r\n                                        addEllipsis = false;\r\n                                        // Get element text\r\n                                        var elementText = node_2.textContent;\r\n                                        // Calculate average number of symbols / width\r\n                                        lineText = lineInfo.element.textContent;\r\n                                        excessChars = $math.min(Math.ceil((lineInfo.bbox.width - maxWidth) / avgCharWidth), lineText.length);\r\n                                        // Do this until we fit\r\n                                        while ((lineInfo.bbox.width > maxWidth) && (excessChars <= lineText.length) && (excessChars > 0)) {\r\n                                            // Calculate max available chars\r\n                                            var maxChars = $math.max(lineText.length - excessChars - this.ellipsis.length, 1);\r\n                                            // Is there anything left?\r\n                                            if (maxChars <= 1) {\r\n                                                // Nope, let's jump to the previous item\r\n                                                // Set excess characters to zero so that this loop does\r\n                                                // not repeat when it over\r\n                                                excessChars = 0;\r\n                                                // Add ellipsis to previous item\r\n                                                // Subsequent iterations will check if the ellipsis fits\r\n                                                if (e > 0) {\r\n                                                    // Indicating to add ellipsis to previous item\r\n                                                    addEllipsis = true;\r\n                                                    // Removing this node\r\n                                                    lineInfo.element.node.removeChild(node_2);\r\n                                                }\r\n                                            }\r\n                                            // Truncate the text\r\n                                            elementText = $utils.truncateWithEllipsis(elementText, maxChars, this.ellipsis, this.fullWords, this.rtl);\r\n                                            if ((elementText.length > maxChars) && this.fullWords) {\r\n                                                // Still too long?\r\n                                                // Let's try truncating breaking words anyway\r\n                                                elementText = $utils.truncateWithEllipsis(elementText, maxChars, this.ellipsis, false, this.rtl);\r\n                                            }\r\n                                            // Set truncated text\r\n                                            node_2.textContent = elementText;\r\n                                            // Measure again\r\n                                            lineInfo.bbox = lineInfo.element.getBBox();\r\n                                            lineInfo.bbox.width = Math.floor(lineInfo.bbox.width);\r\n                                            // Increase excess characters count, just in case it still\r\n                                            // doesn't fit and we have to go at it again\r\n                                            excessChars = Math.ceil(excessChars * 1.1);\r\n                                        }\r\n                                        // Do not process further chunks\r\n                                        skipTextChunks = true;\r\n                                    }\r\n                                }\r\n                            }\r\n                            else {\r\n                                /**\r\n                                 * Processign auto-wrap\r\n                                 * In this case we're going to be adding text chunks until\r\n                                 * they don't fit into current line. Once that happens we will\r\n                                 * inject the rest of the chunks to the next line\r\n                                 */\r\n                                // Get last node added and measure it\r\n                                var node_3 = lineInfo.element.node;\r\n                                if (node_3) {\r\n                                    var lastNode = lineInfo.element.node.lastChild;\r\n                                    // Init split lines\r\n                                    var splitLines = void 0;\r\n                                    while ((lineInfo.bbox.width > maxWidth) && (excessChars <= lineText.length) && (excessChars > 0)) {\r\n                                        // Calculate max available chars\r\n                                        var maxChars = $math.max(chunk.text.length - excessChars, 1);\r\n                                        // Don't split the words mid-word if it's not the first chunk\r\n                                        // in the line\r\n                                        if (firstChunk) {\r\n                                            // Split mid-word if necessary\r\n                                            splitLines = $utils.splitTextByCharCount(chunk.text, maxChars, true, this.rtl);\r\n                                        }\r\n                                        else {\r\n                                            // Don't split mid-word\r\n                                            splitLines = $utils.splitTextByCharCount(chunk.text, maxChars, true, this.rtl, false);\r\n                                            // Check if the first word is too long\r\n                                            if ((splitLines[0].length > maxChars) || maxChars === 1) {\r\n                                                // Yes - move the whole chunk to the next line\r\n                                                // Remove the element we just added\r\n                                                lineInfo.element.node.removeChild(lastNode);\r\n                                                // Break out of the while on next cycle\r\n                                                excessChars = 0;\r\n                                            }\r\n                                        }\r\n                                        // Use the first line to update last item\r\n                                        if (excessChars > 0) {\r\n                                            var lineText_1 = splitLines.shift();\r\n                                            if (firstChunk) {\r\n                                                lineText_1 = $utils.trim(lineText_1);\r\n                                            }\r\n                                            lastNode.textContent = getTextFormatter().cleanUp(lineText_1);\r\n                                        }\r\n                                        // Measure again, just in case\r\n                                        lineInfo.bbox = lineInfo.element.getBBox();\r\n                                        lineInfo.bbox.width = Math.floor(lineInfo.bbox.width);\r\n                                        // Increase excess characters count, just in case it still\r\n                                        // doesn't fit and we have to go at it again\r\n                                        //excessChars = Math.ceil(excessChars * 1.05);\r\n                                        excessChars++;\r\n                                    }\r\n                                    // Construct the rest of the line\r\n                                    if (splitLines.length > 0) {\r\n                                        var restOfLine = \"\";\r\n                                        // Add leftovers from splitting the current chunk\r\n                                        if ($type.hasValue(splitLines)) {\r\n                                            if (this.rtl) {\r\n                                                restOfLine += splitLines.join(\"\") + currentFormat;\r\n                                            }\r\n                                            else {\r\n                                                restOfLine += currentFormat + splitLines.join(\"\").replace(/([\\[\\]]{1})/g, \"$1$1\");\r\n                                            }\r\n                                        }\r\n                                        // Add the rest of the chunks\r\n                                        for (var c = x + 1; c < chunks.length; c++) {\r\n                                            if (chunks[c].type == \"value\") {\r\n                                                // We're escaping single square brackets that were\r\n                                                // cleaned up by chunk() back to double square brackets\r\n                                                // so that they are not being treated as format on\r\n                                                // next pass.\r\n                                                restOfLine += chunks[c].text.replace(/([\\[\\]]{1})/g, \"$1$1\");\r\n                                            }\r\n                                            else {\r\n                                                restOfLine += chunks[c].text;\r\n                                            }\r\n                                        }\r\n                                        // Inject the rest of the lines as chunks for subsequent\r\n                                        lines.splice(i + 1, 0, restOfLine);\r\n                                    }\r\n                                    // Skip processing the rest of the chunks\r\n                                    skipTextChunks = true;\r\n                                }\r\n                            }\r\n                        }\r\n                        // Let's update the text's bbox with the line's one\r\n                        if (this.bbox.width < lineInfo.bbox.width) {\r\n                            this.bbox.width = lineInfo.bbox.width;\r\n                        }\r\n                        // commented to avoid bug (seen on sankey link) where text is incorrectly aligned\r\n                        //if (this.bbox.x > lineInfo.bbox.x) {\r\n                        //this.bbox.x = lineInfo.bbox.x;\r\n                        //}\r\n                        this.bbox.height = currentHeight + currentLineHeight;\r\n                        // Position current line\r\n                        if (!this.textPathElement) {\r\n                            lineInfo.element.attr({\r\n                                \"x\": \"0\",\r\n                                \"y\": currentHeight + currentLineHeight,\r\n                                \"dy\": $math.round((this.baseLineRatio * currentLineHeight), 3).toString()\r\n                            });\r\n                        }\r\n                        else {\r\n                            lineInfo.element.attr({\r\n                                \"dy\": -this.paddingBottom.toString()\r\n                            });\r\n                        }\r\n                        firstChunk = false;\r\n                    }\r\n                }\r\n                // Trim the last item\r\n                var node = lineInfo.element.node;\r\n                if (node) {\r\n                    var lastNode = node.lastChild;\r\n                    if (lastNode) {\r\n                        lastNode.textContent = this.rtl ?\r\n                            $utils.ltrim(lastNode.textContent) :\r\n                            $utils.rtrim(lastNode.textContent);\r\n                    }\r\n                }\r\n                // Increment collective height\r\n                currentHeight += currentLineHeight;\r\n                // Save line cache\r\n                this.addLineInfo(lineInfo, i);\r\n            }\r\n            // Check if maybe we need to hide the whole label if it doesn't fit\r\n            this.maybeHideOversized();\r\n            this.measureFailed = false;\r\n            if (this.bbox.width == 0 || this.bbox.height == 0) {\r\n                this.measureFailed = true;\r\n            }\r\n            // Updated measured dims\r\n            this._measuredWidth = $math.round($math.max(this.bbox.width, this.pixelWidth - this.pixelPaddingLeft - this.pixelPaddingRight));\r\n            this._measuredHeight = $math.round($math.max(this.bbox.height, this.pixelHeight - this.pixelPaddingTop - this.pixelPaddingBottom));\r\n            // Align the lines\r\n            this.alignSVGText();\r\n            this.bbox.width = this._measuredWidth;\r\n            this.bbox.height = this._measuredHeight;\r\n            if (oldH != this._measuredHeight || oldW != this._measuredWidth) {\r\n                this.dispatch(\"transformed\");\r\n            }\r\n            this.hideUnused(lines.length);\r\n        }\r\n        else {\r\n            /**\r\n             * HTML\r\n             */\r\n            this.element.removeAttr(\"display\");\r\n            this.resetBBox();\r\n            // Clear the element\r\n            var group = this.element;\r\n            group.removeChildren();\r\n            this.setCache(\"lineInfo\", [], 0);\r\n            // Create a ForeignObject to use as HTML container\r\n            var fo = this.paper.foreignObject();\r\n            group.add(fo);\r\n            // Set widths on foreignObject so that autosizing measurements work\r\n            // This will bet reset to actual content width/height\r\n            if (this.maxWidth) {\r\n                fo.attr({\r\n                    width: this.maxWidth - this.pixelPaddingLeft - this.pixelPaddingRight\r\n                });\r\n            }\r\n            if (this.maxHeight) {\r\n                fo.attr({\r\n                    height: this.maxHeight - this.pixelPaddingTop - this.pixelPaddingBottom\r\n                });\r\n            }\r\n            // Create line element\r\n            //let lineElement: HTMLElement = this.getHTMLLineElement(getTextFormatter().format(this.html, output));\r\n            var lineElement = this.getHTMLLineElement(text);\r\n            fo.node.appendChild(lineElement);\r\n            // Temporarily set to inline-block so we can measure real width and height\r\n            lineElement.style.display = \"inline-block\";\r\n            var clientWidth = lineElement.clientWidth;\r\n            var clientHeight = lineElement.clientHeight;\r\n            lineElement.style.display = \"block\";\r\n            this._bbox = {\r\n                x: 0,\r\n                y: 0,\r\n                width: clientWidth,\r\n                height: clientHeight\r\n            };\r\n            // Set exact dimensions of foreignObject so it is sized exactly as\r\n            // the content within (add one pixel to width so it does not wrap)\r\n            fo.attr({\r\n                width: clientWidth + 1,\r\n                height: clientHeight\r\n            });\r\n            // Check if maybe we need to hide the whole label if it doesn't fit\r\n            this.maybeHideOversized();\r\n            // Set measurements and update bbox\r\n            this._measuredWidth = $math.max(this.bbox.width, this.pixelWidth - this.pixelPaddingLeft - this.pixelPaddingRight);\r\n            this._measuredHeight = $math.max(this.bbox.height, this.pixelHeight - this.pixelPaddingTop - this.pixelPaddingBottom);\r\n            this.bbox.width = this._measuredWidth;\r\n            this.bbox.height = this._measuredHeight;\r\n            // Don't let labels bleed out of the alotted area\r\n            if (this.truncate) {\r\n                lineElement.style.overflow = \"hidden\";\r\n            }\r\n            if ((clientWidth > maxWidth) || (clientHeight > maxHeight)) {\r\n                this.isOversized = true;\r\n            }\r\n        }\r\n        // Set applicable styles\r\n        this.setStyles();\r\n        this.updateCenter();\r\n        this.updateBackground();\r\n        if (display == \"none\") {\r\n            this.group.attr({ display: \"none\" });\r\n        }\r\n        if (this.pathElement) {\r\n            this.paper.appendDef(this.pathElement);\r\n        }\r\n    };\r\n    /**\r\n     * Hides element if it does not fit into available space\r\n     */\r\n    Label.prototype.maybeHideOversized = function () {\r\n        if (this.hideOversized) {\r\n            if ((this.availableWidth < this.bbox.width) || (this.availableHeight < this.bbox.height)) {\r\n                this.element.attr({ display: \"none\" });\r\n                this.isOversized = true;\r\n            }\r\n            else {\r\n                this.element.removeAttr(\"display\");\r\n                this.isOversized = false;\r\n            }\r\n        }\r\n    };\r\n    /**\r\n     * Aligns the lines horizontally and vertically, based on properties.\r\n     *\r\n     * @ignore Exclude from docs\r\n     */\r\n    Label.prototype.alignSVGText = function () {\r\n        // Get Group\r\n        var group = this.element;\r\n        var children = group.node.children || group.node.childNodes;\r\n        // Is there anything to align?\r\n        if (!children || (children && children.length == 0)) {\r\n            return;\r\n        }\r\n        var width = this._measuredWidth;\r\n        var height = this._measuredHeight;\r\n        // TODO maybe these aren't needed ?\r\n        $utils.used(this.pixelPaddingLeft);\r\n        $utils.used(this.pixelPaddingRight);\r\n        $utils.used(this.pixelPaddingTop);\r\n        $utils.used(this.pixelPaddingBottom);\r\n        if (this.rtl) {\r\n            group.attr({\r\n                \"direction\": \"rtl\"\r\n            });\r\n        }\r\n        else {\r\n            group.removeAttr(\"direction\");\r\n        }\r\n        // Process each line\r\n        //$iter.each(group.children.backwards().iterator(), (element) => {\r\n        for (var i = children.length - 1; i >= 0; i--) {\r\n            // Align horizontally\r\n            // Since we are using `text-anchor` for horizontal alignment, all we need\r\n            // to do here is move the `x` position\r\n            var node = children[i];\r\n            node.setAttribute(\"text-anchor\", this.textAlign);\r\n            if (this.textPathElement) {\r\n                node.removeAttribute(\"x\");\r\n                node.removeAttribute(\"y\");\r\n            }\r\n            else {\r\n                switch (this.textAlign) {\r\n                    case \"middle\":\r\n                        node.setAttribute(\"x\", (width / 2).toString() + \"px\");\r\n                        break;\r\n                    case \"end\":\r\n                        if (this.rtl) {\r\n                        }\r\n                        else {\r\n                            node.setAttribute(\"x\", width.toString());\r\n                        }\r\n                        break;\r\n                    default:\r\n                        if (this.rtl) {\r\n                            node.setAttribute(\"x\", width.toString());\r\n                        }\r\n                        else {\r\n                            node.removeAttribute(\"text-anchor\");\r\n                        }\r\n                        break;\r\n                }\r\n                var y = $type.toNumber(node.getAttribute(\"y\"));\r\n                switch (this.textValign) {\r\n                    case \"middle\":\r\n                        node.setAttribute(\"y\", ((y || 0) + (height - this.bbox.height) / 2).toString());\r\n                        break;\r\n                    case \"bottom\":\r\n                        node.setAttribute(\"y\", ((y || 0) + height - this.bbox.height).toString());\r\n                        break;\r\n                    default:\r\n                        node.setAttribute(\"y\", (y || 0).toString());\r\n                        break;\r\n                }\r\n            }\r\n        }\r\n    };\r\n    /**\r\n     * Produces an SVG line element with formatted text.\r\n     *\r\n     * @ignore Exclude from docs\r\n     * @param text    Text to wrap into line\r\n     * @param y       Current line vertical position\r\n     * @return A DOM element\r\n     * @todo Implement HTML support\r\n     */\r\n    Label.prototype.getSVGLineElement = function (text, y) {\r\n        // Create a <text> node and set text\r\n        var element = this.paper.addGroup(\"text\");\r\n        element.textContent = text;\r\n        // Set parameters\r\n        element.attr({\r\n            \"x\": \"0\"\r\n            //\"alignment-baseline\": \"hanging\",\r\n            //\"baseline-shift\": \"-20%\",\r\n            //\"text-anchor\": \"center\"\r\n        });\r\n        // Set `y` position\r\n        if ($type.hasValue(y)) {\r\n            element.attr({\r\n                \"y\": y.toString()\r\n            });\r\n        }\r\n        // Don't let labels blled out of the alotted area\r\n        if (this.truncate || this.wrap) {\r\n            element.attr({ \"overflow\": \"hidden\" });\r\n        }\r\n        // Add RTL?\r\n        // This has now been moved to this.alignSVGText()\r\n        // if (this.rtl) {\r\n        // \telement.attr({\r\n        // \t\t\"direction\": \"rtl\",\r\n        // \t\t//\"unicode-bidi\": \"bidi-override\"\r\n        // \t});\r\n        // }\r\n        return element;\r\n    };\r\n    Object.defineProperty(Label.prototype, \"rtl\", {\r\n        /**\r\n         * @return RTL?\r\n         */\r\n        get: function () {\r\n            if ($type.hasValue(this._rtl)) {\r\n                return this._rtl;\r\n            }\r\n            else if (this._topParent) {\r\n                return this._topParent.rtl;\r\n            }\r\n            return false;\r\n        },\r\n        /**\r\n         * An RTL (right-to-left) setting.\r\n         *\r\n         * RTL may affect alignment, text, and other visual properties.\r\n         *\r\n         * If you set this on a top-level chart object, it will be used for all\r\n         * child elements, e.g. labels, unless they have their own `rtl` setting\r\n         * set directly on them.\r\n         *\r\n         * @param value  `true` for to use RTL\r\n         */\r\n        set: function (value) {\r\n            value = $type.toBoolean(value);\r\n            this._rtl = value;\r\n            if (this.element) {\r\n                this.alignSVGText();\r\n            }\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    /**\r\n     * Resets cached BBox.\r\n     *\r\n     * @ignore Exclude from docs\r\n     */\r\n    Label.prototype.resetBBox = function () {\r\n        this._bbox = { x: 0, y: 0, width: 0, height: 0 };\r\n    };\r\n    /**\r\n     * Creates and returns an HTML line element (`<div>`).\r\n     *\r\n     * @ignore Exclude from docs\r\n     * @param text  Text to add\r\n     * @return `<div>` element reference\r\n     */\r\n    Label.prototype.getHTMLLineElement = function (text) {\r\n        // Create the <div> element\r\n        var div = document.createElement(\"div\");\r\n        div.innerHTML = text;\r\n        // Set text alignment\r\n        switch (this.textAlign) {\r\n            case \"middle\":\r\n                div.style.textAlign = \"center\";\r\n                break;\r\n            case \"end\":\r\n                div.style.textAlign = \"right\";\r\n                break;\r\n        }\r\n        // Disable or enable wrapping\r\n        if (this.wrap) {\r\n            div.style.wordWrap = \"break-word\";\r\n        }\r\n        else {\r\n            div.style.whiteSpace = \"nowrap\";\r\n        }\r\n        // Don't let labels bleed out of the alotted area\r\n        // Moved to `draw()` because setting \"hidden\" kills all measuring\r\n        /*if (this.truncate) {\r\n            div.style.overflow = \"hidden\";\r\n        }*/\r\n        // Set RTL-related styles\r\n        if (this.rtl) {\r\n            div.style.direction = \"rtl\";\r\n            //div.style.unicodeBidi = \"bidi-override\";\r\n        }\r\n        // Translate some of the SVG styles into CSS\r\n        if ($type.hasValue(this.fill)) {\r\n            div.style.color = this.fill.toString();\r\n        }\r\n        return div;\r\n    };\r\n    /**\r\n     * Applies specific styles to text to make it not selectable, unless it is\r\n     * explicitly set as `selectable`.\r\n     *\r\n     * @ignore Exclude from docs\r\n     * @todo Set styles via AMElement\r\n     */\r\n    Label.prototype.setStyles = function () {\r\n        var group = this.element;\r\n        if (!this.selectable || this.draggable || this.resizable || this.swipeable) {\r\n            group.addStyle({\r\n                \"webkitUserSelect\": \"none\",\r\n                \"msUserSelect\": \"none\"\r\n            });\r\n        }\r\n        else if (this.selectable) {\r\n            group.removeStyle(\"webkitUserSelect\");\r\n            group.removeStyle(\"msUserSelect\");\r\n        }\r\n    };\r\n    /**\r\n     * Hides unused lines\r\n     */\r\n    Label.prototype.hideUnused = function (index) {\r\n        this.initLineCache();\r\n        var lines = this.getCache(\"lineInfo\");\r\n        if (lines.length >= index) {\r\n            for (var i = index; i < lines.length; i++) {\r\n                var line = lines[i];\r\n                if (line && line.element) {\r\n                    line.element.attr({ \"display\": \"none\" });\r\n                }\r\n            }\r\n        }\r\n    };\r\n    Object.defineProperty(Label.prototype, \"text\", {\r\n        /**\r\n         * @return SVG text\r\n         */\r\n        get: function () {\r\n            return this.getPropertyValue(\"text\");\r\n        },\r\n        /**\r\n         * An SVG text.\r\n         *\r\n         * Please note that setting `html` will override this setting if browser\r\n         * supports `foreignObject` in SGV, such as most modern browsers excluding\r\n         * IEs.\r\n         *\r\n         * @param value  SVG Text\r\n         */\r\n        set: function (value) {\r\n            //this.setPropertyValue(\"html\", undefined);\r\n            this.setPropertyValue(\"text\", value, true);\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(Label.prototype, \"path\", {\r\n        /**\r\n         * @return Path\r\n         */\r\n        get: function () {\r\n            return this.getPropertyValue(\"path\");\r\n        },\r\n        /**\r\n         * An SVG path string to position text along. If set, the text will follow\r\n         * the curvature of the path.\r\n         *\r\n         * Location along the path can be set using `locationOnPath`.\r\n         *\r\n         * IMPORTANT: Only SVG text can be put on path. If you are using HTML text\r\n         * this setting will be ignored.\r\n         *\r\n         * @since 4.1.2\r\n         * @param  value  Path\r\n         */\r\n        set: function (value) {\r\n            if (this.setPropertyValue(\"path\", value, true)) {\r\n                if (this.pathElement) {\r\n                    this.pathElement.dispose();\r\n                }\r\n                if (this.textPathElement) {\r\n                    this.textPathElement.dispose();\r\n                }\r\n                this.pathElement = this.paper.add(\"path\");\r\n                this.pathElement.attr({ \"d\": value });\r\n                this.pathElement.attr({ \"id\": \"text-path-\" + this.uid });\r\n                this._disposers.push(this.pathElement);\r\n                this.textPathElement = this.paper.addGroup(\"textPath\");\r\n                this.textPathElement.attrNS($dom.XLINK, \"xlink:href\", \"#text-path-\" + this.uid);\r\n                // TODO remove after https://bugzilla.mozilla.org/show_bug.cgi?id=455986 is fixed\r\n                this.textPathElement.attr({ \"path\": value });\r\n                this._disposers.push(this.textPathElement);\r\n                this.hardInvalidate();\r\n            }\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(Label.prototype, \"locationOnPath\", {\r\n        /**\r\n         * @return Relatvie location on path\r\n         */\r\n        get: function () {\r\n            return this.getPropertyValue(\"locationOnPath\");\r\n        },\r\n        /**\r\n         * Relative label location on `path`. Value range is from 0 (beginning)\r\n         * to 1 (end).\r\n         *\r\n         * Works only if you set `path` setting to an SVG path.\r\n         *\r\n         * @since 4.1.2\r\n         * @default 0\r\n         * @param  value  Relatvie location on path\r\n         */\r\n        set: function (value) {\r\n            this.setPropertyValue(\"locationOnPath\", value);\r\n            if (this.textPathElement) {\r\n                this.textPathElement.attr({ \"startOffset\": (value * 100) + \"%\" });\r\n            }\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(Label.prototype, \"baseLineRatio\", {\r\n        /**\r\n         * @return Base line ratio\r\n         */\r\n        get: function () {\r\n            return this.getPropertyValue(\"baseLineRatio\");\r\n        },\r\n        /**\r\n         * A ratio to calculate text baseline. Ralative distance from the bottom of\r\n         * the label.\r\n         *\r\n         * @since 4.4.2\r\n         * @default -0.27\r\n         * @param  value  Base line ratio\r\n         */\r\n        set: function (value) {\r\n            this.setPropertyValue(\"baseLineRatio\", value);\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(Label.prototype, \"wrap\", {\r\n        /**\r\n         * @return Auto-wrap enabled or not\r\n         */\r\n        get: function () {\r\n            return this.getPropertyValue(\"wrap\");\r\n        },\r\n        /**\r\n         * Enables or disables autowrapping of text.\r\n         *\r\n         * @param value  Auto-wrapping enabled\r\n         */\r\n        set: function (value) {\r\n            this.resetBBox();\r\n            this.setPropertyValue(\"wrap\", value, true);\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(Label.prototype, \"truncate\", {\r\n        /**\r\n         * @return Truncate text?\r\n         */\r\n        get: function () {\r\n            return this.getPropertyValue(\"truncate\");\r\n        },\r\n        /**\r\n         * Indicates if text lines need to be truncated if they do not fit, using\r\n         * configurable `ellipsis` string.\r\n         *\r\n         * `truncate` overrides `wrap` if both are set to `true`.\r\n         *\r\n         * NOTE: For HTML text, this setting **won't** trigger a parser and actual\r\n         * line truncation with ellipsis. It will just hide everything that goes\r\n         * outside the label.\r\n         *\r\n         * @param value  trincate text?\r\n         */\r\n        set: function (value) {\r\n            this.resetBBox();\r\n            this.setPropertyValue(\"truncate\", value, true);\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(Label.prototype, \"fullWords\", {\r\n        /**\r\n         * @return Truncate on full words?\r\n         */\r\n        get: function () {\r\n            return this.getPropertyValue(\"fullWords\");\r\n        },\r\n        /**\r\n         * If `truncate` is enabled, should Label try to break only on full words\r\n         * (`true`), or whenever needed, including middle of the word. (`false`)\r\n         *\r\n         * @default true\r\n         * @param value  Truncate on full words?\r\n         */\r\n        set: function (value) {\r\n            this.setPropertyValue(\"fullWords\", value, true);\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(Label.prototype, \"ellipsis\", {\r\n        /**\r\n         * @return Ellipsis string\r\n         */\r\n        get: function () {\r\n            return this.getPropertyValue(\"ellipsis\");\r\n        },\r\n        /**\r\n         * Ellipsis character to use if `truncate` is enabled.\r\n         *\r\n         * @param value Ellipsis string\r\n         * @default \"...\"\r\n         */\r\n        set: function (value) {\r\n            this.setPropertyValue(\"ellipsis\", value, true);\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(Label.prototype, \"selectable\", {\r\n        /**\r\n         * @return Text selectable?\r\n         */\r\n        get: function () {\r\n            return this.getPropertyValue(\"selectable\");\r\n        },\r\n        /**\r\n         * Forces the text to be selectable. This setting will be ignored if the\r\n         * object has some kind of interaction attached to it, such as it is\r\n         * `draggable`, `swipeable`, `resizable`.\r\n         *\r\n         * @param value  Text selectable?\r\n         * @default false\r\n         */\r\n        set: function (value) {\r\n            this.setPropertyValue(\"selectable\", value, true);\r\n            this.setStyles();\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(Label.prototype, \"textAlign\", {\r\n        /**\r\n         * @return Alignment\r\n         */\r\n        get: function () {\r\n            return this.getPropertyValue(\"textAlign\");\r\n        },\r\n        /**\r\n         * Horizontal text alignment.\r\n         *\r\n         * Available choices:\r\n         * * \"start\"\r\n         * * \"middle\"\r\n         * * \"end\"\r\n         *\r\n         * @param value  Alignment\r\n         */\r\n        set: function (value) {\r\n            this.setPropertyValue(\"textAlign\", value, true);\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(Label.prototype, \"textValign\", {\r\n        /**\r\n         * @ignore Exclude from docs (not used)\r\n         * @return Alignment\r\n         * @deprecated\r\n         */\r\n        get: function () {\r\n            return this.getPropertyValue(\"textValign\");\r\n        },\r\n        /**\r\n         * Vertical text alignment.\r\n         *\r\n         * @ignore Exclude from docs (not used)\r\n         * @param value  Alignment\r\n         * @deprecated\r\n         */\r\n        set: function (value) {\r\n            this.setPropertyValue(\"textValign\", value, true);\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(Label.prototype, \"html\", {\r\n        /**\r\n         * @return HTML content\r\n         */\r\n        get: function () {\r\n            return this.getPropertyValue(\"html\");\r\n        },\r\n        /**\r\n         * Raw HTML to be used as text.\r\n         *\r\n         * NOTE: HTML text is subject to browser support. It relies on browsers\r\n         * supporting SVG `foreignObject` nodes. Some browsers (read IEs) do not\r\n         * support it. On those browsers, the text will fall back to basic SVG text,\r\n         * striping out all HTML markup and styling that goes with it.\r\n         *\r\n         * For more information about `foreignObject` and its browser compatibility\r\n         * refer to [this page](https://developer.mozilla.org/en/docs/Web/SVG/Element/foreignObject#Browser_compatibility).\r\n         *\r\n         * @param value HTML text\r\n         */\r\n        set: function (value) {\r\n            this.setPropertyValue(\"html\", value, true);\r\n            if (!$type.hasValue(value)) {\r\n                var group = this.element;\r\n                group.removeChildrenByTag(\"foreignObject\");\r\n            }\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Label.prototype.setFill = function (value) {\r\n        _super.prototype.setFill.call(this, value);\r\n        if (this.html) {\r\n            var group = this.element;\r\n            var divs = group.node.getElementsByTagName(\"div\");\r\n            for (var i = 0; i < divs.length; i++) {\r\n                var div = divs[i];\r\n                if ($type.hasValue(this.fill)) {\r\n                    div.style.color = this.fill.toString();\r\n                }\r\n            }\r\n        }\r\n    };\r\n    Object.defineProperty(Label.prototype, \"hideOversized\", {\r\n        /**\r\n         * @return Hide if text does not fit?\r\n         */\r\n        get: function () {\r\n            return this.getPropertyValue(\"hideOversized\");\r\n        },\r\n        /**\r\n         * Indicates whether the whole text should be hidden if it does not fit into\r\n         * its allotted space.\r\n         *\r\n         * @param value  Hide if text does not fit?\r\n         */\r\n        set: function (value) {\r\n            this.setPropertyValue(\"hideOversized\", value, true);\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(Label.prototype, \"ignoreFormatting\", {\r\n        /**\r\n         * @return Ignore formatting?\r\n         */\r\n        get: function () {\r\n            return this.getPropertyValue(\"ignoreFormatting\");\r\n        },\r\n        /**\r\n         * If set to `true` square-bracket formatting blocks will be treated as\r\n         * regular text.\r\n         *\r\n         * @default false\r\n         * @param value  Ignore formatting?\r\n         */\r\n        set: function (value) {\r\n            this.setPropertyValue(\"ignoreFormatting\", value, true);\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    /**\r\n     * Override `mesaureElement` so it does not get measure again, because\r\n     * internal `_bbox` is being updated by measuring routines in Text itself.\r\n     */\r\n    Label.prototype.measureElement = function () { };\r\n    /**\r\n     * Returns information about a line element.\r\n     *\r\n     * @ignore Exclude from docs\r\n     * @param index  Line index\r\n     * @return Line info object\r\n     */\r\n    Label.prototype.getLineInfo = function (index) {\r\n        this.initLineCache();\r\n        var lines = this.getCache(\"lineInfo\");\r\n        return lines.length > index ? lines[index] : undefined;\r\n    };\r\n    /**\r\n     * Adds a line to line info cache.\r\n     *\r\n     * @ignore Exclude from docs\r\n     * @param line     Line info object\r\n     * @param index    Insert at specified index\r\n     */\r\n    Label.prototype.addLineInfo = function (line, index) {\r\n        this.initLineCache();\r\n        this.getCache(\"lineInfo\")[index] = line;\r\n    };\r\n    /**\r\n     * Checks if line cache is initialized and initializes it.\r\n     */\r\n    Label.prototype.initLineCache = function () {\r\n        if (!$type.hasValue(this.getCache(\"lineInfo\"))) {\r\n            this.setCache(\"lineInfo\", [], 0);\r\n        }\r\n    };\r\n    /**\r\n     * Sets a [[DataItem]] to use for populating dynamic sections of the text.\r\n     *\r\n     * Check the description for [[Text]] class, for data binding.\r\n     *\r\n     * @param dataItem Data item\r\n     */\r\n    Label.prototype.setDataItem = function (dataItem) {\r\n        if (this._sourceDataItemEvents) {\r\n            this._sourceDataItemEvents.dispose();\r\n        }\r\n        if (dataItem) {\r\n            this._sourceDataItemEvents = new MultiDisposer([\r\n                dataItem.events.on(\"valuechanged\", this.invalidate, this, false),\r\n                dataItem.events.on(\"workingvaluechanged\", this.invalidate, this, false),\r\n                dataItem.events.on(\"calculatedvaluechanged\", this.invalidate, this, false),\r\n                dataItem.events.on(\"propertychanged\", this.invalidate, this, false)\r\n            ]);\r\n        }\r\n        _super.prototype.setDataItem.call(this, dataItem);\r\n    };\r\n    Object.defineProperty(Label.prototype, \"availableWidth\", {\r\n        /**\r\n         * Returns available horizontal space.\r\n         *\r\n         * @ignore Exclude from docs\r\n         * @return Available width (px)\r\n         */\r\n        get: function () {\r\n            return $type.hasValue(this.maxWidth) ? this.maxWidth : this.pixelWidth;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(Label.prototype, \"availableHeight\", {\r\n        /**\r\n         * Returns available vertical space.\r\n         *\r\n         * @return Available height (px)\r\n         */\r\n        get: function () {\r\n            return $type.hasValue(this.maxHeight) ? this.maxHeight : this.pixelHeight;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    // temp, replacing textFormatter method\r\n    Label.prototype.getSvgElement = function (text, style, parent) {\r\n        var element = this.paper.add(\"tspan\");\r\n        element.textContent = text;\r\n        if (style) {\r\n            if (options.nonce && parent) {\r\n                //element.node.setAttribute(\"nonce\", \"test123\");\r\n                var classid = \"amcharts_element_style_\" + btoa(style).replace(/[^\\w]*/g, \"\");\r\n                element.node.setAttribute(\"class\", classid);\r\n                var defs = document.createElementNS($dom.SVGNS, \"defs\");\r\n                parent.node.appendChild(defs);\r\n                var e = document.createElement(\"style\");\r\n                e.type = \"text/css\";\r\n                e.innerHTML = \".\" + classid + \" { \" + style + \"}\";\r\n                e.setAttribute(\"nonce\", options.nonce);\r\n                defs.appendChild(e);\r\n            }\r\n            else {\r\n                element.node.setAttribute(\"style\", style);\r\n            }\r\n        }\r\n        if (parent) {\r\n            parent.add(element);\r\n        }\r\n        return element;\r\n    };\r\n    /**\r\n     * Invalidates the whole element, including layout AND all its child\r\n     * elements.\r\n     */\r\n    Label.prototype.deepInvalidate = function () {\r\n        _super.prototype.deepInvalidate.call(this);\r\n        this.hardInvalidate();\r\n    };\r\n    Object.defineProperty(Label.prototype, \"readerTitle\", {\r\n        /**\r\n         * @return Title\r\n         */\r\n        get: function () {\r\n            var title = this.getPropertyValue(\"readerTitle\");\r\n            if (!title) {\r\n                title = this.populateString($utils.plainText($utils.isNotEmpty(this.html)\r\n                    ? this.html\r\n                    : this.text));\r\n            }\r\n            else if (this.dataItem) {\r\n                title = this.populateString(title);\r\n            }\r\n            return title;\r\n        },\r\n        /**\r\n         * Screen reader title of the element.\r\n         *\r\n         * @param value Title\r\n         */\r\n        set: function (value) {\r\n            value = $type.toText(value);\r\n            if (this.setPropertyValue(\"readerTitle\", value)) {\r\n                this.applyAccessibility();\r\n            }\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    return Label;\r\n}(Container));\r\nexport { Label };\r\n/**\r\n * Register class in system, so that it can be instantiated using its name from\r\n * anywhere.\r\n *\r\n * @ignore\r\n */\r\nregistry.registeredClasses[\"Label\"] = Label;\r\n/**\r\n * Add default responsive rules\r\n */\r\n/**\r\n * Hide labels added directly to chart, like titles if chart is short.\r\n */\r\ndefaultRules.push({\r\n    relevant: ResponsiveBreakpoints.heightXS,\r\n    state: function (target, stateId) {\r\n        if (target instanceof Label && target.parent && target.parent.isBaseSprite) {\r\n            var state = target.states.create(stateId);\r\n            state.properties.disabled = true;\r\n            return state;\r\n        }\r\n        return null;\r\n    }\r\n});\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}