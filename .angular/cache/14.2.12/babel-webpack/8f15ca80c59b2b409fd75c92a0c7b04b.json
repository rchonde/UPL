{"ast":null,"code":"/**\r\n * Axis Label module\r\n */\nimport { __extends } from \"tslib\";\n/**\r\n * ============================================================================\r\n * IMPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\n\nimport { AxisLabel } from \"./AxisLabel\";\nimport { registry } from \"../../core/Registry\";\nimport * as $math from \"../../core/utils/Math\";\nimport * as $type from \"../../core/utils/Type\";\nimport * as $path from \"../../core/rendering/Path\";\nimport * as $utils from \"../../core/utils/Utils\";\nimport { Percent } from \"../../core/utils/Percent\";\n/**\r\n * ============================================================================\r\n * MAIN CLASS\r\n * ============================================================================\r\n * @hidden\r\n */\n\n/**\r\n * Use to create labels on circular axis.\r\n *\r\n * @see {@link IAxisLabelCircularEvents} for a list of available events\r\n * @see {@link IAxisLabelCircularAdapters} for a list of available Adapters\r\n */\n\nvar AxisLabelCircular =\n/** @class */\nfunction (_super) {\n  __extends(AxisLabelCircular, _super);\n  /**\r\n   * Constructor\r\n   */\n\n\n  function AxisLabelCircular() {\n    var _this = _super.call(this) || this;\n    /**\r\n     *\r\n     * @ignore\r\n     */\n\n\n    _this.fdx = 0;\n    /**\r\n     *\r\n     * @ignore\r\n     */\n\n    _this.fdy = 0;\n    _this.className = \"AxisLabelCircular\";\n\n    _this.padding(0, 0, 0, 0);\n\n    _this.location = 0.5;\n    _this.locationOnPath = 0.5;\n    _this.radius = 0;\n    _this.isMeasured = false;\n\n    _this.applyTheme();\n\n    return _this;\n  }\n\n  Object.defineProperty(AxisLabelCircular.prototype, \"relativeRotation\", {\n    /**\r\n     * @return Rotation angle\r\n     */\n    get: function () {\n      return this.getPropertyValue(\"relativeRotation\");\n    },\n\n    /**\r\n     * Relative rotation of the label.\r\n     *\r\n     * It is an angle to circle. In case 90, labels will be positioned like rays\r\n     * of light, if 0 - positioned along the circle.\r\n     *\r\n     * @param value Rotation angle\r\n     */\n    set: function (value) {\n      this.setPropertyValue(\"relativeRotation\", value, true);\n\n      if (!$type.hasValue(value)) {\n        this.rotation = undefined;\n        var dataItem = this.dataItem;\n\n        if (dataItem && dataItem.component) {\n          dataItem.component.invalidateDataItems();\n        }\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(AxisLabelCircular.prototype, \"radius\", {\n    /**\r\n     * @return Distance (px)\r\n     */\n    get: function () {\n      return this.getPropertyValue(\"radius\");\n    },\n\n    /**\r\n     * Distance from axis circle to label in pixels or percent.\r\n     *\r\n     * @param value Distance (px or percent)\r\n     */\n    set: function (value) {\n      this.setPercentProperty(\"radius\", value, true, false, 10, false);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(AxisLabelCircular.prototype, \"bent\", {\n    /**\r\n     * @return Bent?\r\n     */\n    get: function () {\n      return this.getPropertyValue(\"bent\");\n    },\n\n    /**\r\n     * Specifies if label should be bent along the circle.\r\n     *\r\n     * IMPORTANT: Use this with caution, since it is quite CPU-greedy.\r\n     *\r\n     * @since 4.1.2\r\n     * @default false\r\n     * @param  value  Bent?\r\n     */\n    set: function (value) {\n      this.setPropertyValue(\"bent\", value, true);\n      this.setPropertyValue(\"wrap\", false);\n      this.setPropertyValue(\"horizontalCenter\", \"none\");\n      this.setPropertyValue(\"verticalCenter\", \"none\");\n\n      if (value) {\n        this.setPropertyValue(\"dx\", 0);\n        this.setPropertyValue(\"dy\", 0);\n        this.setPropertyValue(\"x\", 0);\n        this.setPropertyValue(\"y\", 0);\n        this.setPropertyValue(\"rotation\", 0); //this.setPropertyValue(\"relativeRotation\", undefined);\n\n        this.fdx = 0;\n        this.fdy = 0;\n        this.textAlign = \"middle\";\n      } else {\n        if (this.textPathElement) {\n          this.textPathElement.dispose();\n          this.textPathElement = undefined;\n        }\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\r\n   * Returns label radius in pixels.\r\n   *\r\n   * @param   axisRadius  Radius\r\n   * @return              Pixel radius\r\n   */\n\n  AxisLabelCircular.prototype.pixelRadius = function (axisRadius) {\n    var sign = 1;\n\n    if (this.inside) {\n      sign = -1;\n    }\n\n    return $utils.relativeToValue(this.radius, axisRadius) * sign;\n  };\n  /**\r\n   * Returns label horizontal radius in pixels.\r\n   *\r\n   * @param   axisRadius   Radius\r\n   * @param   axisRadiusY  Vertical radius\r\n   * @return               Radius\r\n   */\n\n\n  AxisLabelCircular.prototype.pixelRadiusY = function (axisRadius, axisRadiusY) {\n    var sign = 1;\n\n    if (this.inside) {\n      sign = -1;\n    }\n\n    var radius = this.radius;\n\n    if ($type.isNumber(radius)) {\n      radius *= axisRadiusY / axisRadius;\n      return $utils.relativeToValue(radius, axisRadius) * sign;\n    } else {\n      return $utils.relativeToValue(radius, axisRadiusY) * sign;\n    }\n  };\n  /**\r\n   * [fixPosition description]\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @todo Description\r\n   * @param point       Label affixation point\r\n   * @param axisRadius  Distance from point (px)\r\n   */\n\n\n  AxisLabelCircular.prototype.fixPosition = function (angle, axisRadius, axisRadiusY, dx, dy) {\n    if (!$type.isNumber(axisRadiusY)) {\n      axisRadiusY = axisRadius;\n    }\n\n    if (!$type.isNumber(dx)) {\n      dx = 0;\n    }\n\n    if (!$type.isNumber(dy)) {\n      dy = 0;\n    }\n\n    var point = {\n      x: axisRadius * $math.cos(angle),\n      y: axisRadiusY * $math.sin(angle)\n    };\n\n    if (this.invalid) {\n      this.validate(); //@todo\" check if we need this\n    }\n\n    var isNegative = false;\n    var realRadius = this.radius;\n\n    if (realRadius instanceof Percent && realRadius.value < 0) {\n      isNegative = true;\n    } else if (realRadius < 0) {\n      isNegative = true;\n    }\n\n    var relativeRotation = this.relativeRotation;\n    var labelRadius = this.pixelRadius(axisRadius);\n\n    if (this.bent) {\n      var point_1 = {\n        x: (axisRadius + labelRadius) * $math.cos(angle + 180),\n        y: (axisRadiusY + labelRadius * axisRadiusY / axisRadius) * $math.sin(angle + 180)\n      };\n      this.path = $path.moveTo(point_1) + $path.arcTo(angle + 180, 360, axisRadius + labelRadius, axisRadiusY + labelRadius * axisRadiusY / axisRadius);\n\n      if (this.textPathElement) {\n        this.textPathElement.attr({\n          \"startOffset\": this.locationOnPath * 100 + \"%\"\n        });\n      }\n\n      return;\n    } // WHEN ROTATED\n\n\n    if ($type.isNumber(relativeRotation)) {\n      this.horizontalCenter = \"none\";\n      this.verticalCenter = \"none\";\n      angle = $math.fitAngleToRange(angle, -180, 180);\n      var pixelWidth = this.bbox.width;\n      var pixelHeight = this.bbox.height;\n      var pixelPaddingBottom = this.pixelPaddingBottom;\n      var pixelPaddingTop = this.pixelPaddingTop;\n      var pixelPaddingLeft = this.pixelPaddingLeft;\n      var pixelPaddingRight = this.pixelPaddingRight;\n\n      if (angle > 90 || angle < -90) {\n        if (relativeRotation == -90) {\n          relativeRotation = 90;\n          pixelWidth = 0;\n        }\n      } else {\n        if (relativeRotation == -90) {\n          pixelHeight = -pixelHeight;\n        }\n\n        if (relativeRotation == 90) {\n          relativeRotation = -90;\n          pixelWidth = -pixelPaddingLeft - pixelPaddingRight;\n          pixelHeight = -pixelHeight - pixelPaddingTop - pixelPaddingBottom;\n        }\n      }\n\n      this.rotation = relativeRotation + angle + 90;\n      var dH = $math.sin(relativeRotation) / 2;\n      var dW = $math.cos(relativeRotation) / 2;\n      var rotation = this.rotation;\n      this.dx = pixelHeight * dH * $math.sin(rotation) - pixelWidth * dW * $math.cos(rotation);\n      this.dy = -pixelHeight * dH * $math.cos(rotation) - pixelWidth * dW * $math.sin(rotation);\n\n      if (!this.inside) {\n        labelRadius += (pixelHeight + pixelPaddingBottom + pixelPaddingTop) * $math.cos(relativeRotation) + (pixelWidth + pixelPaddingLeft + pixelPaddingRight) * $math.sin(relativeRotation);\n      } else {\n        if (angle > 90 || angle < -90) {\n          labelRadius -= (pixelPaddingBottom + pixelPaddingTop) * $math.cos(relativeRotation) + (pixelPaddingLeft + pixelPaddingRight) * $math.sin(relativeRotation);\n        } else {\n          labelRadius += (pixelPaddingBottom + this.bbox.height + pixelPaddingTop) * $math.cos(relativeRotation) + (pixelPaddingLeft + pixelPaddingRight + this.bbox.width) * $math.sin(relativeRotation);\n        }\n      }\n\n      point.x += $math.cos(angle) * labelRadius;\n      point.y += $math.sin(angle) * labelRadius * axisRadiusY / axisRadius;\n    } else {\n      // END OF ROTATED\n      this.horizontalCenter = \"middle\";\n      this.verticalCenter = \"middle\";\n\n      if (isNegative) {\n        this.dx = 0;\n        this.dy = 0;\n        point.x = (axisRadius + labelRadius) * $math.cos(angle);\n        point.y = (axisRadiusY + labelRadius * axisRadiusY / axisRadius) * $math.sin(angle);\n      } else {\n        // we don't use valign for labels because then they would jump while animating. instead we modify dy depending on a y position\n        // this math makes dy to be 1 at the top of the circle, 0.5 at the middle and 1 at the bottom\n        // @todo with this math doesn't work well with inside = true\n        this.dy = this._measuredHeight / 2 * $math.sin(angle); //(1 - (point.y + axisRadiusY) / (2 * axisRadiusY));\n        // simmilar with dx\n\n        this.dx = this._measuredWidth / 2 * $math.cos(angle); //(1 - (point.x + axisRadius) / (2 * axisRadius));\n\n        point.x += $math.cos(angle) * labelRadius;\n        point.y += $math.sin(angle) * labelRadius * axisRadiusY / axisRadius;\n      }\n    }\n\n    point.x += dx;\n    point.y += dy;\n    this.fdx = this.dx;\n    this.fdy = this.dy;\n    this.moveTo(point);\n  };\n\n  return AxisLabelCircular;\n}(AxisLabel);\n\nexport { AxisLabelCircular };\n/**\r\n * Register class in system, so that it can be instantiated using its name from\r\n * anywhere.\r\n *\r\n * @ignore\r\n */\n\nregistry.registeredClasses[\"AxisLabelCircular\"] = AxisLabelCircular;","map":{"version":3,"names":["__extends","AxisLabel","registry","$math","$type","$path","$utils","Percent","AxisLabelCircular","_super","_this","call","fdx","fdy","className","padding","location","locationOnPath","radius","isMeasured","applyTheme","Object","defineProperty","prototype","get","getPropertyValue","set","value","setPropertyValue","hasValue","rotation","undefined","dataItem","component","invalidateDataItems","enumerable","configurable","setPercentProperty","textAlign","textPathElement","dispose","pixelRadius","axisRadius","sign","inside","relativeToValue","pixelRadiusY","axisRadiusY","isNumber","fixPosition","angle","dx","dy","point","x","cos","y","sin","invalid","validate","isNegative","realRadius","relativeRotation","labelRadius","bent","point_1","path","moveTo","arcTo","attr","horizontalCenter","verticalCenter","fitAngleToRange","pixelWidth","bbox","width","pixelHeight","height","pixelPaddingBottom","pixelPaddingTop","pixelPaddingLeft","pixelPaddingRight","dH","dW","_measuredHeight","_measuredWidth","registeredClasses"],"sources":["D:/APPLICATION/UI/UPL/NEW/node_modules/@amcharts/amcharts4/.internal/charts/axes/AxisLabelCircular.js"],"sourcesContent":["/**\r\n * Axis Label module\r\n */\r\nimport { __extends } from \"tslib\";\r\n/**\r\n * ============================================================================\r\n * IMPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\r\nimport { AxisLabel } from \"./AxisLabel\";\r\nimport { registry } from \"../../core/Registry\";\r\nimport * as $math from \"../../core/utils/Math\";\r\nimport * as $type from \"../../core/utils/Type\";\r\nimport * as $path from \"../../core/rendering/Path\";\r\nimport * as $utils from \"../../core/utils/Utils\";\r\nimport { Percent } from \"../../core/utils/Percent\";\r\n/**\r\n * ============================================================================\r\n * MAIN CLASS\r\n * ============================================================================\r\n * @hidden\r\n */\r\n/**\r\n * Use to create labels on circular axis.\r\n *\r\n * @see {@link IAxisLabelCircularEvents} for a list of available events\r\n * @see {@link IAxisLabelCircularAdapters} for a list of available Adapters\r\n */\r\nvar AxisLabelCircular = /** @class */ (function (_super) {\r\n    __extends(AxisLabelCircular, _super);\r\n    /**\r\n     * Constructor\r\n     */\r\n    function AxisLabelCircular() {\r\n        var _this = _super.call(this) || this;\r\n        /**\r\n         *\r\n         * @ignore\r\n         */\r\n        _this.fdx = 0;\r\n        /**\r\n         *\r\n         * @ignore\r\n         */\r\n        _this.fdy = 0;\r\n        _this.className = \"AxisLabelCircular\";\r\n        _this.padding(0, 0, 0, 0);\r\n        _this.location = 0.5;\r\n        _this.locationOnPath = 0.5;\r\n        _this.radius = 0;\r\n        _this.isMeasured = false;\r\n        _this.applyTheme();\r\n        return _this;\r\n    }\r\n    Object.defineProperty(AxisLabelCircular.prototype, \"relativeRotation\", {\r\n        /**\r\n         * @return Rotation angle\r\n         */\r\n        get: function () {\r\n            return this.getPropertyValue(\"relativeRotation\");\r\n        },\r\n        /**\r\n         * Relative rotation of the label.\r\n         *\r\n         * It is an angle to circle. In case 90, labels will be positioned like rays\r\n         * of light, if 0 - positioned along the circle.\r\n         *\r\n         * @param value Rotation angle\r\n         */\r\n        set: function (value) {\r\n            this.setPropertyValue(\"relativeRotation\", value, true);\r\n            if (!$type.hasValue(value)) {\r\n                this.rotation = undefined;\r\n                var dataItem = this.dataItem;\r\n                if (dataItem && dataItem.component) {\r\n                    dataItem.component.invalidateDataItems();\r\n                }\r\n            }\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(AxisLabelCircular.prototype, \"radius\", {\r\n        /**\r\n         * @return Distance (px)\r\n         */\r\n        get: function () {\r\n            return this.getPropertyValue(\"radius\");\r\n        },\r\n        /**\r\n         * Distance from axis circle to label in pixels or percent.\r\n         *\r\n         * @param value Distance (px or percent)\r\n         */\r\n        set: function (value) {\r\n            this.setPercentProperty(\"radius\", value, true, false, 10, false);\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(AxisLabelCircular.prototype, \"bent\", {\r\n        /**\r\n         * @return Bent?\r\n         */\r\n        get: function () {\r\n            return this.getPropertyValue(\"bent\");\r\n        },\r\n        /**\r\n         * Specifies if label should be bent along the circle.\r\n         *\r\n         * IMPORTANT: Use this with caution, since it is quite CPU-greedy.\r\n         *\r\n         * @since 4.1.2\r\n         * @default false\r\n         * @param  value  Bent?\r\n         */\r\n        set: function (value) {\r\n            this.setPropertyValue(\"bent\", value, true);\r\n            this.setPropertyValue(\"wrap\", false);\r\n            this.setPropertyValue(\"horizontalCenter\", \"none\");\r\n            this.setPropertyValue(\"verticalCenter\", \"none\");\r\n            if (value) {\r\n                this.setPropertyValue(\"dx\", 0);\r\n                this.setPropertyValue(\"dy\", 0);\r\n                this.setPropertyValue(\"x\", 0);\r\n                this.setPropertyValue(\"y\", 0);\r\n                this.setPropertyValue(\"rotation\", 0);\r\n                //this.setPropertyValue(\"relativeRotation\", undefined);\r\n                this.fdx = 0;\r\n                this.fdy = 0;\r\n                this.textAlign = \"middle\";\r\n            }\r\n            else {\r\n                if (this.textPathElement) {\r\n                    this.textPathElement.dispose();\r\n                    this.textPathElement = undefined;\r\n                }\r\n            }\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    /**\r\n     * Returns label radius in pixels.\r\n     *\r\n     * @param   axisRadius  Radius\r\n     * @return              Pixel radius\r\n     */\r\n    AxisLabelCircular.prototype.pixelRadius = function (axisRadius) {\r\n        var sign = 1;\r\n        if (this.inside) {\r\n            sign = -1;\r\n        }\r\n        return $utils.relativeToValue(this.radius, axisRadius) * sign;\r\n    };\r\n    /**\r\n     * Returns label horizontal radius in pixels.\r\n     *\r\n     * @param   axisRadius   Radius\r\n     * @param   axisRadiusY  Vertical radius\r\n     * @return               Radius\r\n     */\r\n    AxisLabelCircular.prototype.pixelRadiusY = function (axisRadius, axisRadiusY) {\r\n        var sign = 1;\r\n        if (this.inside) {\r\n            sign = -1;\r\n        }\r\n        var radius = this.radius;\r\n        if ($type.isNumber(radius)) {\r\n            radius *= axisRadiusY / axisRadius;\r\n            return $utils.relativeToValue(radius, axisRadius) * sign;\r\n        }\r\n        else {\r\n            return $utils.relativeToValue(radius, axisRadiusY) * sign;\r\n        }\r\n    };\r\n    /**\r\n     * [fixPosition description]\r\n     *\r\n     * @ignore Exclude from docs\r\n     * @todo Description\r\n     * @param point       Label affixation point\r\n     * @param axisRadius  Distance from point (px)\r\n     */\r\n    AxisLabelCircular.prototype.fixPosition = function (angle, axisRadius, axisRadiusY, dx, dy) {\r\n        if (!$type.isNumber(axisRadiusY)) {\r\n            axisRadiusY = axisRadius;\r\n        }\r\n        if (!$type.isNumber(dx)) {\r\n            dx = 0;\r\n        }\r\n        if (!$type.isNumber(dy)) {\r\n            dy = 0;\r\n        }\r\n        var point = { x: axisRadius * $math.cos(angle), y: axisRadiusY * $math.sin(angle) };\r\n        if (this.invalid) {\r\n            this.validate(); //@todo\" check if we need this\r\n        }\r\n        var isNegative = false;\r\n        var realRadius = this.radius;\r\n        if (realRadius instanceof Percent && realRadius.value < 0) {\r\n            isNegative = true;\r\n        }\r\n        else if (realRadius < 0) {\r\n            isNegative = true;\r\n        }\r\n        var relativeRotation = this.relativeRotation;\r\n        var labelRadius = this.pixelRadius(axisRadius);\r\n        if (this.bent) {\r\n            var point_1 = { x: (axisRadius + labelRadius) * $math.cos(angle + 180), y: (axisRadiusY + labelRadius * axisRadiusY / axisRadius) * $math.sin(angle + 180) };\r\n            this.path = $path.moveTo(point_1) + $path.arcTo(angle + 180, 360, axisRadius + labelRadius, axisRadiusY + labelRadius * axisRadiusY / axisRadius);\r\n            if (this.textPathElement) {\r\n                this.textPathElement.attr({ \"startOffset\": (this.locationOnPath * 100) + \"%\" });\r\n            }\r\n            return;\r\n        }\r\n        // WHEN ROTATED\r\n        if ($type.isNumber(relativeRotation)) {\r\n            this.horizontalCenter = \"none\";\r\n            this.verticalCenter = \"none\";\r\n            angle = $math.fitAngleToRange(angle, -180, 180);\r\n            var pixelWidth = this.bbox.width;\r\n            var pixelHeight = this.bbox.height;\r\n            var pixelPaddingBottom = this.pixelPaddingBottom;\r\n            var pixelPaddingTop = this.pixelPaddingTop;\r\n            var pixelPaddingLeft = this.pixelPaddingLeft;\r\n            var pixelPaddingRight = this.pixelPaddingRight;\r\n            if (angle > 90 || angle < -90) {\r\n                if (relativeRotation == -90) {\r\n                    relativeRotation = 90;\r\n                    pixelWidth = 0;\r\n                }\r\n            }\r\n            else {\r\n                if (relativeRotation == -90) {\r\n                    pixelHeight = -pixelHeight;\r\n                }\r\n                if (relativeRotation == 90) {\r\n                    relativeRotation = -90;\r\n                    pixelWidth = -pixelPaddingLeft - pixelPaddingRight;\r\n                    pixelHeight = -pixelHeight - pixelPaddingTop - pixelPaddingBottom;\r\n                }\r\n            }\r\n            this.rotation = relativeRotation + angle + 90;\r\n            var dH = $math.sin(relativeRotation) / 2;\r\n            var dW = $math.cos(relativeRotation) / 2;\r\n            var rotation = this.rotation;\r\n            this.dx = pixelHeight * dH * $math.sin(rotation) - pixelWidth * dW * $math.cos(rotation);\r\n            this.dy = -pixelHeight * dH * $math.cos(rotation) - pixelWidth * dW * $math.sin(rotation);\r\n            if (!this.inside) {\r\n                labelRadius += (pixelHeight + pixelPaddingBottom + pixelPaddingTop) * $math.cos(relativeRotation) + (pixelWidth + pixelPaddingLeft + pixelPaddingRight) * $math.sin(relativeRotation);\r\n            }\r\n            else {\r\n                if (angle > 90 || angle < -90) {\r\n                    labelRadius -= (pixelPaddingBottom + pixelPaddingTop) * $math.cos(relativeRotation) + (pixelPaddingLeft + pixelPaddingRight) * $math.sin(relativeRotation);\r\n                }\r\n                else {\r\n                    labelRadius += (pixelPaddingBottom + this.bbox.height + pixelPaddingTop) * $math.cos(relativeRotation) + (pixelPaddingLeft + pixelPaddingRight + this.bbox.width) * $math.sin(relativeRotation);\r\n                }\r\n            }\r\n            point.x += $math.cos(angle) * labelRadius;\r\n            point.y += $math.sin(angle) * labelRadius * axisRadiusY / axisRadius;\r\n        }\r\n        else {\r\n            // END OF ROTATED\r\n            this.horizontalCenter = \"middle\";\r\n            this.verticalCenter = \"middle\";\r\n            if (isNegative) {\r\n                this.dx = 0;\r\n                this.dy = 0;\r\n                point.x = (axisRadius + labelRadius) * $math.cos(angle);\r\n                point.y = (axisRadiusY + labelRadius * axisRadiusY / axisRadius) * $math.sin(angle);\r\n            }\r\n            else {\r\n                // we don't use valign for labels because then they would jump while animating. instead we modify dy depending on a y position\r\n                // this math makes dy to be 1 at the top of the circle, 0.5 at the middle and 1 at the bottom\r\n                // @todo with this math doesn't work well with inside = true\r\n                this.dy = this._measuredHeight / 2 * $math.sin(angle); //(1 - (point.y + axisRadiusY) / (2 * axisRadiusY));\r\n                // simmilar with dx\r\n                this.dx = this._measuredWidth / 2 * $math.cos(angle); //(1 - (point.x + axisRadius) / (2 * axisRadius));\r\n                point.x += $math.cos(angle) * labelRadius;\r\n                point.y += $math.sin(angle) * labelRadius * axisRadiusY / axisRadius;\r\n            }\r\n        }\r\n        point.x += dx;\r\n        point.y += dy;\r\n        this.fdx = this.dx;\r\n        this.fdy = this.dy;\r\n        this.moveTo(point);\r\n    };\r\n    return AxisLabelCircular;\r\n}(AxisLabel));\r\nexport { AxisLabelCircular };\r\n/**\r\n * Register class in system, so that it can be instantiated using its name from\r\n * anywhere.\r\n *\r\n * @ignore\r\n */\r\nregistry.registeredClasses[\"AxisLabelCircular\"] = AxisLabelCircular;\r\n"],"mappings":"AAAA;AACA;AACA;AACA,SAASA,SAAT,QAA0B,OAA1B;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,SAASC,SAAT,QAA0B,aAA1B;AACA,SAASC,QAAT,QAAyB,qBAAzB;AACA,OAAO,KAAKC,KAAZ,MAAuB,uBAAvB;AACA,OAAO,KAAKC,KAAZ,MAAuB,uBAAvB;AACA,OAAO,KAAKC,KAAZ,MAAuB,2BAAvB;AACA,OAAO,KAAKC,MAAZ,MAAwB,wBAAxB;AACA,SAASC,OAAT,QAAwB,0BAAxB;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,IAAIC,iBAAiB;AAAG;AAAe,UAAUC,MAAV,EAAkB;EACrDT,SAAS,CAACQ,iBAAD,EAAoBC,MAApB,CAAT;EACA;AACJ;AACA;;;EACI,SAASD,iBAAT,GAA6B;IACzB,IAAIE,KAAK,GAAGD,MAAM,CAACE,IAAP,CAAY,IAAZ,KAAqB,IAAjC;IACA;AACR;AACA;AACA;;;IACQD,KAAK,CAACE,GAAN,GAAY,CAAZ;IACA;AACR;AACA;AACA;;IACQF,KAAK,CAACG,GAAN,GAAY,CAAZ;IACAH,KAAK,CAACI,SAAN,GAAkB,mBAAlB;;IACAJ,KAAK,CAACK,OAAN,CAAc,CAAd,EAAiB,CAAjB,EAAoB,CAApB,EAAuB,CAAvB;;IACAL,KAAK,CAACM,QAAN,GAAiB,GAAjB;IACAN,KAAK,CAACO,cAAN,GAAuB,GAAvB;IACAP,KAAK,CAACQ,MAAN,GAAe,CAAf;IACAR,KAAK,CAACS,UAAN,GAAmB,KAAnB;;IACAT,KAAK,CAACU,UAAN;;IACA,OAAOV,KAAP;EACH;;EACDW,MAAM,CAACC,cAAP,CAAsBd,iBAAiB,CAACe,SAAxC,EAAmD,kBAAnD,EAAuE;IACnE;AACR;AACA;IACQC,GAAG,EAAE,YAAY;MACb,OAAO,KAAKC,gBAAL,CAAsB,kBAAtB,CAAP;IACH,CANkE;;IAOnE;AACR;AACA;AACA;AACA;AACA;AACA;AACA;IACQC,GAAG,EAAE,UAAUC,KAAV,EAAiB;MAClB,KAAKC,gBAAL,CAAsB,kBAAtB,EAA0CD,KAA1C,EAAiD,IAAjD;;MACA,IAAI,CAACvB,KAAK,CAACyB,QAAN,CAAeF,KAAf,CAAL,EAA4B;QACxB,KAAKG,QAAL,GAAgBC,SAAhB;QACA,IAAIC,QAAQ,GAAG,KAAKA,QAApB;;QACA,IAAIA,QAAQ,IAAIA,QAAQ,CAACC,SAAzB,EAAoC;UAChCD,QAAQ,CAACC,SAAT,CAAmBC,mBAAnB;QACH;MACJ;IACJ,CAxBkE;IAyBnEC,UAAU,EAAE,IAzBuD;IA0BnEC,YAAY,EAAE;EA1BqD,CAAvE;EA4BAf,MAAM,CAACC,cAAP,CAAsBd,iBAAiB,CAACe,SAAxC,EAAmD,QAAnD,EAA6D;IACzD;AACR;AACA;IACQC,GAAG,EAAE,YAAY;MACb,OAAO,KAAKC,gBAAL,CAAsB,QAAtB,CAAP;IACH,CANwD;;IAOzD;AACR;AACA;AACA;AACA;IACQC,GAAG,EAAE,UAAUC,KAAV,EAAiB;MAClB,KAAKU,kBAAL,CAAwB,QAAxB,EAAkCV,KAAlC,EAAyC,IAAzC,EAA+C,KAA/C,EAAsD,EAAtD,EAA0D,KAA1D;IACH,CAdwD;IAezDQ,UAAU,EAAE,IAf6C;IAgBzDC,YAAY,EAAE;EAhB2C,CAA7D;EAkBAf,MAAM,CAACC,cAAP,CAAsBd,iBAAiB,CAACe,SAAxC,EAAmD,MAAnD,EAA2D;IACvD;AACR;AACA;IACQC,GAAG,EAAE,YAAY;MACb,OAAO,KAAKC,gBAAL,CAAsB,MAAtB,CAAP;IACH,CANsD;;IAOvD;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACQC,GAAG,EAAE,UAAUC,KAAV,EAAiB;MAClB,KAAKC,gBAAL,CAAsB,MAAtB,EAA8BD,KAA9B,EAAqC,IAArC;MACA,KAAKC,gBAAL,CAAsB,MAAtB,EAA8B,KAA9B;MACA,KAAKA,gBAAL,CAAsB,kBAAtB,EAA0C,MAA1C;MACA,KAAKA,gBAAL,CAAsB,gBAAtB,EAAwC,MAAxC;;MACA,IAAID,KAAJ,EAAW;QACP,KAAKC,gBAAL,CAAsB,IAAtB,EAA4B,CAA5B;QACA,KAAKA,gBAAL,CAAsB,IAAtB,EAA4B,CAA5B;QACA,KAAKA,gBAAL,CAAsB,GAAtB,EAA2B,CAA3B;QACA,KAAKA,gBAAL,CAAsB,GAAtB,EAA2B,CAA3B;QACA,KAAKA,gBAAL,CAAsB,UAAtB,EAAkC,CAAlC,EALO,CAMP;;QACA,KAAKhB,GAAL,GAAW,CAAX;QACA,KAAKC,GAAL,GAAW,CAAX;QACA,KAAKyB,SAAL,GAAiB,QAAjB;MACH,CAVD,MAWK;QACD,IAAI,KAAKC,eAAT,EAA0B;UACtB,KAAKA,eAAL,CAAqBC,OAArB;UACA,KAAKD,eAAL,GAAuBR,SAAvB;QACH;MACJ;IACJ,CAtCsD;IAuCvDI,UAAU,EAAE,IAvC2C;IAwCvDC,YAAY,EAAE;EAxCyC,CAA3D;EA0CA;AACJ;AACA;AACA;AACA;AACA;;EACI5B,iBAAiB,CAACe,SAAlB,CAA4BkB,WAA5B,GAA0C,UAAUC,UAAV,EAAsB;IAC5D,IAAIC,IAAI,GAAG,CAAX;;IACA,IAAI,KAAKC,MAAT,EAAiB;MACbD,IAAI,GAAG,CAAC,CAAR;IACH;;IACD,OAAOrC,MAAM,CAACuC,eAAP,CAAuB,KAAK3B,MAA5B,EAAoCwB,UAApC,IAAkDC,IAAzD;EACH,CAND;EAOA;AACJ;AACA;AACA;AACA;AACA;AACA;;;EACInC,iBAAiB,CAACe,SAAlB,CAA4BuB,YAA5B,GAA2C,UAAUJ,UAAV,EAAsBK,WAAtB,EAAmC;IAC1E,IAAIJ,IAAI,GAAG,CAAX;;IACA,IAAI,KAAKC,MAAT,EAAiB;MACbD,IAAI,GAAG,CAAC,CAAR;IACH;;IACD,IAAIzB,MAAM,GAAG,KAAKA,MAAlB;;IACA,IAAId,KAAK,CAAC4C,QAAN,CAAe9B,MAAf,CAAJ,EAA4B;MACxBA,MAAM,IAAI6B,WAAW,GAAGL,UAAxB;MACA,OAAOpC,MAAM,CAACuC,eAAP,CAAuB3B,MAAvB,EAA+BwB,UAA/B,IAA6CC,IAApD;IACH,CAHD,MAIK;MACD,OAAOrC,MAAM,CAACuC,eAAP,CAAuB3B,MAAvB,EAA+B6B,WAA/B,IAA8CJ,IAArD;IACH;EACJ,CAbD;EAcA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;;;EACInC,iBAAiB,CAACe,SAAlB,CAA4B0B,WAA5B,GAA0C,UAAUC,KAAV,EAAiBR,UAAjB,EAA6BK,WAA7B,EAA0CI,EAA1C,EAA8CC,EAA9C,EAAkD;IACxF,IAAI,CAAChD,KAAK,CAAC4C,QAAN,CAAeD,WAAf,CAAL,EAAkC;MAC9BA,WAAW,GAAGL,UAAd;IACH;;IACD,IAAI,CAACtC,KAAK,CAAC4C,QAAN,CAAeG,EAAf,CAAL,EAAyB;MACrBA,EAAE,GAAG,CAAL;IACH;;IACD,IAAI,CAAC/C,KAAK,CAAC4C,QAAN,CAAeI,EAAf,CAAL,EAAyB;MACrBA,EAAE,GAAG,CAAL;IACH;;IACD,IAAIC,KAAK,GAAG;MAAEC,CAAC,EAAEZ,UAAU,GAAGvC,KAAK,CAACoD,GAAN,CAAUL,KAAV,CAAlB;MAAoCM,CAAC,EAAET,WAAW,GAAG5C,KAAK,CAACsD,GAAN,CAAUP,KAAV;IAArD,CAAZ;;IACA,IAAI,KAAKQ,OAAT,EAAkB;MACd,KAAKC,QAAL,GADc,CACG;IACpB;;IACD,IAAIC,UAAU,GAAG,KAAjB;IACA,IAAIC,UAAU,GAAG,KAAK3C,MAAtB;;IACA,IAAI2C,UAAU,YAAYtD,OAAtB,IAAiCsD,UAAU,CAAClC,KAAX,GAAmB,CAAxD,EAA2D;MACvDiC,UAAU,GAAG,IAAb;IACH,CAFD,MAGK,IAAIC,UAAU,GAAG,CAAjB,EAAoB;MACrBD,UAAU,GAAG,IAAb;IACH;;IACD,IAAIE,gBAAgB,GAAG,KAAKA,gBAA5B;IACA,IAAIC,WAAW,GAAG,KAAKtB,WAAL,CAAiBC,UAAjB,CAAlB;;IACA,IAAI,KAAKsB,IAAT,EAAe;MACX,IAAIC,OAAO,GAAG;QAAEX,CAAC,EAAE,CAACZ,UAAU,GAAGqB,WAAd,IAA6B5D,KAAK,CAACoD,GAAN,CAAUL,KAAK,GAAG,GAAlB,CAAlC;QAA0DM,CAAC,EAAE,CAACT,WAAW,GAAGgB,WAAW,GAAGhB,WAAd,GAA4BL,UAA3C,IAAyDvC,KAAK,CAACsD,GAAN,CAAUP,KAAK,GAAG,GAAlB;MAAtH,CAAd;MACA,KAAKgB,IAAL,GAAY7D,KAAK,CAAC8D,MAAN,CAAaF,OAAb,IAAwB5D,KAAK,CAAC+D,KAAN,CAAYlB,KAAK,GAAG,GAApB,EAAyB,GAAzB,EAA8BR,UAAU,GAAGqB,WAA3C,EAAwDhB,WAAW,GAAGgB,WAAW,GAAGhB,WAAd,GAA4BL,UAAlG,CAApC;;MACA,IAAI,KAAKH,eAAT,EAA0B;QACtB,KAAKA,eAAL,CAAqB8B,IAArB,CAA0B;UAAE,eAAgB,KAAKpD,cAAL,GAAsB,GAAvB,GAA8B;QAA/C,CAA1B;MACH;;MACD;IACH,CA/BuF,CAgCxF;;;IACA,IAAIb,KAAK,CAAC4C,QAAN,CAAec,gBAAf,CAAJ,EAAsC;MAClC,KAAKQ,gBAAL,GAAwB,MAAxB;MACA,KAAKC,cAAL,GAAsB,MAAtB;MACArB,KAAK,GAAG/C,KAAK,CAACqE,eAAN,CAAsBtB,KAAtB,EAA6B,CAAC,GAA9B,EAAmC,GAAnC,CAAR;MACA,IAAIuB,UAAU,GAAG,KAAKC,IAAL,CAAUC,KAA3B;MACA,IAAIC,WAAW,GAAG,KAAKF,IAAL,CAAUG,MAA5B;MACA,IAAIC,kBAAkB,GAAG,KAAKA,kBAA9B;MACA,IAAIC,eAAe,GAAG,KAAKA,eAA3B;MACA,IAAIC,gBAAgB,GAAG,KAAKA,gBAA5B;MACA,IAAIC,iBAAiB,GAAG,KAAKA,iBAA7B;;MACA,IAAI/B,KAAK,GAAG,EAAR,IAAcA,KAAK,GAAG,CAAC,EAA3B,EAA+B;QAC3B,IAAIY,gBAAgB,IAAI,CAAC,EAAzB,EAA6B;UACzBA,gBAAgB,GAAG,EAAnB;UACAW,UAAU,GAAG,CAAb;QACH;MACJ,CALD,MAMK;QACD,IAAIX,gBAAgB,IAAI,CAAC,EAAzB,EAA6B;UACzBc,WAAW,GAAG,CAACA,WAAf;QACH;;QACD,IAAId,gBAAgB,IAAI,EAAxB,EAA4B;UACxBA,gBAAgB,GAAG,CAAC,EAApB;UACAW,UAAU,GAAG,CAACO,gBAAD,GAAoBC,iBAAjC;UACAL,WAAW,GAAG,CAACA,WAAD,GAAeG,eAAf,GAAiCD,kBAA/C;QACH;MACJ;;MACD,KAAKhD,QAAL,GAAgBgC,gBAAgB,GAAGZ,KAAnB,GAA2B,EAA3C;MACA,IAAIgC,EAAE,GAAG/E,KAAK,CAACsD,GAAN,CAAUK,gBAAV,IAA8B,CAAvC;MACA,IAAIqB,EAAE,GAAGhF,KAAK,CAACoD,GAAN,CAAUO,gBAAV,IAA8B,CAAvC;MACA,IAAIhC,QAAQ,GAAG,KAAKA,QAApB;MACA,KAAKqB,EAAL,GAAUyB,WAAW,GAAGM,EAAd,GAAmB/E,KAAK,CAACsD,GAAN,CAAU3B,QAAV,CAAnB,GAAyC2C,UAAU,GAAGU,EAAb,GAAkBhF,KAAK,CAACoD,GAAN,CAAUzB,QAAV,CAArE;MACA,KAAKsB,EAAL,GAAU,CAACwB,WAAD,GAAeM,EAAf,GAAoB/E,KAAK,CAACoD,GAAN,CAAUzB,QAAV,CAApB,GAA0C2C,UAAU,GAAGU,EAAb,GAAkBhF,KAAK,CAACsD,GAAN,CAAU3B,QAAV,CAAtE;;MACA,IAAI,CAAC,KAAKc,MAAV,EAAkB;QACdmB,WAAW,IAAI,CAACa,WAAW,GAAGE,kBAAd,GAAmCC,eAApC,IAAuD5E,KAAK,CAACoD,GAAN,CAAUO,gBAAV,CAAvD,GAAqF,CAACW,UAAU,GAAGO,gBAAb,GAAgCC,iBAAjC,IAAsD9E,KAAK,CAACsD,GAAN,CAAUK,gBAAV,CAA1J;MACH,CAFD,MAGK;QACD,IAAIZ,KAAK,GAAG,EAAR,IAAcA,KAAK,GAAG,CAAC,EAA3B,EAA+B;UAC3Ba,WAAW,IAAI,CAACe,kBAAkB,GAAGC,eAAtB,IAAyC5E,KAAK,CAACoD,GAAN,CAAUO,gBAAV,CAAzC,GAAuE,CAACkB,gBAAgB,GAAGC,iBAApB,IAAyC9E,KAAK,CAACsD,GAAN,CAAUK,gBAAV,CAA/H;QACH,CAFD,MAGK;UACDC,WAAW,IAAI,CAACe,kBAAkB,GAAG,KAAKJ,IAAL,CAAUG,MAA/B,GAAwCE,eAAzC,IAA4D5E,KAAK,CAACoD,GAAN,CAAUO,gBAAV,CAA5D,GAA0F,CAACkB,gBAAgB,GAAGC,iBAAnB,GAAuC,KAAKP,IAAL,CAAUC,KAAlD,IAA2DxE,KAAK,CAACsD,GAAN,CAAUK,gBAAV,CAApK;QACH;MACJ;;MACDT,KAAK,CAACC,CAAN,IAAWnD,KAAK,CAACoD,GAAN,CAAUL,KAAV,IAAmBa,WAA9B;MACAV,KAAK,CAACG,CAAN,IAAWrD,KAAK,CAACsD,GAAN,CAAUP,KAAV,IAAmBa,WAAnB,GAAiChB,WAAjC,GAA+CL,UAA1D;IACH,CA7CD,MA8CK;MACD;MACA,KAAK4B,gBAAL,GAAwB,QAAxB;MACA,KAAKC,cAAL,GAAsB,QAAtB;;MACA,IAAIX,UAAJ,EAAgB;QACZ,KAAKT,EAAL,GAAU,CAAV;QACA,KAAKC,EAAL,GAAU,CAAV;QACAC,KAAK,CAACC,CAAN,GAAU,CAACZ,UAAU,GAAGqB,WAAd,IAA6B5D,KAAK,CAACoD,GAAN,CAAUL,KAAV,CAAvC;QACAG,KAAK,CAACG,CAAN,GAAU,CAACT,WAAW,GAAGgB,WAAW,GAAGhB,WAAd,GAA4BL,UAA3C,IAAyDvC,KAAK,CAACsD,GAAN,CAAUP,KAAV,CAAnE;MACH,CALD,MAMK;QACD;QACA;QACA;QACA,KAAKE,EAAL,GAAU,KAAKgC,eAAL,GAAuB,CAAvB,GAA2BjF,KAAK,CAACsD,GAAN,CAAUP,KAAV,CAArC,CAJC,CAIsD;QACvD;;QACA,KAAKC,EAAL,GAAU,KAAKkC,cAAL,GAAsB,CAAtB,GAA0BlF,KAAK,CAACoD,GAAN,CAAUL,KAAV,CAApC,CANC,CAMqD;;QACtDG,KAAK,CAACC,CAAN,IAAWnD,KAAK,CAACoD,GAAN,CAAUL,KAAV,IAAmBa,WAA9B;QACAV,KAAK,CAACG,CAAN,IAAWrD,KAAK,CAACsD,GAAN,CAAUP,KAAV,IAAmBa,WAAnB,GAAiChB,WAAjC,GAA+CL,UAA1D;MACH;IACJ;;IACDW,KAAK,CAACC,CAAN,IAAWH,EAAX;IACAE,KAAK,CAACG,CAAN,IAAWJ,EAAX;IACA,KAAKxC,GAAL,GAAW,KAAKuC,EAAhB;IACA,KAAKtC,GAAL,GAAW,KAAKuC,EAAhB;IACA,KAAKe,MAAL,CAAYd,KAAZ;EACH,CAzGD;;EA0GA,OAAO7C,iBAAP;AACH,CAvQsC,CAuQrCP,SAvQqC,CAAvC;;AAwQA,SAASO,iBAAT;AACA;AACA;AACA;AACA;AACA;AACA;;AACAN,QAAQ,CAACoF,iBAAT,CAA2B,mBAA3B,IAAkD9E,iBAAlD"},"metadata":{},"sourceType":"module"}